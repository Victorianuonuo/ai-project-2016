Session  18  Automatic  Programming 

PROVING  THEOREMS  ABOUT  LISP  FUNCTIONS 

by 

Robert  S.  Boyer  and  J  S t r o t h er  Moore 
Department  of  C o m p u t a t i o n al  L o g i c, 
U n i v e r s i ty  of  E d i n b u r g h,  S c o t l a n d. 

ABSTRACT 

OUR  LISP  SUBSET 

i n d u c t i on  which  we  have 

implemented 
t h at  a u t o m a t i c a l ly  proves  a  wide  v a r i e ty  of 
The  method 

We  d e s c r i be  some  s i m p le  h e u r i s t i cs  combining  e v a l u a t i on 
and  mathematical 
in 
a  program 
theorems  about  r e c u r s i ve  LISP 
the  program  uses 
to  generate 
d e s c r i b ed  at 
gram 
i n c l u de 
i ts  own 
a  p a r t i c u l ar  SORT  program  is  c o r r e c t. 
c o n t a i ns  a 

theorems  proved  by  t he  p r o­
is 
t h at 

theorems  proved  by  t he  p r o g r a m. 

l e n g t h. 
The 
t h at  REVERSE 

f u n c t i o n s. 
i n d u c t i on 

i n v e r se  and 

Appendix  B 

f o r m u l as 

l i st  of 

the 

is 

KEY  WORDS 

LISP,  a u t o m a t ic 
p r o v i ng  programs  c o r r e c t. 

theorem  p r o v i n g,  s t r u c t u r al 

i n d u c t i o n, 

INTRODUCTION 

We  use  a  subset  of  pure  LISP  which  has  as  p r i m i t i v es 
N I L,  CONS,  CAR,  CDR,  COND,  and  EQUAL.  We  do  no.t  prove 
theorems  about 
f u n c t i o ns 
RPLACA,  QUOTE,  or  LABEL. 
r e s e nt  n a t u r al  numbers: 
and  ADP1 
is  d e f i n ed  a s; 

to  r e p­
is  (CONS  N il  N I L ), 

i n v o l ve  s i de  e f f e c t s, 

We  use 
is  N I L,  1 

l i s ts  of  NIL 

t h at 

0 

(LAMBDA  (X) 

(CONS  NIL  X))  . 

(Our  a r i t h m e t ic 
a r i t h m e t i c .) 

is 

thus  a  v e r s i on  of  Peano  successor 

Our  e q u a l i ty  p r i v i t i ve 
COND  p r i m i t i ve 
t a k es 
w i t h o ut 
(COND  (A  B) 

l o ss  of  p o w e r ). 

(T  C)) 

is  EQUAL 
t h r ee  arguments 

r a t h er  than  EQ. 

Our 
( f or  s i m p l i c i ty 

(COND  A  B  C) 

in  our  system  is 

in  more 

t r a d i t i o n al  LISP  systems. 

in  a  f i r s t-

t he  elementary 
We  use  a  subset  of  LISP  as  our 

t h e o ry 
language 

l i st  p r o c e s s i ng  f u n c t i o ns  are  easy 
theorems  can  be  n a t u r a l ly 

to 

f u r t h e r m o r e,  LISP  has  a  s i m p le  s y n t ax 
in  A r t i f i c i al  I n t e l l i g e n c e. 

We 

to 

t h e o ry  of 

r e c u r s i ve 

l i s t s,  a k in 

in  LISP  and  because 
in  L I S P; 

We  are  concerned  w i th  p r o v i ng  theorems 
o r d er 
of  numbers. 
because 
w r i te 
s t a t ed 
and 
employ  a  LISP 
h e u r i s t ic  w h i ch  produces 
m a t i on  about  how  t he 
w i th 
r u l es  of  LISP  and  a  h e u r i s t ic 
theorem  being  p r o v e d. 

i n t e r p r e t er  f a i l s. 

i n t e r p r e t er  to 

is  u n i v e r s al 

i n d u c t i on 

' r u n'  our 

the 

We  combine 
i n d u c t i on  h e u r i s t ic  a  s et  of  simple  r e w r i te 

theorems  and  a 

f o r m u l as 

f r om 

i n f o r­

f or  g e n e r a l i z i ng  t he 

Our  program  accepts  as 

i n p ut  a  LJSP  e x p r e s s i o n,  e . g ., 

(EQUAL  (REVERSE  (REVERSE  A))  A ), 

t h is  paper)  which  stand 

p o s s i b ly  i n v o l v i ng  skolem  c o n s t a n ts  ( e . g .,  A,  B  and  C 
t h r o u g h o ut 
q u a n t i f i ed  v a r i a b l es  r a n g i ng  over  a ll 
gram  attempts  to  show 
s s i on 
is  always  equal 
a n ts  are 
have  proved  a u t o m a t i c a l ly 

The  p r o­
i n p ut  e x p r e­
the  skolem  c o n s t­

the  v a l ue  of 
{whenever 
l i s t s ). 

r e p l a c ed  by  a r b i t r a ry 

f or  u n i v e r s a l ly 

Theorems  we 

l i s t s. 
the 

t h at 
to  T 

i n c l u d e: 

(EQUAL  (REVERSE  (REVERSE  A))  A) 
(IMPLIES  (OR 

(MEMBER  A  B) 
(MEMBER  A  (UNION  B  c))) 

(MEMBER  A  C)) 

and 

[ORDERED  (SORT  A)) 

is  a  p r i m i t i ve 

f u n c t i on  ( i . e.  b u i lt 

where  EQUAL 
the  theorem  p r o v e r)  but  REVERSE, 
UNION,  ORDERED,  and  SORT  are  d e f i n ed  by 
program. 
LISP  p r i m i t i v es  and 
the  uBer. 
u s e r. 

The  program  uses  o n ly  i ts  knowledge  of  the 
the  LISP  d e f i n i t i o ns  s u p p l i ed  by 
the 

f u r t h er  i n f o r m a t i on 

IMPLIES,  OR,  MEMBER, 

r e q u i r ed  of 

i n to 

t he  user  of  the 

No 

is 

T h is  paper  d e s c r i b es  many  aspects  of 
b r e v i t y. 
p a rt 

t h o r o u gh  p r e s e n t a t i on 

II  of  Moore*'a:  t h e s i s. 

A 

the  program  in 
f o r t h c o m i ng  in 

is 

the 

The  u s e r of 
t i o ns  almost  e x a c t ly  as 
DEFINE. 
F or  example, 

theorem  p r o v er  s u p p l i es 

f u n c t i on  d e f i n i­

in  L I S P,  w i th 

the 

f u n c t i on 

DEFINE  ( 

(APPEND  {LAMBDA  (X  Y) 

(COND  X 

(CONS  (CAR  X) 

(APPEND  (CDR  X)  Y) )J 

Y )» 

). 

EVAL 

is  s i m i l ar 
EVAL  a p p l i es 
l i ke  COND. 

in  many  ways 

to 
f u n c t i on  d e f­

EVAL 

is 

i n t e r p r e t e r; 

i n t e r p r e t e r,  EVAL, 

Our  LISP 
a  normal  LISP 
i n i t i o ns  and  handles  p r i m i t i v es 
r e c u r s i v e; 
e v a l u a t i ng  f u n c t i on  d e f i n i t i o n s. 
p r o v i s i o ns 
which 
t he  b e h a v i o ur  of  our  EVAL: 

they  appear. 

it  e v a l u a t es  arguments  b e f o re  a p p l y i ng  and 
Our  EVAL  has  s p e c i al 

f or  h a n d l i ng  skolem  c o n s t a n ts  and 
f o l l o w i ng  examples 

The 

terms 
i l l u s t r a te 

in 

-  NIL 

EVAL(  NIL  ) 
EVAL  {  A  )  =  A 
EVAL( 
EVAL( 
EVAL 
EVAL(  (COND  (CONS  A  B)  C  D)  )  =  C 
EVAL( 

(CONS  A  B)  )  =  (CONS  A  B) 
(CAR  (CONS  A  B)) 
)  =  A 
(CDR  (CAR  (CONS  A  B)J) 

(APPEND  (CONS  A  B)  C)  )  =  (CONS  A 

)  =  (CDR  A) 

(APPEND  B  C)) 

l a st  example 

The 
v a l u es  of  A,  B  and  C, 
n ot  N I L,  so 
can  be  e v a l u a t e d. 

t h at 

is 

j u s t i f i ed  because  r e g a r d l e ss  of 
to  APPEND 

the 
f i r st  argument 
is 
in  t he  d e f i n i t i on  of  APPEND 

the 
the  COND 

t r i es 
it 

EVAL 
because 
(See 

to  e v a l u a te  (APPEND  B  C) 
' r e c u r s es 

i n t o1 

t he  skolem  c o n s t a nt  B. 

f u r t h er  but 

f a i ls 

the  d e f i n i t i on  of  APPEND  above.) 

t he 

is  a 
f u n c t i o n,  we  r e c u r s i v e ly  e v a l u a te  t he  arguments 
C a ll 

EVAL  b i n ds 

tn)  where 

form  ( f oo 

f oo 

the 

. .. 

ti 

t j. 

ti( 
t h e ir  v a l u e s, 
If  a 

t j _,  and 
t h en 
r e c u r s i ve  c a ll 

When  e v a l u a t i ng 
d e f i n ed 
f i r s t. 
f o r m al  v a r i a b l es  of  f oo 
e v a l u a t es 
t h is 
of 
ments  are  e v a l u a t ed  aa  u s u a l. 
e v a l u a t ed  arguments 

t he  v a l ue  of 
to 

is  encountered 

t he  d e f i n i t i on  of  f o o. 

f oo 

in 

f u n c t i on  body 

Then, 

if  one  of 

t he  a r g u­
the 
it 

i8  a  CAR  or  CDR  e x p r e s s i o n, 

is 

486 

the  BOMBLIST. 

In  t h is  case  the 
t h is  recursive 
The  current  evaluation  of  the  function  body  is 

added  to  a  l i st  called 
d e f i n i t i on  of  foo  is  not  re-applied  for 
c a l l. 
continued  in  the  hopes  of  adding  more  terms  to  the 
BOHBLIST. 
. ..  t l)  . 

F i n a l l y,  EVAL  returns  (foo 

t1 

Thus,  in  evaluating  (APPEND  B  C) 
(APPEND  (CDR  B)  C) 
APPEND. 
recursion  on  B. 
the  value  of (APPEND  B  C). 

(CDR  B) 

is  encountered  in  the  d e f i n i t i on  of 
is  added  to  the  BOHBLIST  indicating 
is  returned  as 

F i n a l l y,  (APPEND  B  C) 

the  recursive  c a ll 

EVALUATION AND  INDUCTION 

P a r t i al  evaluation  is  s u f f i c i e nt 
theorems, 

for  example: 

to  prove  a  few  t r i v i al 

(EQUAL  (APPEND  NIL  B)  B) 

EVALs  to  T  since  p a r t i al  evaluation  of  the  APPEND 
yields  B,  even  though  the  structure  of  B  is  not  known. 
However, 
simple  theorems  about  recursive  LISP  functions. 

induction  is  usually  needed  to  prove  even 

is 

The  paradigm  for  evaluating  a 

i n t u i t i v e ly  clear  that  evaluation  arid 

It 
are  complements. 
simp]e  recursive  function  FOO  i s:  evaluate  (FOO  (CONS 
A  B)) 
separately. 
that  (FOO  X) 
(FOO  ML) 
show  that  (FOO  (CONS  A  B)) 

The  paradigm  f or  a  simple  inductive  proof 
is  T  for  any  argument  X  i s: 

in  terms  of  (FOO  B)  and  handle  the  NIL  case 

is  T,  and  then  assuming  that  (?00  P) 

show  that 
is  T, 

induction 

is  T. 

provided  that 

the 

recursion  s t a r ts  with  some  structure  and 
it  while  induction  starts  with  NIL  and  builds 

In  p a r t i c u l a r, 
decomposes 
This  duality  cim  be  used  to  great  advantage: 
up. 
Evaluation  can  be  used  to  reduce  the  induction  conclu­
sion  (FOO  (CONS  A  B)) 
induction  hypothesis.  (FQO  B)T 

to  a  statement  involving  the 

the 

is  T, 

To  show  that  (FOO  NIL) 

is  one  cf  the  structures  that  FOO  decom­

(CONS  A  B) 
poses  in  i ts  recursion. 
Suppose  that  we  wish  to  prove  by  induction  that  (FOO  X) 
is  T  for  a ll  X. 
obvious  thing-  to  do  is  c a ll  EVAL  and  l et  evaluation 
solve  the  problem  ( f or  example,  EVAl(  (APPEND  NIL  B)  ) 
is  B) .  We  then  assume  that  {FOO  B) 
is  T,  and  t ry  to 
show  that  (FOO  (CONS  A  B)) 
constant  A. 
EVAL  again  and  l et  the  recursion  in  FOO  decompose  the 
(CONS  A  B). 
simple  expression  E,  involving  (FOO  B);  we  then  use 
the  hypothesis  that  (FOO  B) 
is  T  to  show  that  E  is  T. 
This  process 
next  two  sections. 

The  obvious  thing  to  do  now  is  to  c a ll 

The  result  w i ll  (hopefully)  be  some 

is  i l l u s t r a t ed  by  the  examples 

is  T,  for  a  new  skolem 

in  the 

to  induct  upon. 

if  FOO  has  more  than  one  argument,  one  must 

induct  on  the  structures  that  FOO  recurses 

Of  course, 
But  the  l i nk 
choose  which  one(s) 
between  evaluation  and  induction  makes  the  choice 
obvious: 
on,  that  i s,  on  the  structures  that  are  being  recur­
sively  decomposed  by  FOO, 
By  choosing  those  s t r u c t­
ures  we  insure  that  when  EVAL  is  called  on  the  induct­
ion  conclusion,  (FOO  (CONS  A  B ) ),  FOO  w i ll  be  able  to 
recurse  at  least  one  step  and 
reduced  by  EVAL  to  one  i n v o l v i ng  the  induction  hypo­
thesis,  (FOO  B). 

the  problem  w i ll  be 

the  terms  that  FOO  is  t r y i ng  to  recurse  on 

However, 
are  just  those  that  generate  the 
e a r l i e r. 
To  determine  what  to  induct  upon  we  f i r st 
EVAL  the  expression  (expecting  to  f a i l)  and  then  i n­
duct  upon  some  term  on  the  BOHBLIST,  that  i s,  some 
term  which  EVAL  f a i l ed  to  evaluate. 

' e r r o r s'  noted 

487 

USING  THE  INDUCTION  HYPOTHESIS  AND  GENERALIZATION. 

similar  theorem: 

Using  the  induction  hypothesis  is  not  always  as  easy  as 
it  was  above. 
A  good  example  occurs  in  our  program's 
proof  of: 

(EQUAL  (REVERSE  (APPEND  A  B)) 

(APPEND  (REVERSE  B)  (REVERSE  A ) ) ), 

(8) 

(EQUAL  (REVERSE  (REVERSE  A))  A), 

where  the  d e f i n i t i on  of  REVERSE  i s: 

(LAMBDA 

(x) 
(COND X 

(APPEND  (REVERSE  (CDR  X)) 

(CONS  (CAB  X)  NIL)) 

N I L ). 

If  we  induct  on  A  in  (8)  we  f i nd  that  the  NIL  case 
evaluates  to  T.  We  therefore  assume  (8)  as  our  indu­
ction  hypothesis  and  t ry  to  prove: 

(9) 

(EQUAL  (REVERSE  (REVERSE  (CONS  A1  A)))  (CONS  Al  A)) 

This  evaluates  to: 

(10)  (EQUAL  (REVERSE  (APPEND  (REVERSE  A)  (CONS  A1  NIL))) 

(CONS  Al  A)) 

We  now  wish  to  use  the  induction  hypothesis,  ( 8 ). 
it  is  an  equality  our  h e u r i s t ic  is  to  ' c r o s s-
Since 
f e r t i l i z e' 
(10)  with  i t,  by  replacing  the  A  in  the 
right-hand  side  of  (10)  by  the  left-hand  side  of  ( 8 ), 
g i v i n g: 

(11)  (EQUAL  (REVERSE  (APPEND  (REVERSE  A)  (CONS  A1  NIL))) 

(CONS  Al  (REVERSE  (REVERSE  A ) ) ) ). 

We  then  consider  (8) 
We  must  now  prove  (11) . 

to  be  'used'  and  throw  it  away. 

At  t h is  point  we  note  that  (REVERSE  A) 
which  appears  on  both  sides  of  an  EQUAL. 
from  the  d e f i n i t i on  of  REVERSE  the  program  can  deter­
mine  that  the  output  of  (REVERSE  A)  can  be  any  l i st  at 
a l l.  On  these  grounds  we  choose  to  generalize  the 
theorem  to  be  proved  by  replacing  (REVERSE  A) 
by  a  new  skolem  constant,  B,  and  set  out  to  prove: 
(12)  (EQUAL  (REVERSE  (APPEND  B  (CONS  A1  NIL))) 

is  a  subformula 
Furthermore, 

in  (11) 

(CONS  Al  (REVERSE  B ) ) ). 

EVAL  t e l ls  us  to  induct  on 

is  easy  to  prove. 

The  NIL  case  EVALs  to  T.  Assuming  (12)  as  the 

But  (12) 
B. 
induction  hypothesis,  we  EVAL  the  'CONS  case': 
(EQUAL  (REVERSE  (APPEND  (CONS  B1  B)(C0NSA1  NIL))) 
(13) 
(14) 

(CONS  Al  (REVERSE  (CONS  B1  B))))  and  get 

(EQUAL 
(APPEND  (REVERSE  (APPEND  B  (CONS  A1  NIL))) 

(CONS  B1  NIL)) 

(CONS  A1  (APPEND  {REVERSE  B)  (CONS  B1  N I L ) ) ) ). 

We  now  use  our  hypothesis,  (12),  by  c r o s s - f e r t i l i z i ng 
(14)  with  i t,  replacing  (REVERSE  (APPEND  B  (CONS  A1 
NIL))) 
side  of  (12),  y i e l d i n g: 

in  the  left-hand  side  of  (14)  by  the  right-hand 

(15)  (EQUAL 

(APPEND  (CONS  A1  (REVERSE  B))  (COHS  B1  MIL)) 
(CONS  A1  (APPEND  (REVERSE  B)  (CONS  BI  NIL)))) 

F i n a l l y,  (15)  EVALs  to  T  because  the  left-hand  side 
APPEND  evaluates  t o: 

(CONS  A1  (APPEND  (REVERSE  B)  (CCNS  B1  N I L ) ) ), 

which  is  the  right-hand  side,  so  the  EQUAL  returns  T. 
The  theorem  is  therefore  proved. 

Our  theorem  prover  takes  8  seconds  to  produce  t h is 
If  the  reader  thinks  that  t h is  theorem  is 
proof. 
u t t e r ly  t r i v i a l,  he  is 
i n v i t ed  to  t ry  to  prove  the 

which  is  also  proved  by  the  program. 

A  DESCRIPTION  OF  THE  PROGRAM. 

Besides  EVAL  there  are  f i ve  basic  subroutines  in  our 
system:  NORMALIZE,  REDUCE,  FERTILIZE,  GENERALIZE,  and 
INDUCT. 
routines. 

Below  are  b r i ef  descriptions  of  these 

NORMALIZE  applies  about  ten  rewrite  rules  to  LISP 
expressions. 

For  example: 

(COND  (COND  A  B  C)  D  E)  becomes  (CCND  A  (COND  B  D  E) 
(COND  C  D  E)),  and  (COND  A  A  NIL)  becomes  A. 

APPENDIX  C  l i s ts  the  rewrite  r u l e s. 

REDUCE  attemptsto  propagate  the  results  of  the  tests 
COND  statements  down  the  branches  of  the  COND  t r e e. 
Thus, 

in 

(COND  A  (COND  A  B  C)  (P  A))  becomes 
(COND  A  B  (P  NIL)). 

is  responsible  f or  ' u s i n g' 

FERTILIZE 
an  implication  when  it  is  an  equality. 
the  form: 

the  hypothesis  of 
A  theorem  of 

x  =  y  -  p(y) 

is  rewritten  to 

p(x)  v  x  /  y. 

We  make  f e r t i l i z a t i o ns of  the  form: 

x  =■  y  -  f ( z)  =  g(y)=>  f ( z)  =  g(x)  v  x  /  y 

before  any  other  kind.  We  c a ll  such  substitutions 
' c r o s s - f e r t i l i z a t i o n s ';  we  prefer  c r o s s - f e r t i l i z a t i o ns 
because  they  frequently  allow  the  proofs  we  want. 
A f t er  f e r t i l i z i ng  we  never  again  l o ok at  the  equality 
hypothesis  although  we  retain  it  f or  soundness. 

GENERALIZE  is  responsible  f or  generalizing  the 
to  be  proved. 
subformulas  in  the  theorem  by  new  skolem  constants. 
To  prove  something  of  the  form: 

theorem 
This  is  done  by  replacing  some  common 

p(f(A))  =  q(f(A)) 

we  t ry  proving 

p(B)  =  q(B), 

and  to  prove 

plflA))  -q(f(A)) 

we  t ry 

p(B) 

-  q(B), 

where  B  is  a  new  skolem  constant. 
subformula  f(A) 
instance, 
d i t i on  is  imposed  on  the  new  skolem  constant. 

is  of  a  highly  constrained  type, 

it  is  always  a  number,  an  additional  con­

However, 

if  the 
f or 

If  the  theorem  to  be  generalized  i s: 

(EQUA1  (ADD  (LENGTH  A)  B)  (ADD  B  (LENGTH  A))) , 

488 

GENERALIZE  produces  as  o u t p u t: 

(COHD  (LENGTYPE  C) 

(EQUAL  (ADD  C  B) 

(ADD  B  C))  T) 

is  a  LISP 

where  LENGTYPE 
from  the  LISP  d e f i n i t i on  of  LENGTH. 
c u l ar  case, 
p r e c i s e ly 

In  t h is  p a r t i­
f u n c t i on  w r i t t en  "by  GENERALIZE  has 

the  d e f i n i t i on  of  NUMBERP,  namely: 

f u n c t i on  w r i t t en  by  GENERALIZE 

t he 

(LAMBDA 

(X) 
(COND  X 

(COND  (CAR  X)  NIL  (NUMBERP  (CDR  X ) )) 
T ) ). 

To  p e r f o rm 
s e c t i o n,  GENERALIZE  wrote 
REVERSE: 

the  g e n e r a l i z a t i on  d e s c r i b ed 

in 

the  p r e v i o us 

the 

' t y pe 

f u n c t i o n' 

f or 

(LAMBDA 

(X)  T ), 

t h en  i g n o r e d. 

w h i ch  was  r e c o g n i z ed  as  being  no  r e s t r i c t i on  at  a ll 
and 
The  problem  of  r e c o g n i z i ng  t he 
o u t p ut  of  a  r e c u r s i ve 
and  v e ry  d i f f i c u l t. 
GENERALIZE  uses  some  h e u r i s t i cs  which  arc  o f t en  u s e f u l. 

is  c l e a r ly  undecidable 
these 

f u n c t i on 
To  w r i te 

f u n c t i o n s, 

type 

INDUCT 
is 
h e u r i s t i c. 
p r e s e n ts 
the  new 
r o u t i n es  and  how 
f or  u s e. 

the  program 

t h at  embodies  our 

We  now  d e s c r i be 

the 

i n d u ' t i on 
in  which  it 
t he  o t h er 

form 
to 

i n d u c t i on 
the 

f o r m u la 

i n d u c t i on  h y p o t h e s is 

is  saved 

the 

theorem 

If 
and  EVAL 
the  o u t p ut  of  INDUCT 

i n d i c a t es 

i s: 

to  be  p r o v ed  by 

i n d u c t i on 

is  (F00  A) 

t h at  F00  r e c u r s en  on  the  CDR  of  A, 

(COND  (FOO  NIL) 

(COND  (F00  A) 
N I L ). 

(FOO  (CONS  A1  A))  T) 

which  becomes 
the  LISP  e x p r e s s i on 

the 

f o r: 

theorem  to  be  p r o v e d. 

T h is 

is 

,just 

(FOO  NIL)  &  ( ( F 00  A)  ->  (FOO  (CONS  A1  A ) ) ). 

The  d e f i n i t i o ns  of  AND  and  IMPLIES  are 

in  APPENDIX  A. 

i n d u c t i on 

form  of  t he 

is  d i c t a t ed  by 

The  p r e c i se 
INDUCT 
ered  by  EVAL. 
CDR  of  A  occur  on  the  BOMBLIST, 
f o r m u la 

For  example, 

the 

i s: 

t y p es  of 

f o r m u la  o u t p ut  by 
' e r r o r s'  e n c o u n t(cid:173)
the 

if  both  the  CAR  and 

t h en  the  i n d u c t i on 

(FOO  NIL)  &  (((FOO  A1)  &  (FOO  A))  -  (FOO  (CONS  A1  A ) ) ). 

For  simultaneous  r e c u r s i on  on 
in  APPENDIX  A)  or  CDRing  t w i ce 
ORDERED), 
f o r m u l a s. 
the  BOMBLIST  produced  by  EVAL. 

A ll  of 

t h is 

i n f o r m a t i on 

INDUCT  produces  a p p r o p r i a te 

two  v a r i a b l es  ( e . g.  LTE 

in  a  f u n c t i on  ( e . g ., 

i n d u c t i on 
is  c o l l e c t ed 

from 

CONTROL  STRUCTURE  OF  THE  PROGRAM. 

The  c o n t r ol  s t r u c t u re  of  our  system 
To  prove  t h at  some  LISP  e x p r e s s i o n,  THM,  always 
e v a l u a t es 
l o o p:  s et  OLDTHM  to  THM; 

to  T,  we  execute 

f o l l o w i ng  l o o p: 

the 

is  v e ry  s i m p l e. 

to  R E D U E ( N 0 R M A L I Z E ( E V A L ( T H M ) ) ); 

then  return; 

THM 

s et 
if  THM  =  T, 
if  THM  is  n ot  EQUAL 
if 

f e r t i l i z a t i on  a p p l i e s, 
FERTILIZE(THM) 
if  THM 

is  of 

to  OLDTHM, 

t h en  goto 
to 

then  set  THM 

l o o p; 

o t h e r w i s e, 
then  set  THM  to  (COND  I N D U C T { G E N E R A L I Z E ( P )) 

form  (COND  p  q  NIL) 

the 

o t h e r w i s e,  set  THM  to  I N D U C T ( G E N E R A L I Z E ( T H M ) ); 
g o to 

l o o p; 

q  NIL) 

is  embedded 

the  NIL  case  and 

It  should  be  n o t ed 
s t r u c t u re 
For  example,  when 
of 
done  by  r e p l a c i ng 
s i on  which  has  v a l ue  T 
is 
t r u e. 
r e t u r ns 
to  be  p r o v e d. 

If 

t h at  a ll  of 

the 

i m p o r t a nt  c o n t r ol 

in 

the  LISP  e x p r e s s i on  THM. 

INDUCT  needs 

to  prove 
i n d u c t i on  s t e p, 

the 

is  a c t u a l ly 
the  e x p r e s s i on  THM  by  a  LISF  e x p r e s(cid:173)
t h at  c o n j u n c t i on 

if  and  only 

the  c o n j u n c t i on 
it 

if 
to  T, 

the  NIL  case  e v a l u a t es 

the  second  c o n j u n c t,  which  becomes 

t h en  EVAL 
the 

theorem 

CONCLUSION. 

f i nd 

to  use 

it  n a t u r al 

the  r o u t i n es  EVAL,  NORMALIZE, 

to  r e w r i te  LISP  expresssions;  and  prove 
Our  experience  c o n f i r m s,  and  was  m o t i v a t ed 

We 
and  REDUCE  both 
theorems. 
by,  a  c o n v i c t i on  t h at  p r o o fs  and  computations  are 
e s s e n t i a l ly  s i m i l a r. 
Bob  K o w a l s ki  and  Pat  Hayes,  and 
Cur  program 
the  s t y le  of 
programs  w r i t t en  by  Woody  B l e d s o e. 

T h is  c o n v i c t i on  was 

the  beauty  of  LISP. 

theorem  p r o v i ng 

i n s p i r ed  by 

in 

is 

l i ke 

to  note 

t h at  our  program  uses  no  search 

We  would 
and  a p p l i es  no  lemmas. 
prover 
r . r ~ o c i a t i v i ty  of  APPEND. 
program 
time 
and  to  pursue  one  goal  w i th  power  and  p e r s e v e r a n c e. 

the 
The  p h i l o s o p hy  of  our 

f r e q u e n t ly  r e p r o v es  simple 

Consequently  our  theorem 

the  c o r r e ct  guess 

to  make 

f a c te 

f i r st 

l i ke 

the 

is 

to 

"n 

t he 

i n to 

jumps  or 

theorems 

to  p o i n ts 

to  a r r a y s) 

f or  Compu(cid:173)

to  e s t a b l i sh 

f or  r e c u r s i ve 

t h is  approach, 

languag  s  which 

f or  S c o t t 's  L o g ic 

the  c o r r e c t n e ss  of 

i n d u c t i o n,  which  was 

the  depth  of  f u n c t i on 

(1972)  have 
f or 

i n d u c t i on  on 
(1972) 

in  a  program  and  are  used 

and  M i l n er  and  Weyhrnueh  (1972) 

' v e r i f i c a t i on  c o n d i t i o n s ',  which  are 

i n c l u de  assignments 
l o o p s,  but  w i t h o ut 

The  user  s u p p l i es 
the  systems  generate 

(1967) 
Common  a l t e r n a t i ve 
languages  are  comput(cid:173)

K i ng  ( 1 9 6 9 ),  Good  ( 1 9 7 0 ),  Cooper  (1971) 
implemented  systems  which  use 

i n d u c t i on  ( P a r k,  1969,  and  deBakker  and  S c o t t, 
Both 

i n t r o(cid:173)
l i t e r a t u re  by  B u r s ' a ll  ( 1 9 6 9 ),  a l t h o u gh 
in 

Our  program  uses s t r u c t u r al 
duced 
it  was  used  e a r l i er  by  McCarthy  and  P a i n t er 
a  c o m p i l er  c o r r e c t n e ss  p r o o f. 
i n d u c t i ve  methods 
a t i o n al 
1969)  and  r e c u r s i on  i n d u c t i on  (McCarthy,  1 9 6 3 ). 
are  e s s e n t i a l ly 
c a l l s.  M i l n er 
d e s c r i be  a  p r o of  checker 
t a b le  F u n c t i o ns  ( S c o t t,  1970)  which  uses  c o m p u t a t i o n al 
is 
i n d u c t i o n. 
The  most  commonly  used  method 
f or  f l o w-
diagram  languages  and  was  suggerted  by  Naur 
( l 9 6 6)  and 
F l o yd  ( 1 9 6 7 ). 
i n d u c t i ve  a s s e r t i o ns 
are  attached 
generate 
which  roust  be  proved 
the  program. 
and  Gerhart 
t h is  method 
( p o s s i b ly 
find 
d e f i n ed  procedure  c a l l s. 
i n d u c t i ve  a s s e r t i o ns  and 
v e r i f i c a t i on  c o n d i t i o n s. 
i n c o r p o r a t ed  a u t o m a t ic 
to  prove 
(1973)  use  a  F l o y d - l i ku  method  on  a 
procedure  c a l l s. 
a s s e r t i o ns  but  a  symbolic 
generates 
(1973)  also  uses  symbolic  e v a l u a t i o n. 
and  Katz  and  Manna  (1973)  p r e s e nt  h e u r i s t i cs 
g e n e r a t i ng 
and  F l o yd  (1973)  have 
theorem  prover  very  s i m i l ar 
generates 
i n d u c t i on 
g e n e r a l i z a t i on  h e u r i s t ic  we  use 
f u n c t i o n s ' ). 
i n d u ct  upon 
c o n s t a nt  a p p e a r i ng 
r a t h er  than  u s i ng  EVAL  and  the  BOMBLIST  as  we  d o. 
T h e ir  h e u r i s t ic  w i ll  always  choose  a 
term  r e c u r s ed 
forms  of  r e c u r s i ve 
upon  (due 
e q u a t i o ns  allowed)  but 
the 
one  we  choose. 
d e s c r i be  a  system  which  w i ll 
the  ones 
programs  which  are  more  e f f i c i e n t. 
r e p l a ce 
d a ta  s t r u c t u r es 

it  w i ll  n ot  always  choose 
D a r l i n g t on  and  B u r s t a ll  (1973) 

theorem  p r o v e rs  which  a t t e m pt 
Topor  and  B u r s t a ll 

to  o u r s. 
f o r m u l as  and  uses 
' t y pe 

( w i t h o ut 
the  r i g h t - m o st  skolem 

in  our  LISP  subset  and  w r i te  e q u i v a l e nt 

i n d u c t i ve  a s s e r t i o ns  a u t o m a t i c a l l y. 

( d e s t r u c t i v e l y)  when  p e r m i t t e d. 

T h is  system  w i ll 
l o o p s,  and  use 

r e c u r s i on  by  i t e r a t i o n,  rnerge 

i n t e r p r e t er  ( l i ke  Our  EVAI.) 

They  r e q u i re  user  s u p p l i ed 

implemented  an  a r i t h m e t ic 

t he  theorems  g e n e r a t e d. 

v e r i f i c a t i on  conditions, 

K i ng  and  Cooper  have 

f u n c t i o ns  such  as 

the  statement  of 

r e s t r i c t i o ns  on 

language  w i th 

T h e ir  system 

the 
the 

theorem 

i ts  own 

Deutsch 

B r o tz 

They 

t a ke 

t he 

the 

the 

the 

f or 

to 

in 

Wegbreit  (1973) 

i n d u c t i ve 

The  program  automatically  proves  a ll  of  the 

APPENDIX  A  contains  the  d e f i n i t i o ns  of  the  LISP  f u n c t­
ions  we  use  in  the  proofs  of  the  theorems  in  APPENDIX 
B. 
theorems  in  APPENDIX  B. 
prove  each  theorem  is  8  seconds  on  an  ICL  4130  using 
POP-2. 
The  time  is  almost  completely  spent  in  POP-2 
l i st  processing,  where  the  time  f or  a  CONS  is  400 
microseconds,  and  f or  CAR  and  CDR  it  is  50  microseconds. 

The  average  time  it  takes  to 

Our  work  is  supported  by  a  B r i t i sh  Science  Research 
Council  Grant. 
Meltzer. 

Our  thanks  to  Professor  Bernard 

REFERENCES. 

B u r s t a l l,  R.M., 

( 1 9 6 9 ). 

' P r o v i ng  P r o p e r t i es  of  P r o(cid:173)

grams  by  S t r u c t u r al  I n d u c t i o n '.  Computer  J o u r n a l, 
V o l.  1 2,  p p.  4 1 - 8. 

McCarthy,  J.  and  P a i n t e r,  J . A .,  ( 1 9 6 7 ). 

' C o r r e c t n e ss 

of  a  Compiler  f or  A r i t h m e t ic  E x p r e s s i o n s '. 
P r o c e e d i n gs  of  a  Symposium  in  A p p l i ed  M a t h e m a t i c s. 
V o l.  1 9.  M a t h e m a t i c al  Aspects  of  Computer  S c i e n c e, 
p p.  33-41 • 
( e d.  S c h w a r t z,  J.T.) .  P r o v i d e n c e,  Rhode 
I s l a n d,  American M a t h e m a t i c al  S o c i e t y. 

In 

P a r k,  D .,  ( 1 9 6 9 ). 

' F i x p o i nt  I n d u c t i on  and  P r o o fs  of 
In  Machine  I n t e l l i g e n ce  5 

Program  P r o p e r t i e s '. 
(eds  M e l t z e r,  B.  and  M i c h i e,  D) ,  E d i n b u r gh 
U n i v e r s i ty  P r e s s,  p p.  5 9 - 7 8. 

deBakker,  J.W.  and  S c o t t,  D .,  ( 1 9 6 9 ). 

'A  Theory  of 

P r o g r a m s '.  U n p u b l i s h ed  memo.,  V i e n n a. 

M c C a r t h y,  J .,  ( 1 9 6 3 ). 

'A  B a s is  f or  a  M a t h e m a t i c al 

T h e o ry  of  C o m p u t a t i o n '. 
and  F o r m al  Systems,  p p.  3 3 - 7 0. 
and  H i r s c h b e r g,  D , ). 

In  Computer  Programming 
(eds  B r a f f o r t,  P. 
Amsterdam,  N o r th  H o l l a n d. 

M i l n e r,  R .,  ( 1 9 7 2 ). 

' I m p l e m e n t a t i on  and  A p p l i c a t i on 

of  S c o t t 's  L o g ic  f or  Computable  F u n c t i o n s '. 
Proceedings  of  an  ACM  Conference  on  P r o v i ng  A s s e r t(cid:173)
i o ns  about  P r o g r a m s.  SIGPLAN  N o t i c e s,  V o l.  7,  No,  1 
( J a n u a ry  1 9 7 2 ), 

p p.  1-6. 

In 

Machine  I n t e l l i g e n ce  7.  pp.  51 -70  (eds  Meltzer,  B. 
and  Michie,  D.)  Edinburgh  University  Press. 

S c o t t,  D.,  (1970). 

'Outline  of  a  Mathematical  Theory 

of  Computation1  . 
Laboratory,  Programming  Research  Croup,  Technical 
Monograph  PRG-2. 

Oxford  University  Computing 

November  1970. 

Naur,  P.,  (1966), 

'Proof  of  Algorithms  by  General 

Snapshots'. 

BIT,  V o l.  6,  pp.  310-316. 

Floyd,  R.W.,  {1967). 

'Assigning  Meaning  to  Programs'. 

In  Proceedings  of  a  Symposium  in  Applied  Mathe­
matics.  V o l. 
Computer  Science,  pp.  19-32. 
Providence,  Rhode  I s l a n d,  American  Mathematical 
Society. 

19.  Mathematical  Aspects  of 

(ed.  Schwartz,  J.T.)  . 

King,  J .,  (1969). 

'A  Program  V e r i f i e r '. 

Ph.D. 

Thesis,  Carnegie-Mellon  University,  U.S.A. 

Good,  D.,  (1970). 

'Toward  a  Man-Machine  System  f or 

Proving  Program  Correctness'. 
University  of  Wisconsin,  U.S.A. 

Ph.D.  Thesis, 

Cooper,  D.  (1971). 

V e r i f i c a t i o n '. 
59,  (eds  Meltzer,  B.  and  Michie,  D). 
University  Press. 
Gerhart,  S .,  (1972). 

'Programs  f or  Mechanical  Program 
In  Machine  I n t e l l i g e n ce  6.  pp.  43-
Edinburgh 

' V e r i f i c a t i on  of  APL  Programs'. 

Ph.D.  Thesis,  Carnegie-Mellon  University,  U.S.A. 

Topor,  R.,  and  B u r s t a l l,  R.M.  (1973)  -  Private 

Communication. 

Deutsch,  P.,  (1973) 
Brotz,  D.  and  Floyd,  R.W. 

by  Mathematical  I n d u c t i o n '. 
Science  Department  Report. 

Forthcoming  Ph.D.  Thesis. 

(1973). 

'Proving  Theorems 

Stanford  Computer 

Wegbreit,  B., 

(1973)- 

' H e u r i s t ic  Methods  f or  Mechani­

c a l ly  Deriving  Inductive  A s s e r t i o n s '. 
eedings  of  IJCAI,  1973  ( to  appear). 

In  Proc-

Katz,  S.M.,  and  Manna,  Z .,  (1973). 

'A  Heuristic 

Approach  to  Program  V e r i f i c a t i o n '. 
of  IJCAI  1973  (to  appear). 

Darlington,  J.  and  B u r s t a l l,  R.M.,  (1973}- 
which  automatically  improves  Programs'. 
eedings  of  IJCAI  1973  { to  appear). 

In  Proceedings 

'A  System 
In  Proc-

APPENDIX  &. 

FUNCTION  DEFINITIONS. 

DEFINE((ADD  (LAMBDA  {X  Y) 

(COND  X  (CONS  N IL  (ADD  (CDR  X)  Y))  (LENGTH  Y ) ) ) )) 

[NOTE:  CONSING  N IL  ONTO  A  NUMBER  IS  JUST 
ADDING  1  TO  I T. 
THAT  THE  OUTPUT  IS  ALWAYS  A  NUMBER.] 
DEFINE((ADDTOLIS  (LAMBDA  (X  Y) 

'LENGTH'  IS  USED  TO  INSURE 

(COND Y 

(COND  (LTE  X  (CAR  Y)) 

(CONS  X  Y) 
(CONS  (CAR  Y)  (ADDTOLIS  X  (CDR  Y ) ) )) 

(CONS  X  N I L ) ) ) )) 

DEFINE((AND  (LAMBDA  (X  Y) 

(COND  X  (COND  Y  T  NIL)  N I L ) ) )) 
[NOTEt 
BOOLEAN,  EVEN  IF  X  AND  Y  ARE  NOT. 
HOLDS  FOR  ' O R ',  ' N O T ',  AND  ' I M P L I E S ' .] 
DEFINE((APPEND  (LAMBDA  (X  Y) 

'AND'  IS  DEFINED  SO  THAT  IT  IS  ALWAYS 
THE  SAME 

(COND  X  (CONS  (CAR  X)  (APPEND  (CDR  X)  Y))  Y ) ) )) 

DEFINE((ASSOC  (LAMBDA  (X  Y) 

(COND Y 

(COND  (CAR  Y) 

(COND  (EQUAL  X  (CAR  (CAR  Y ) )) 

(CAR  Y) 
(ASSOC  X  (CDR  Y ) )) 

(ASSOC  X  (CDR  Y ) )) 

N I L ) ) )) 

DEFINE((BOOLEAN  (LAMBDA  ( x) 

(COND  X  (EQUAL  X T)  T ) ) )) 
DEFINE((CDRN  (LAMBDA  (X  Y) 

(COND  Y  (  COND  X  (CDRN  (CDR  X)  (CDR  T ))  Y)  N I L ) ) )) 
[NOTE: 
DEFINE((CONSNODE  (LAMBDA  (X  Y) 

'CDRN'  RETURNS  THE  XTH  CDR  OF  Y .] 

M i l n e r,  R .,  and  Weyhrauch,  R .,  ( 1 9 7 2 ). 

' P r o v i ng 
C o m p i l er  C o r r e c t n e ss  in  a  Mechanized  L o g i c '. 

In 

(CONS  NIL  (CONS  X  Y ) ) ) )) 
DEFINE((COPY  (LAMBDA  ( x) 

490 

(COND  X 

(CONS  (COPY  (CAR  X)) 
N I L ) ) )) 

DEFINE((COUNT  (LAMBDA 

(x  Y) 

(COPY  (CDR  X ) )) 

(COND  (EQUAL  X  (CAR  Y))  T  (MEMBER  X  (CDR  Y ) )) 
N I L ) ) )) 
DEFIRE((MONOT1 

(LAMBDA  (X) 

(COND  X 

(CONE  Y 

(COND  (EQUAL  X  (CAR  Y)) 

(CONS  NIL  (COUNT  X  (CDR  Y ) )) 
(COUNT  X  (CDR  Y ) )) 

N I L ) ) )) 
'COUNT'  RETURNS  THE  NUMBER  OF  TIMES 

[NOTE: 
X  OCCURS  AS  AN  ELEMENT  OF  Y .] 
DEFINE((DOUBLE 

(LAMBDA  (x) 

(CONS  N IL  (CONS  NIL  (DOUBLE  (CDR  X ) ) )) 
N I L ) ) )) 

DEFINE((ELEMENT 

(LAMBDA 

(X  Y) 

(COND  X 

(COND  Y 

(COND  X  (ELEMENT  (CDR  X) 
N I L ) ) )) 

DEFINE(EQUALP  (LAMBDA  (X  Y) 

(COND  X 

(COND  Y 

(COND  (EQUALP  (CAR  X) 
(EQUALP  (CDR  X) 
NIL) 

(CAR  Y)) 
(CDR  Y)) 

(CDR  Y)) 

(CAR  Y)) 

(EVEN2  (CDR  (CDR  X ) ))  NIL) 

NIL) 

DEFINE((EVEN1 

(COND  Y  NIL  T ) ) ) )) 
(LAMBDA  (X) 

(COND  X  (NOT  (EVEN1 

(CDR  X ) ))  T ) ) )) 

DEFINE((EVEN2  (LAMBDA  (x) 

(COND  X 

(COND  (CDR  X) 
T ) ) )> 

DEFINE  (FLATTEN  (LAMBDA  (X) 

(COND  (NODE  X) 
(APPEND 

(FLATTEN 
(CDR  x))) 
(FLATTEN  (CDR  (CDR  X ) ) )) 

(CAR 

(CONS  X  N I L ) ) ) )) 
'FLATTEN'  RETURNS  A  LIST  OF  TIPS  IN 
'CONSNODE' 

[NOTE: 
A  BINARY  TREE  OF 
FOR  THE  DEFINITION  OF  HOW  TO  BUILD  A  NODE.] 
DEFINE((GT  (LAMBDA  (X  Y) 

'NODES'. 

SEE 

(COND  X  (COND  Y  (GT  (CDR  X) 

(CDR  Y))  T)  N I L ) ) )) 

DEFINE((HALF  (LAMBDA  (X) 

(CONS  NIL  (HALF  (CDR  (CDR  X ) ) ))  NIL) 

(COND 
X 
(COND  (CDR  X) 
N I L ) ) )) 

DEFINE((IMPLIES 

(LAMBDA  (X  Y) 
(COND  X  (COND  Y  T  NIL)  T ) ) )) 

DEFINE((INTERSEC 

(LAMBDA  (X  Y) 

(COND  X 

(COND  (MEMBER  (CAR  X)  Y) 

(CONS  (CAR  X) 
(INTERSEC  (CDR  X)  Y)) 

(INTERSEC  (CDR  X)  Y)) 

N I L ) ) )) 

DEFINE((LAST 
(COND  X 

(LAMBDA 

(COND  (CDR  X) 
N I L ) ) )) 
DEFINE((LENGTH 

(LAMBDA 

(X) 

(X) 

(LAST  (CDR  X)) 

(CAR  X)) 

(COND  X  (CONS  NIL  (LENGTH  (CDR  X ) ))  N I L ) ) )) 

DEFIHE((LIT 

(LAMBDA 

(X  Y  Z) 

( L IT  (CDR  X)  Y  Z))  Y ) ) )) 

'LIT'' 

(COND  X  (APPLY  Z  (CAR  X) 
[NOTE: 
IS  A  GENERAL  PURPOSE  FUNCTION, 
FOR  EXAMPLE,  (APPEND  X  T)  =  ( L IT  X  Y  CONS). 
OUR  PROGRAM  CANNOT  HANDLE  FUNCTIONS  AS  ARGS, 
BUT  SOME  FACTS  ABOUT 
WITHOUT  KNOWING  WHAT 
DEFINE((LTE 

' L I T'  CAN  BE  VERIFIED 
'APPLY'  DOES.] 

(LAMBDA 

(X 

I) 

(COND  X  (COND  Y  (LTE  (CDR  X) 
(X  Y) 

DEFINE((MAPLIST 

(LAMBDA 

(CDR  Y))  NIL)  T ) ) )) 

(COND  X 

(CONS  (APPLY  Y  (CAR  X)) 
N I L ) ) )) 
DEFIHE((MEKBER 

(LAMBDA 

(x  Y) 

(COND  Y 

(MAPLIST  (CDR  X)  Y)) 

(COND  (CDR  X) 

T) 

T ) ) )) 

(COND  (EQUAL  (CAR  X) 

(CAR  (CDR  X ) )) 

(MONOT1 

(CDR  X))  NIL) 

DEFINE((MONOT2 

(LAMBDA 

(X  Y) 

(COND 
Y 
(COND  (EQUAL  X  (CAR  Y)) 
T ) ) )) 

DEFINE((MONOT2P  (LAMBDA  (X) 

(M0N0T2  X  (CDR  Y))  NIL) 

(COND  X  (MONOT2  (CAR  X) 
[NOTE:  A  LIST  IS 
ELEMENTS  ARE  THE  SAME. 
ARE  TWO  DIFFERENT  WAYS  TO  DETECT  THIS.] 
DEFINE((MULT  (LAMBDA 

(CDR  X))  T ) ) )) 

'MONOTONOUS' 

IF  ALL  THE 

(X  Y) 

(COND  X  (ADD  Y  (MULT  (CDR  X)  Y))  N I L ) ) )) 

DEFINE((NODE  (LAMBDA  (X) 

'MONOTl'  AND  'MONOT2P' 

(COND  X 

(COND  (CAR  X)  NIL  (COND  (CDR  X)  T  N I L )) 
N I L ) ) )) 

DEFINE((NOT 

(LAMBDA 

(COND  X  NIL  T ) ) )) 

(X) 

DEFINE((NUMBERP 
(COND 

(COND  X 

(LAMBDA 
(CAR  X)  NIL  (NUMBERP  (CDR  X ) ))  T ) ) )) 

(X) 

DEFINE((OCCUR 

(LAMBDA 

(X  Y) 

(COND 
(EQUAL  X  Y) 
T 
(COND  Y 

(COND  (OCCUR  X  (CAR  Y))  T  (OCCUR  X  (CDR  Y ) )) 
N I L ) ) ) )) 

DEFINE((OR  (LAMBDA  (X  Y) 

(COND  X  T  (COND  Y  T  N I L ) ) ) )) 

DEFINE((ORDERED  (LAMBDA 

(x) 

(COND  X 

(COND  (CDR  X) 

(COND  (LTE  (CAR  X)  (CAR  (CDR  X ) )) 

(ORDERED 
NIL) 

(CDR  x)) 

T) 

T ) ) )) 

DEFINE((PAIRLIST  (LAMBDA 

(X  Y) 

(COND 
X 
(COND 
Y 
(CONS  (CONS  (CAR  X)  (CAR  Y)) 

N I L ) ) )) 

DEFINE((REVERSE 
(COND  X 

(LAMBDA 

(x) 

(PAIRLIST  (CDR  X) 

(CDR  Y ) )) 

(CONS  (CONS  (CAR  X)  NIL) 

(PAIRLIST  (CDR  X)  N I L ) )) 

(APPEND  (REVERSE  (CDR  X)) 
N I L ) ) )) 

DEFINE((SORT  (LAMBDA 

(x) 

(CONS  (CAR  X)  NIL)) 

(COND  X  (ADDTOLIS  (CAR  X) 

DEFINE((SUBSET  (LAMBDA 

(X  Y) 

(SORT  (CDR  X ) ))  N I L ) ) )) 

(COND 

X 
(COND  (MEMBER  (CAR  X)  Y) 
T ) ) )) 

DEFINE((SUBST  (LAMBDA  (X  Y  Z) 

(SUBSET  (CDR  X)  Y)  NIL) 

(COND 
(EQUAL  Y  Z) 
X 
(COND 
Z 
(CONS  (SUBST  X  Y  (CAR  Z ))  (SUBST  X  Y  (CDR  2 ) )) 
N I L ) ) ) )) 

DEFINE(SWAPTREE 
(COND  (NODE  X) 

(LAMBDA 

(X) 

(CONSNODE  (SWAPTREE  (CDR  (CDR  X ) )) 

(SWAPTREE 

(CAR  (CDR  X ) ) )) 

MISCELLANEOUS  THEOREMS 

DEFINE((TIPCOUNT  (LAMBDA 

(X) 

(EQUAL  ( L IT  (APPEND  A  B)  C D) 

( L IT  A  ( L IT  B  C  D)  D)) 

x)))) 

1)))) 

(COND  (NODE  X) 

(ADD  (TIPCOUNT  (CAR  (CDR  X ) )) 

(TIPCOUNT 

(CDR 

{CDR  x)))) 

DEFINE((UNION 

(LAMBDA 

(X  T) 

(COND  x 

(COND  (MEMBER  (CAM  X)  Y) 

UNION  (CDR  X)  Y) 
(CONS  (CAR  X) 

(UNION  (CDR  X)  Y ) )) 

APPENDIX  B. 

THEOREMS  PROVED  AUTOMATICALLY. 

APPEND,  LENGTH  AND  REVERSE  THEOREMS 

(EQUAL  (APPEND  A  (APPEND  B  C)) 
(APPEND  (APPEND  A  B)  C)) 

(IMPLIES  (EQUAL  (APPEND  A  B) 

(EQUAL  E C )) 

(APPEND  A  C)) 

(EQUAL  (LENGTH  (APPEND  A  B)) 

(LENGTH  (APPEND  B  A ) )) 

(EQUAL  (REVERSE  (APPEND  A  B)) 

(APPEND  (REVERSE  B) 

(REVERSE  A ) )) 

(EQUAL  (LENGTH  (REVERSE  D)) 

(LENGTH  D)) 

(EQUAL  (REVERSE  (REVERSE  A ))  A) 

(IMPLIES  A  (EQUAL  (LAST  (REVERSE  A)) 

(CAR  A ) )) 

MEMBER,  UNION,  ETC  THEOREMS 

(IMPLIES  (MEMBER  A  B) 

(MEMBER  A  (APPEND  B  C ) )) 

(IMPLIES  (MEMBER  A  B) 

(MEMBER  A  (APPEND  C  B ) )) 

(IMPLIES  (AND 

(NOT  (EQUAL  A  (CAR  B ) )) 

(MEMBER  A  B)) 

(MEMBER  A  (CDR  B ) )) 

(IMPLIES  (OR  (MEMBER  A  B) 

(MEMBER  A  C)) 

(MEMBER  A  (APPEND  B  C))) 

(IMPLIES  (AND  (MEMBER  A  B) 

(MEMBER  A C )) 

(MEMBER  A  (INTERSEC  B  C ) )) 

(IMPLIES  (OR (MEMBER  A  B) 

(MEMBER  A  C)) 

(MEMBER  A  (UNION  B  c))) 

(IMPLIES  (SUBSET  A  B) 

(EQUAL  (UNION  A  B)  B)) 

(IMPLIES  (SUBSET  A  B) 

(EQUAL  (INTERSEC  A  B)  A)) 

(EQUAL  (MEMBER  A  B) 

(NOT  (EQUAL  {ASSOC  A  (PAIRLIST  B  C))  N I L ) )) 

HAPLIST  THEOREMS 

(EQUAL  (MAPLIST  (APPEND  A  B)  C) 

(APPEND  (MAPLIST  A  C) 

(MAPLIST  B  C ) )) 

(EQUAL  (LENGTH  (MAPLIST  A  B)) 

(LENGTH  A)) 

(EQUAL  (REVERSE  (MAPLIST  A  B)) 
(MAPLIST  (REVERSE  A)  B)) 

(IMPLIES  (AND  (BOOLEAN  A) 

(BOOLEAN  B)) 

(EQUAL  (AND  (IMPLIES  A  E) 

(IMPLIES  B  A)) 

(EQUAL  A  B ) )) 

(EQUAL  (ELEMENT  B  A) 

(ELEMENT  (APPEND  C  B) 

(APPEND  C  A ) )) 

(IMPLIES  (ELEMENT  B  A) 

(MEMBER  (ELEMENT  B  A)  A)) 

(EQUAL  (CDRN  C  (APPEND  A  B)) 

(APPEND  (CDRN  C  A) 

(CDRN  (CDRN  A  C)  B ) )) 

(EQUAL  (CDRN  (APPEND  B  C)  A)  (CDRN  C  (CDRN  B  A ) )) 

(EQUAL  (EQUAL  A  B) 

(EQUAL  B  A)) 

(IMPLIES  (AND  (EQUAL  A  B) 
(IMPLIES 

(EQUAL  B  c )) 

(EQUAL  A  C)) 

(AND  (BOOLEAN  A) 
{EQUAL  (EQUAL  (EQUAL  A  B)  C) 

(AND(BOOLEAN  B) 

(EQUAL  A  (EQUAL  B  C ) ) )) 

(BOOLEAN  C ) )) 

ARITHMETIC  THEOREMS 

(EQUAL  (ADD  A  B)  (ADD  B  A)) 

(EQUAL  (ADD  A  (ABD  B  C)) 

(ADD  (ADD  A  B)  C)) 

(EQUAL  (MULT  A  B) 

(MULT  B  A)) 

(EQUAL  (MULT  A  (ADD  B  C)) 

(ADD  (MULT  A  B) 

(MULT  A  C ) )) 

(EQUAL  (MULT  A  (MULT  B  C)) 

(MULT  (MULT  A  B)  C)) 

(EVENt 

(DOUBLE  A)) 

(IMPLIES  (NUMBER?  A) 
(IMPLIES  (AND  (NUMBERP  A) 

(EVENl  A )) 
(EQUAL  (DOUBLE  (HALF  A))  A)) 

(EQUAL  (HALF  (DOUBLE  A))  A)) 

(EQUAL  (DOUBLE  A) 

(MULT  2  A)) 

(EQUAL  (DOUBLE  A) 

(MULT  A  2)) 

(EQUAL  (EVEK1  A) 

(EVEN2  A)) 

GT,  LTE,  ORDERED  AND  SORT  THEOREMS 

(QT  (LENGTH  (CONS  A  B)) 

(LENGTH  B)) 

(IMPLIES  (AND  (GT  A  B) 

(GT  B  C))  (GT  A  C)) 

(IMPLIES  (GT  A  B) 

(  NOT  (GT  B  A ) )) 

(LTE  A  (APPEND  B  A )) 

(OR  (LTE  A  B) 

(LTE  B  A)) 

(OR  (GT  A  B) 

(OR  (GT  B  A) 

(EQUAL  (LENGTH  A) 

(LENGTH  B j ) )) 

(EQUAL  (M0N0T2P  A) 

(MONOT1  A )) 

(ORDERED  (SORT  A)) 

(IMPLIES  (AND  (MONOT1  A) 

(MEMBER  B  A)) 

(EQUAL  (CAR  A)  B)) 

(LTE  (CDRN  A  B)  B) 

492 

(EQUAL  (MEMBER  A  (SORT  B))  (MEMBER  A  B)) 

(EQUAL  (LENGTH  A) 

(LENGTH  (SORT  A ) )) 

(EQUAL  (COUNT  A  B)  (COUHT  A  (SORT  B ) )) 

(IMPLIES  (ORDERED  A) 

(EQUAL  A  (SORT  A ) )) 

(IMPLIES  (ORDERED  (APPEND  A  B)) 

(ORDERED  A)) 

(IMPLIES  (ORDERED  (APPEND  A  B)) 

(ORDERED  B)) 

(EQUAL  (EQUAL  (SORT  A)  A) 

(ORDERED  A)) 

(LTE  (HALF  A)  A) 

THEOREMS  ABOUT  TREES 

(EQUAL  (COPY  A)  A) 

(EQUAL  (EQUAL  P  A  B) 

(EQUAL  A  B)) 

(EQUAL  (SUBST  A  A  B)  B) 

(IMPLIES  (MEMBER  A  B)  (OCCUR  A  B)) 

(IMPLIES  (NOT  (OCCUR  A  B)) 

(EQUAL  (SUBST  C  A  B)  B)) 

(EQUAL  (EQUALP  A  B) 

(EQUALP  B  A)) 

(IMTLIES  (AND  (EQUALP  A  B)  (EQUALP  B  C)) 

(EQUALP  A  C)) 

(EQUAL  (SWAPTREE  (SWAPTREE  A))  A) 

(EQUAL  (FLATTEN  (SWAPTREE  A)) 

(REVERSE  (FLATTEN  A ) )) 

(EQUAL  (LENGTH  (FLATTEN  A)) 

(TIPCOUKT  A)) 

APPENDIX  C. 

REWRITE  RULES  APPLIED  BY  NORMALIZE. 

'equal' 

if 

IDENT  is 

'unequal' 

lower  oase  l e t t e rs  represent 

they  are  s y n t a c t i c a l ly  i d e n t i c al 

Forms  matching  those  on  the  l o f t-

In  the  rules  below, 
a r b i t r a ry  forms. 
hand  side  of  the  arrows  are  replaced  by  the  appro­
priate  instances  of  the  forms  on  the  r i g h t. 
a  routine  which  takes  two  terms  as  arguments  and 
returns 
(such  as  (CONS  A  B)  and  (CONS  A  B),  or  (CONS  NIL  NIL) 
and  1 ), 
as  (CONS  A  B)  and  NIL,  or  (CONS  A  B)  and  A ),  or 
'unknown'. 
or  false  depending  upon  whether  i ts  argument  is 
boolean  by  inspecting  i ts  d e f i n i t i on  with  an  inductive 
assumption  that  any  recursive  c a l ls  are  to  be 
considered  boolean. 
top-level 
is  given  before  r e w r i t i ng  the 
to  the  term  it 
expression. 
F i n a l l y,  any  rule  i n v o l v i ng  EQUAL  has  a 
symmetric  version  not  presented  in  which  the  arguments 
to  the  EQUAL  have  been  interchanged. 

BOOLEAN  is  a  routine  which  returns  true 

if  they  are  obviously  unequal  (such 

NORMALIZE  rewrites  the  arguments 

if  IDENT(x,y)  = 

(EQUAL  x  y)  = > T, 
(EQUAL  x  y)  =>  N I L, 
(EQUAL  x  T)  =>  x, 
(EQUAL  (EQUAL  x  y)  z)  =>  (COND  (EQUAL  x  y) 
(EQUAL  z  T) 
(COND  2  NIL  T)) 

IDENT(x.y)  = 

if  BOOLEAN(x) 

' u n e q u a l' 

' e q u a l' 

if 

(COND  (CONS  U  V)  x  y)  =>  x 
(COND  NIL  x  y)  =c  y 
(COND  x  T  NIL)  ^>  x, 
COND  x  y  y)  =>  y 
(COND  x  x  NIL)  =>  x 
(f  X1...(COHD  y  u  v)  . . .x  )  =>  (COND  y 

if  BOOLEAN(x) 

(f  x 

. . . u . . .x  ) 

493 

