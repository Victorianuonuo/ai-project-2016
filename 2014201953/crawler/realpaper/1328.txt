Session  18  Automatic  Programming 

A  HEURISTIC  APPROACH  TO  PROGRAM  VERIFICATION 

Shmuel  M.  Katz  and  Zohar  Manna 

Department  of  Applied  Mathematics 
The  Weizmann  I n s t i t u te  of  Science 

Rehovot, 

I s r a el 

Abstract 

We  present  various  h e u r i s t ic  techniques  for  use  in 

proving  the  correctness  of  computer  programs.  The 
techniques  are  designed  to  obtain  automatically  the 
"inductive  assertions"  attached  to  the  loops  of  the 
program  which  previously  required  human  "understanding" 
of  the  program's  performance.  We  distinguish  between 
two  general  approaches:  one  in  which  we  obtain  the 
inductive  assertion  by  analyzing  predicates  which  are 
known  to  be  true  at  the  entrances  and  e x i ts  of  the  loop 
(top-down  approach),  and  another  in  which  we  generate 
the  inductive  assertion  d i r e c t ly  from  the  statements 
of 

the  loop  (bottom-up  approach). 

I. 

Introduction 

if 

if  a ll 

that 

i s, 

i t e r a t i ve  (flow­
that 

[1967]  has  provided  a  proof  method 

The  d e s i r a b i l i ty  of  proving  that  a  given  program 
is  correct  has  been  noted  repeatedly  in  the  computer 
l i t e r a t u r e,  Floyd 
for  showing  p a r t i al  correctness  of 
chart)  programs, 
the  program 
it  shows 
terminates,  a  given  input-output  r e l a t i on  is  s a t i s f i e d. 
The  method  involves  c u t t i ng  each  loop  of  the  program, 
attaching  to  each  cutpoint  an  "inductive  assertion" 
(which 
Is  a  predicate  in  f i r s t - o r d er  predicate  c a l c u l­
us),  and  constructing  v e r i f i c a t i on  conditions  for  each 
path  from  one  assertion 
to  another  (or  back  to  i t s e l f ). 
The  program  is  p a r t i a l ly  correct 
t i on  conditions  are  v a l i d.  Elements  of  these  tech­
niques  have  been  shown  amenable  to  mechanization. 
King 
for  example,  has  actually  w r i t t en  a  ' v e r i­
f i e r'  program  which,  given  the  proper  inductive  asser­
tions 
for  programs  w r i t t en  in  a  s i m p l i f i ed  A l g o l - l i ke 
language,  can  prove  p a r t i al  correctness. 
it  is 
f a i r ly  clear  that 
volve  generating  v e r i f i c a t i on  conditions 
assertions  and  then  proving  or  disproving  t h e ir  v a l i­
d i ty  is  a  d i f f i c u lt  but  programmable  problem.  However, 
as  King  puts  i t, 
' c u t' 
each  loop  of  the  program  "depends  on  our  deep  under­
standing  of  the  program's  performance  and  requires  some 
sophisticated 

finding  a  set  of  assertions  to 

i n t e l l e c t u al  endeavor". 

t h is  method  which  in-

from  inductive 

the  v e r i f i c a­

the  parts  of 

[1969], 

Thus, 

In  this  paper  we  show  some  general  h e u r i s t ic  tech­

for  automatically  f i n d i ng  a  set  of 

niques 
inductive 
assertions  which  w i ll  allow  proving  p a r t i al  correct­
ness  of  a  given  program.  More  precisely,  we  are  given 
a  flowchart  program  with  input  variables  x  (which  are 
not  changed  during  execution),  program  variables  y 
(used  as  temporary  storage  during  the  execution  of  the 

500 

In  a d d i t i o n, 

program),  and  output  variables  z  (which  are  assigned 
values  only  at  the  end  of  the  execution). 
we  are  given  "input  predicate"  $ ( x ),  which  puts  r e­
s t r i c t i o ns  on  the  input  variables,  and  "output  p r e d i­
cate"  <Kx,z),  which  indicates  the  desired  r e l a t i on  be­
tween  the  input  and  output  variables.  Given  a  set  of 
cutpoints  which  cut  a ll  the  loops,  our  task  is  to  a t­
tach  an  appropriate  inductive  assertion  Qi  to  each 
cutpoint 

i. 

We  distinguish  between  two  general  approaches: 
top-down  approach  in  which  we  obtain  the  Induct­

(a) 
ive  assertion  inside  a  loop  by  analyzing  the  predicates 
which  are  known  to  be  true  at  the  entrances  and  exits 
of  the  loop,  and 
(b)  bottom-up  approach  in  which  we  generate  the  i n­
ductive  assertion  of  a  loop  d i r e c t ly  from  the  s t a t e­
ments  of  the  loop. 

it 
the 

For  "toy"  examples,  having  only  a  single  loop, 

is 

that  the 

top-down  approach 

is  generally  clear 
natural  method  to  use.  However, 
t h is  is  d e f i n i t e ly  not 
the  case  for  real  ( n o n - t r i v i a l)  programs  with  more  com­
plex  loop  structure. 
In  t h is  case  some  bottom-up  tech­
niques  were  found  indispensible.  Most  commonly  we  have 
found  it  necessary  to  combine  the  two  techniques,  w i th 
the  bottom-up  methods  dominant. 

Preliminary  attempts 

to  attack  the  problem  of  f i n d­
[private  commun­
ing  assertions  have  been  made  by  Floyd 
i c a t i o n ],  and  Cooper 
[1971].  Heuristic  rules  basically 
similar  to  some  of  our  top-down  rules  have  been  discov­
ered  Independently  by  Wegbreit 
[1973].  Elspas,  et  a l. 
[1972],  used  "difference  equations"  derived  from  the 
program's  statements  which  i s, 
approach. 

in  essence,  a  bottom-up 

We  handle  programs  with  arrays  separately,  since 
involving  q u a n t i f i c a t i on  over 

generating  assertions 
the  indices  of  arrays  requires  special  treatment. 
Thus 
in  Section  II  we  discuss  h e u r i s t ic  techniques  for  flow­
chart  programs  without  arrays,  while  in  Section  I II  we 
extend  the  treatment 
In  Sec­
t i on  IV  (conclusion)  we  discuss  open  problems  and  pos­
s i b le  implications  of  our  techniques.  Related  problems 
where  these  approaches  seem  applicable  include  proving 
termination  of  programs,  and  discovering  the  input  and 

to  programs  w i th  arrays. 

output  assertions  of  a  program. 

Our  emphasis  in  t h is  paper  is  on  the  exposition  of 

the  rules  themselves  and  we  are  purposely  somewhat 
vague  on  other  problems,  such  as  correctly  locating 
the  cutpoints  or  ordering  the  application 
of  the  rules.  Though  we  do  not  enter  into  d e t a i l s,  we 
assume  that  whenever  possible  we  conduct  immediate 
tests  on  the  consistency  (with  known  information)  of  a 
new  component  for  an  assertion  as  soon  as  it  is  gene­
rated,  and  that  algebraic  simplifications  and  manipu­
lations  are  done  whenever  necessary. 

II  Heuristics 

for  Programs  without  Arrays 

A.  Top-down  approach. 

We  begin  by  l i s t i ng  the  top-down  rules,  which  may 

be  divided  into  two  classes: 
rules. 

entry  rules  and  exit 

1.  Entry  rules.  These  rules  are  i n t u i t i v e ly  ob­
vious,  but  provide  valuable  information  in  a  surpris­
ing  number  of  cases. 
rule  En`1.  Any  conjunct*  in  the  input  predicate  $(x) 
may  be  added  to  any  Q, 
It  need  not  be  proven  since 
the  input  variables  are  not  changed  inside  the  program, 

rule  En2.  Any  predicate  known  to  be  true  upon  f i r st 
reaching  a  cutpoint 
2.  Exit  rules. 

i  should  be  t r i ed  in  Qi. 
For  s i m p l i c i ty  in  the  statement 

of  these  rules,  we  assume  that  a  cutpoint  is  attached 
to  the  arc  immediately  before  an  e x it  test  of  the  loop. 
Thus  we  may  consider  an  e x it  from  a  loop  to  be  of  the 
form 

is  the  e x it  t e s t,  p, 

is  some  conjunct  of  a 
where  t. 
predicate  known  to  be  true  when  the  exit  test  f i r st 
holds,  1  is  the  cutpoint  on  the  arc  leading  into  the 
e x it  t e s t,  and  Q1  is  the  assertion  which  we  wish  to 
discover.  We  attempt  to  extract  information  from  p. 

If  a  predicate  is  expressed  as  a  conjunction 
A1AA2^........AN  ,  then  each  A  is  a  conjunct,  of  the 
predicate. 

501 

It  Is  possible  to  continue  to  design  rules  for 
,  but  since  our 

to  explain  the  general  tone  of  these  techniques, 

obtaining  R  for  specific  forms  of  p. 
aim 
we  w i ll  not  go  i n to  further  details  in  t h is  d i r e c t i o n. 
B.  Bottom-up  Approach. 

is 

A ll  of 

the  rules  given  above  have  in  common  that 

they  expect  to  be  provided  with  some  information  on 
either  what  conditions  were  true  upon  entering  the 
loop  or  what  conditions  were  expected  to  hold  upon 
completing  the  loop  (or  both).  However., 
to  produce  conjuncts  of  the  assertion  Q  without  con­
sidering  predicates  already  established  elsewhere  in 
the  program. 
shall  look  for  a  predicate  which  is  an  invariant  of 
the  loop  L  , 
cutions  of 

In  order  to  accomplish  t h is  goal  we 

it  remains  true  upon  repeated  exe­

the  loop. 

i . e ., 

it  is  possible 

this 

the  top-down  rules 

is  usually  the  last 

Clearly,  any  conjunct 

in  the  inductive  assertion 
of  a  loop  must  be  an  invariant  of  the  loop.  However, 
in 
fact 
which  is  established  about  a  prospective  assertion. 
In  the  pure  bottom-up  approach,  assertions  which  arise 
" n a t u r a l l y" 
r e c t ly  generated  —  and  only  afterward  checked  for 
relevance  to 

from  the  computations 

in  the  loop  are  d i­

the  o v e r a ll  proof. 

Most 

invariants  may  be  traced  back  to  the  fact 

that  at  any  stage  of  the  computation, 
statements  which  are  on  the  same  paths  through  the 
loop  have  been  executed  an  i d e n t i c al  number  of  times, 
and  t h is  is  a  'constant'  which  may  be  used  to  relate 
the  variables 

those  assignment 

i t e r a t e d. 

Our 

(01 
' 

technique  for  f i n d i ng  invariants 

the  value  of  y.  a f t er  n  executions  of 

For  an  assignment  statement  y.  ■*■  f ( x , y)  we  l et 
the 
indicates  the  " i n i t i a l"  value  of 

y1  denote 
statement,  while  y; 
y1  upon  f i r st  reaching  a  given  cutpolnt  of  the  loop. 
involves 
constructing  an  "operator  table"  in  which  we  record 
useful  information  for  each  operator.  Among  the  eitries 
for  an  operator  are  i ts  d e f i n i t i on  (using  "weaker"  ope­
rators) ,  a  description  of  a  general  computation  after 
n  i t e r a t i o n s,  and  other  common  i d e n t i t i es  which  f a c i­
l i t a te  s i m p l i f i c a t i o n s.  For  example, 
for  +  our  table 
w i ll  include  the  fact  that  for  an  assignment  statement 
of  the  form  y1  +  y1+k,  in  general  y1
where  kVJ 

(n)=y(0)+  T  k ^ "15 
is  the  value  of  k  before  the  j - th  i t e r a­

n 

t i on  of  the  assignment  statement. 
Important  i d e n t i­
t i es  are  also  noted  including  that  for  a  constant  c 
n 
I  c » c n,  and  that  £  i» 
i -1 
invariants  l i n k i ng  variables  which  receive  assignments 
on  d i f f e r e nt  paths  through  the  loop  are  presently 
being  developed.  Here  we  present  rules  only  for  the 

, 
'  -i—*-  .  Rules  for  producing 

i -1 

, 

.. 

2 

502 

Our  h e u r i s t ic  rules  are  a ll  relevant  to  programs 

'topology',  although,  of  course, 

having  an  a r b i t r a ry  number  of  loops,  and  an  arbitrary 
complex 
yield  v a l id  inductive  assertions  more  often  and  more 
immediately  in  a  simple  program. 

they  w i ll 

One  of  the  problems  in  applying  the  rules  is  deci­

In  p a r t i c u l a r, 

it  has 

. 

is  expended 

the  result 
if 

immediately,  while  considerable 
the  other  method 

ding  what  order  is  preferable. 
been  found  that  many  terms  of  the  assertion  may  be  ob­
tained  both  by  the  bottom-up  rules  and  by  repeated  use 
of  the  top-down  rules.  However,  usually  one  method 
w i ll  y i e ld 
e f f o rt 
f i r s t.  Experience  shows  that  there  is  a  need  for  i n­
teraction  between  the  top-down  and  bottom-up  ap­
proaches.  For  example,  we  may  use  established  invar­
iants  to  deduce  the  r e l a t i on  R  in  the  top-down  rule 
Ex2,  and  on  the  other  hand,  we  may  direct  the  search 
for  p a r t i c u l ar  invariants  based  on  variables  or  opera­
tors  which  appear  in  p. 

is  applied 

503 

504 

505 

to  e s t a b l i s h, 

i . e .,  the  claim  which  can  be  made  about  the  e f f e ct  on 
the  arrays  of  one  c i r c u it  through  the  loop.  This  claim 
is  often  not  d i f f i c u lt 
in  p a r t i c u l ar  f or 
loops  which  do  not  contain  other  loops  since  then  the 
c i r c u it  through  the  loop  is  a  simple  sequence  of  s t a t e­
ments.  The  assertion  can  be  most  easily  established  by 
the  known  technique  of  "backward  s u b s t i t u t i o n ",  moving 
backwards  around  the  loop  past  each  assignment  s t a t e­
ment. 

506 

assertions  w i ll  show  the  program  p a r t i a l ly  correct. 
We  c l e a r ly  could  have  used  the  t r a n s i t i v i ty  rule  here, 
but  f or  t h is  example, 
about  the  same. 

the  amount  of  work  required  is 

IV.  Conclusion 

Clearly, 

the  rules  and  examples  given  in  this  paper 
are  far  from  being  a  general  system  for  finding  induc­
t i ve  assertions.  More  and  better  rules  are  needed, 
p a r t i c u l a r ly  for  array  assertions,  which  tend  to  be 
complex  and  unwieldy. 

In  a d d i t i o n,  before  the  rules  can  be  incorporated 
i n to  a  p r a c t i c al  framework,  we  must  order  their  a p p l i­
cation.  That  i s,  at  each  step  we  must  provide  more 
exact  c r i t e r ia  for  deciding  which  rule  to  apply  and  on 
which  cutpoint  of  the  program. 
The  order  in  which  the 
rules  are  presented  in  each  subclass  does  i m p l i c i t ly 
provide  a  p a r t i al  s p e c i f i c a t i o n.  Thus  we  presently 
would  t ry 
etc.  Moreover,  we  generally  would  t ry  to  gather  i n­
formation  on  simple  variables  using  the  rules  of  Sec­
t i on  II  before  attempting  to 
treat  array  assertions. 

to  apply  Ex1,  and  only  if 

it  f a i l ed 

t ry  Ex2, 

The  more  basic  (and  open)  questions  are  (a)  whether 

is 

to  f i r st  use  top-down  rules 
(Since 
there  is  more  than  one  outer  loop,  usually 

to  attempt  top-down  or  bottom-up  techniques  f i r st  for 
a  given  loop,  and  (b)  which  loop  of  a  program  should 
be  treated  f i r s t.  Although  we  experimented  with 
various  orderings  in  the  examples  In  this  paper,  we 
have  t e n t a t i v e ly  formulated  a  more  fixed  approach. 
Our  present  I n c l i n a t i on 
from  the  (physical)  beginning  of  the  program. 
in  general 
only  entrance  rules  are  applicable.)  Then  we  use 
bottom-up  rules  for  the  same  loop, 
to  create  a  p  true 
after  e x it  from  the  f i r st  loop  containing  as  much  i n­
formation  as  possible.  We  continue  with  the  next 
outer  loop  In  a  similar  manner. 
stymied  and  unable 
with  top-down  rules  from  the  end  of  the  program,  and 
t ry  to  work  backwards  towards  the  beginning. 

to  find  a  loop  assertion,  we  start 

I f,  however,  we  are 

A  more  sophisticated  approach  would  require  a 

weighted  evaluation  function  capable  of  making  a  very 
cursory  scan  of  the  program.  This  function  would 
i d e n t i fy  loops  which  seemed 
to  y i e ld  valuable  information  r a p i d l y,  and  apply  selec­
ted  rules  f i r st  to  these  loops. 

'promising1, 

l i k e ly 

i . e. 

Since  some  of  the  rules  could  continue  searching 
for  a  possibly  non-existent  form  of  assertion  almost 
I n d e f i n i t e ly 
such  rules  would  have  a  "weak"  version  and  a  "strong" 
version.  The  "weak"  version  would  be  used  in  the 

(the  t r a n s i t i v i ty  r u l e, 

for  example), 

it  did  not  provide  an  almost 

i n i t i al  attempt  to  find  an  assertion,  and  would  "give-
up"  rapidly  if 
immediate 
solution.  Then  other,  possibly  more  appropriate,  rules 
may  be  t r i ed  on  the  cutpoint.  Only  if  a ll  rules  f a i l ed 
to  add  relevant  information,  would  the  "strong"  version 
be  applied.  This  d i v i s i on  is  p a r a l l el  to  the  human 
attempt  to  f i r st  find  what  Is  "obviously"  true  In  the 
loop,  and  only  afterwards  bring  out  the  f i ne  points. 

The  overall  strategy  we  have  adopted  in  t h is  paper 
has  been  to  find  assertions  strong  enough  to  prove  the 
p a r t i al  correctness  in  as  few  steps  as  possible.  Thus, 
in  general,  we  attempt  to  d i r e c t ly  produce  a  near-exact 
description  of  the  operation  of  a  loop,  without  going 
through  numerous  intermediate  stages  where  we  are  un­
able  to  shorn  either  v a l i d i ty  or  u n s a t l s f i a b i l i t y. 
If 
our  heuristic  is  wrong, 
t h is  fact  w i ll  be  revealed 
r e l a t i v e ly  rapidly  by  generating  an  unsatisfiable  v e r i­
f i c a t i on  condition.  We  then  may  t ry  a  weaker  a l t e r­
native  claim.  We  f e el  that  t h is  is  the  approach  which 
should  be  taken  in  order  to  construct  a  p r a c t i c al 
system  which  could  be  added  to  a  program  v e r i f i e r. 

We  believe  that  the  bottom-up  approach  may  also  be 

in  the 

the  inductive  assertion 

used  to  solve  other  problems.  For  example, 
p a r t i t i on  program  (Example  5 ), 
was  actually  found  without  using  the  w  given  by  the 
programmer. 
In  one  single  step  1)1  may  be  generated 
from  Q  ,  and  thus  we  have  'discovered'  what  the  program 
does  without  the  use  of  additional  information.  This 
feature  of  the  bottom-up  approach  can  probably  be  most 
useful 
i . e ., 
revealing  that  the  program  does  more  than  is  claimed 
in  w  . 

for  strengthening  a  too-weak  assertion, 

Another  apparent  application  is 

for  proving  termi­

to 

the  well-founded  set)  has 

nation  using  well-founded  sets.  For  termination, 
predicates  Qi  and  functions  ui  are  required,  where  ui 
(a  mapping 
bounded  by  Qi  and  descends  each  time  the  loop  Is  exe­
cuted.  Here  again  the  bottom-up  approach  is  useful 
since  no  w  Is  provided.  We  have  already  begun  inves-
t i g a t i ng  bottom-up  methods  for  generating  both  the 
Qi 
's  which  w i ll  ensure  termination. 

's  and  the  ui 
The  ultimate  goal  of  automatic  assertion  generation 

i ts  domain 

thus  the  optimal 

involve  man-machine  i n t e r a c t i o n.  Whenever 

is  almost  certainly  unattainable; 
system  would 
it  was  unable  to  generate  the  proper  assertion, 
machine  would  supply  detailed  questions  on  problematic 
relations  among  variables  and  possible  f a i l u re  points 
(incorrect  loops)  of  the  program.  Clearly,  a  p a r t i al 
specification  of  the  assertions,  provided  by  the 
programmer,  could  shorten  this  entire  process. 

the 

REFERENCES 

COOPER 

[ 1 9 7 1 ].  D.  C.  Cooper,  "Programs 
Program  V e r i f i c a t i o n ", 
in  Machine 
6,  American  E l s e v i e r,  p p.  43-59 

( 1 9 7 1 ). 

f or  M e c h a n i c al 
I n t e l l i g e n ce 

ELSPAS  et  a l. 

[ 1 9 7 2 ]. 

B.  E l s p a s,  M.W.  G r e e n,  K.N. 

L e v i tt  and  R . J.  W a l d i n g e r, 
a c t i ve  P r o g r a m - P r o v i ng  T e c h n i q u e s ",  S R I,  Menlo 
P a r k,  C a l. 

(May  1 9 7 2 ). 

"Research 

in 

I n t e r­

FLOYD 

" A s s i g n i ng  Meanings 

to 

[ 1 9 6 7 ].  R.W.  F l o y d, 
P r o g r a m s ", 
M a t h e m a t i c s,  V o l.  19 
AMS,  p p.  19-32 

( 1 9 6 7 ). 

in  P r o c.  of  a  Symposium 

in  A p p l i ed 
( J . T.  Schwartz  -  e d i t o r ), 

KING 

[ 1 9 6 9 ]. 

J.  K i n g, 

"A  Program  V e r i f i e r ",  Ph.D. 

T h e s i s,  C a r n e g i e - M e l l on  U n i v e r s i t y,  P i t t s b u r g h, 
Pa. 

( 1 9 6 9 ). 

WEGBREIT 

[ 1 9 7 3 ]. 

B.  W e g b r e l t, 

" H e u r i s t ic  Methods 

f or  M e c h a n i c a l ly  D e r i v i ng 
U n p u b l i s h ed  memo,  B o l t,  Beranek  and  Newman, 
I n c .,  Cambridge,  M a s s ., 

(February  1973). 

n d u c t i ve  A s s e r t i o n s ", 

512 

ITERATED  LIMITING  RECURSION  AND  THE  PROGRAM 
MINIMIZATION  PROBLEM. 

m a c h i n e s. 

Session  18  Automatic  Programming 

L . K.  S c h u b e rt 

D e p a r t m e nt  of  Computing  S c i e n c e,  U n i v e r s i ty 
o f A l b e r t a,  Edmonton,  A l b e r t a,  Canada. 

ABSTRACT: 

The  g e n e r al  p r o b l em  of 

f i n d i ng 

m i n i m al  p r o g r a ms 

r e a l i z i ng  g i v en 

" p r o g r am 

d e s c r i p t i o n s" 

is  c o n s i d e r e d,  where  program 

d e s c r i p t i o ns  may  s p e c i fy  a r b i t r a ry  program 

p r o p e r t i e s. 

The  p r o b l em  of 

f i n d i ng  m i n i m al 

programs  c o n s i s t e nt  w i th 

f i n i te  or 

i n f i n i te 

i n p u t - o u t p ut 

l i s ts 

is  a  s p e c i al  case 

( f or 

i n f i n i te 

i n p u t - o u t p ut 

l i s t s, 

t h is 

is  a  v a r i a nt 

of  E.M.  G o l d 's 

f u n c t i on 

i d e n t i f i c a t i on 

p r o b l e m;  a n o t h er  c l o s e ly 

r e l a t ed  p r o b l em 

is 

t ne  g r a m m a t i c al 

i n f e r e n ce  p r o b l e m ). 

A l t h o u gh 

most  p r o g r am  m i n i m i z a t i on  p r o b l e ms  are  n ot 

r e c u r s i v e ly  s o l v a b l e, 

t h ey  are 

f o u nd 

to  be  no 

more  d i f f i c u lt 

t h an 

t he  p r o b l em  of  d e c i d i ng 

w h e t h er  any  g i v en  p r o g r am  r e a l i z es  any  g i v en 

d e s c r i p t i o n,  or 

t he  p r o b l em  of  e n u m e r a t i ng 

programs 

in  o r d er  of  n o n d e c r e a s i ng 

l e n g th 

( w h i c h e v er 

is 

h a r d e r ). 

T h is 

r e s u lt 

is 

f o r m u l a t ed 

in 

t e r ms  of  k - l i m i t i ng 

r e c u r s i ve 

p r e d i c a t es  and 

f u n c t i o n a l s,  d e f i n ed  by 

r e p e a t ed  a p p l i c a t i on  of  G o l d 's 

l i m it  o p e r a t o r. 

A  s i m p le  consequence 

is 

t h at 

t he  program 

m i n i m i z a t i on  p r o b l em 

is 

l i m i t i ng 

r e c u r s i v e ly 

s o l v a b le 

f or 

f i n i te 

i n p u t - o u t p ut 

l i s ts  and  2-

l i m i t i ng 

r e c u r s i v e ly  s o l v a b le 

f or 

i n f i n i te 

i n p u t - o u t p ut 

l i s t s,  w i th  weak  a s s u m p t i o ns 

about 

t he  measure  of  p r o g r am  s i z e. 

Gold 

r e g a r d ed 

l i m i t i ng 

f u n c t i on 

i d e n t i f i c a t i on 

(more  g e n e r a l l y, 

" b l a ck  box" 

i d e n t i f i c a t i o n) 

as  a  model  of 

i n d u c t i ve 

t h o u g h t. 

I n t u i t i v e l y, 

i t e r a t ed 

l i m i t i ng 

i d e n t i f i c a t i on  m i g ht  be 

r e g a r d ed  as  h i g h e r - o r d er 

i n d u c t i ve 

i n f e r e n ce 

p e r f o r m ed  c o l l e c t i v e ly  by  an  e v er  g r o w i ng 

community  of 

l o w e r - o r d er 

i n d u c t i ve 

i n f e r e n ce 

KEY  WORDS  AND  PHRASES: 

f u n c t i on 

i d e n t i f i c a t i o n, 

m i n i m al  p r o g r a m s, 

l i m i t i ng 

r e c u r s i o n, 

i n d u c t i ve 

i n f e r e n c e,  p r o g r am 

l e n g th  m e a s u r e s,  p r o g r am 

p r o p e r t i e s,  degree  of  u n s o l v a b i l i t y. 

1. 

INTRODUCTION 

A  q u e s t i on  c o n s i d e r ed  by  Gold 

[1]  was 

f or 

what  c l a s s es  of  computable 

f u n c t i o ns 

t h e re 

e x i st  machines  w h i ch  succeed 

in 

" i d e n t i f y i ng 

in 

t he 

l i m i t"  any  member  of 

t he  c l a s s. 

I d e n t i f y i ng  a  computable 

f u n c t i on 

in 

t he 

l i m it 

c o n s i s ts  of  g e n e r a t i ng  a  sequence  of 

" g u e s s e s" 

( i n t e g e r s) 

c o n v e r g e nt 

to  an 

i n d ex 

f or 

t he 

f u n c t i o n,  s u c c e s s i ve  guesses  b e i ng  based  on 

s u c c e s s i v e ly 

l a r g er  p o r t i o ns  of  an 

i n f o r m a t i on 

sequence  w h i ch 

l i s ts  a ll  e l e m e n ts  of 

t he 

f u n c t i o n. 

An  example  of  a  p r a c t i c al  p r o b l em 

to  w h i ch 

t h e se  c o n c e p ts  are 

r e l e v a nt 

is 

t he 

l e a r n i ng  p r o b l em 

in  p a t t e rn 

r e c o g n i t i o n. 

T y p i c a l ly  an  a d a p t i ve  p a t t e rn 

r e c o g n i t i on 

system 

is  caused 

to 

" l e a r n"  a  mapping 

f r om 

p a t t e r ns 

to 

r e s p o n s es  by  p r e s e n t i ng 

to 

it  a 

sequence  of 

l a b e l l ed  p a t t e r n s, 

i . e .,  p a t t e r ns 

w i th 

t h e ir  a p p r o p r i a te 

r e s p o n s e s. 

A ll  of 

t he 

m a c h i n e 's 

responses  w i ll  c o n f o rm  w i th 

t he 

d e s i r ed  mapping  once 

it  has 

i d e n t i f i ed 

t h at 

m a p p i n g, 

in 

t he  sense 

t h at 

it  has 

f o u nd  an 

a l g o r i t hm 

( e q u i v a l e n t l y,  an 

i n d e x) 

f or 

i t. 

Two  of  G o l d 's  main 

r e s u l ts  were 

t h at  any 

r . e. 

c l a ss  of 

t o t al 

r e c u r s i ve 

f u n c t i o ns 

is 

i d e n t i f i a b le 

in 

t he 

l i m i t,  and 

t h at 

t he  c l a ss 

of 

t o t al 

r e c u r s i ve 

f u n c t i o ns 

is  n ot 

i d e n t i­

f i a b le 

in 

t he 

l i m it 

(hence  a l so 

t he  c l a ss  of 

p a r t i al 

r e c u r s i ve 

f u n c t i o ns 

is  n ot 

i d e n t i­

f i a b le 

in 

t he 

l i m i t ). 

Here  a  m o d i f i ed  v e r s i on  of  G o l d 's  p r o b l em 

is  c o n s i d e r e d. 

The 

f i r st  m o d i f i c a t i on 

is 

t he 

r e p l a c e m e nt  of 

i n f o r m a t i on  sequences  by 

( f i n i te  or  i n f i n i t e) 

"program  d e s c r i p t i o n s" 

is  also  suggested  by 

the  work  of  Kolmogorov 

which  may  specify  a r b i t r a ry  program  p r o p e r t i e s. 

[ 6 ],  M a r t i n - L of 

[7]  and  o t h e r s,  showing 

t h at 

Descriptions  which 

l i st 

i n p u t - o u t p ut  p a i rs  are 

the  number  of  symbols 

in 

the  s h o r t e st  program 

then  regarded  as  a  s p e c i al  case.  The  second 

f or  generating  a  f i n i te  sequence  can  be 

taken 

m o d i f i c a t i on 

is 

t h at 

i t e r a t ed 

l i m it  procedures 

as  a  measure  of 

the 

i n f o r m a t i on  content  of 

the 

( I t - l i m i t i ng  r e c u r s i ve  f u n c t i o n a l s)  are 

sequence,  and  t h is  measure  provides  a  l o g i c al 

admitted 

f or  p r o g r a m - f i n d i n g,  since 

f i n d i ng 

basis 

f or 

i n f o r m a t i on 

theory  and  p r o b a b i l i ty 

s u i t a b le  programs 

in 

the  n o n - i t e r a t ed 

l i m it 

theory. 

is  impossible  f or  many  classes  of  program 

In 

the 

f o l l o w i ng 

the  u n s o l v a b i l i ty  of  most 

d e s c r i p t i o n s. 

For  t h is  purpose  k - l i m i t i ng 

n o n t r i v i al  program  m i n i m i z a t i on  problems 

is 

recursiveness 

is  defined  by  s t r a i g h t - f o r w a rd 

f i r st  noted. 

A f t er  establishment  of  some 

g e n e r a l i z a t i on  of  Gold's  concept  of 

l i m i t i ng 

basic  p r o p e r t i es  of  k - l i m i t i ng 

r e c u r s i ve 

recursiveness. 

The 

t h i rd  m o d i f i c a t i on  is 

the 

predicates  and 

f u n c t i o n a l s, 

it 

is  shown 

t h at 

added  requirement  t h at  programs 

found 

in 

the 

any  program  m i n i m i z a t i on  problem 

is  k - l i m i t i ng 

( i t e r a t e d) 

l i m it  be  minimal  according  to  some 

r e c u r s i v e ly  solvable 

if 

the  problem  of  determ-

prescribed  measure  of  program  s i z e. 

i n i ng  whether  any  given  program  s a t i s f i es  any 

Accordingly  problems  of 

t h is  m o d i f i ed  type  are 

given  d e s c r i p t i on 

is  k - l i m i t i ng 

r e c u r s i v e ly 

c a l l ed  program  m i n i m i z a t i on  problems. 

solvable  and  programs  are  k - l i m i t i ng  r . e. 

in 

There  are  various  reasons 

f or  an 

i n t e r e st  order  of  nondecreasing  s i z e. 

Simple  conse-

in  f i n d i ng  m i n i m a l - l e n g th  programs. 

In  work 

quences  are 

t h at 

the  problem  of 

f i n d i ng 

on  grammatical 

inference  c l o s e ly  r e l a t ed  to 

minimal  programs 

f or 

f i n i te 

f u n c t i o ns 

is 

Gold's 

i d e n t i f i c a t i on  problem,  Feldman 

[2] 

l i m i t i ng  r e c u r s i v e ly  s o l v a b l e,  and 

t h at 

the 

considers 

inference  schemes  which 

t ry  to 

f i nd 

problem  of 

f i n d i ng  minimal  programs 

f or 

"good"  grammars  c o n s i s t e nt  w i th  a v a i l a b le 

a r b i t r a ry  computable 

f u n c t i o ns 

(given  an 

i n f o r m a t i on  about  a  language.  One  measure 

e x p l i c it 

l i s t i n g) 

is  2 - l i m i t i ng 

r e c u r s i v e ly 

of  goodness 

is 

the  i n t r i n s ic  complexity,  or 

s o l v a b l e,  w i th  weak  assumptions  about 

the 

s i z e,  of  a  grammar. 

In 

terms  of 

the  f u n c t i on  measure  of  program  s i z e. 

Lower  bounds  on 

the 

i d e n t i f i c a t i on  problem, 

t h is  corresponds 

to 

d i f f i c u l ty  of 

these  problems  are  already  known 

f i n d i ng  programs  which  are  small  according 

from 

the  work  of  Pager 

[8]  and  Gold 

[ 1 ]. 

to  some  measure  of  program  s i z e. 

Indeed, 

the 

F i n a l l y, 

the  p o i nt 

is  emphasized 

in 

the 

use  of  small  programs 

f or 

i n d u c t i ve  inference 

concluding  remarks 

t h at 

l i m i t i ng 

r e c u r s i v e ly 

is  a  r e c u r r i ng 

theme 

in  the 

l i t e r a t u re 

(see 

solvable 

i n d u c t i on  problems, 

though  s t r i c t ly 

f or  example  Refs.  3 - 5 );  a l l u s i on  is  u s u a l ly 

"unsolvable" 

in  g e n e r a l,  are  nonetheless  w i t h-

made  to  the  s c i e n t i f ic  maxim  knows  as 

in 

the  reach  of  mechanical  procedures 

in 

the 

"Occam's  Razor",  according 

to  which  " it  is 

important  sense  described  by  Gold,  and  t h at 

vain 

to  do  w i th  more  what  can  be  done  w i th 

even  problems  unsolvable 

in 

the 

l i m it  may  be 

fewer" 

in  accounting  f or  known  phenomena. 

regarded  as  solvable  in  a  weakened  sense  by  an 

The  s p e c i al  importance  of  minimal  programs 

expanding  community  of  mechanisms  performing 

514 

l i m it  c o m p u t a t i o n s. 

assumed  to  be  e f f e c t i v e ly  enumerable 

in  order 

2.  PROGRAM  MINIMIZATION  PROBLEMS 

of 

n°ndecreasing  l e n g t h.  For  example,  the 

To  f ix  i d e a s,  any  programmable  machine  M 

number  of  elementary  symbols 

in  a  program 

may  be  thought  of  as  a  2-tape  Turing  machine, 

provides  such  a  l e n g th  measure, 

w i th  one  tape  regarded  as  i n p u t - o u t p ut  (I/O) 

In 

the 

f o l l o w i n g,  o b v i o u s ly  machine  and 

tape  and  the  o t h er  as  program  t a p e.  One  or 

length-measure  dependent  concepts  w i ll  some-

both  tapes  a l so  serve  as  working  t a p e.  A 

times 

be 

used 

w i t h o ut  e x p l i c it  r e f e r e n ce  to  a 

computation  begins  w i th  the  f i n i t e - s t a te 

p a r t i c u l ar  machine  or  l e n g th  measure. 

This 

c o n t r ol  of  the  machine  in  a  unique  s t a rt  s t a te 

should 

be  kept  in  mind  f or  a  c o r r e ct  i n t e r-

and  w i th  a  program  on  the  program  tape  and  an 

p r e t a t i on  of 

the  r e s u l t s. 

i n p ut  on  the  I/O  t a p e. 

If  and  when  the  machine 

a 

minimal 

Program  f or  a  f u n c t i on  O  is  one 

h a l t s, 

the 

I/O 

tape 

expression 

g i v es 

the 

o u t-  Whose 

length  does  not  exeed  the 

length  any 

p u t. 

It  is  assumed  t h at  t h e re  is  an  e f f e c t i ve 

otherr  Program  f or  4,. 

The  problem  of 

f i n d i ng  a 

1-1  coding 

from  tape  expressions 

(same  syntax 

minimal 

program  (or  a ll  minimal  programs) 

f or 

f or  b o th  tapes)  onto  the  i n t e g e rs  N. 

The 

a 

f u n c t i on  O  given  a  ( p o s s i b ly  i n f i n i t e) 

l i st 

program (or I/O tape expression) corresponding of the elements of ♦, is an example of a code number (index) X be written as ■i.i. ~ program m i n i m i z a t i on problem. More g e n e r a l l y, 
to code number (index) x w i ll be w r i t t en as x. Program problem generally 
TC  ,. 
-  ,,u_„ 
If  M  e v e n t u a l ly  h a l ts  w i th  o u t p ut  z  when 

a  program  m i n i m i z a t i on  problem  is 

the  problem 

r  ■» 

. .. 

.  . 

. , 

e 

c 

. 

. 

, 

, 

- 

.  - 

.  .. 

„.,„ 
s u p p l i ed  w i th  program  x  and  i n p ut  y,  one  may 
T.  ,„ 
J.M/,,\ 
If  M  does  not  h a l t,  <t>  (Y) 

w r i te  4>  (y)  =  z. 
m. 

x 
i 
is  u n d e f i n e d.  Thus  M  computes  a  p a r t i al 

,M,  . 
x 
-  ^. 

.  , 

i. • 

.  . 

-, 

., 

- 

. 

. 

, 

, 

,M 

. 

, 

- 

f u n c t i on  $x  w i th  program  x.  However, 
. 

,_  - 

be  convenient  to  t h i nk  of  x  not  merely  as  a 

. .  ■ , i 
it  w i ll 

M 

program  f or  tj> 
M 
. 

subset  of  $ 

,  b ut  as  a  program  f or  any 

In  o t h er  words,  x  is  a  program 

- 

. 

.  , 

, 

,,_  _  ,M,  . 
lyJ  = 

f or  a  f u n c t i on  $  p r o v i d ed  o n ly  t h at  cp 

,  , 
<My) 

M, 
f or  a ll  y  in  the  domain  of  <j>;  *x( y> 
need  n ot  be  undefined  f or  y  o u t s i de  t h at 

,. 

= 

. 

. 

of 

f i n d i ng  a  minimal  program  (or  a ll  minimal 

3 

programs)  meeting 

the  c o n d i t i o ns 

l i s t ed  in  any 

"program  d e s c r i p t i o n"  belonging  to  some  class 
v  •» 
of  such  d e s c r i p t i o n s.  Program  d e s c r i p t i o ns 

are  l o o s e ly  d e f i n ed  as 

f o l l o w s.  Suppose  t h at 

a 

( p o s s i b ly  i n f i n i t a r y) 

l o g i c al  system  is 

q i v en  along  w i th  an  i n t e r p r e t a t i on  based  on  a 

y 

f i x ed  M  such  t h at  every  w ff  in  tne  system 

expresses  some  program  p r o p e r ty 

( i . e .,  every 

w ff  is  a  unary  p r e d i c a te  over  programs). 

Then 

domain. 

, 
If  such  an  x  e x i s ts  f or  a  g i v en  q>,  <p 

the  w f is  comprising 

the  system  w i ll  be  c a l l ed 

. 

,  , 

,* 
w i ll  be  s a id  to  be  programmable  (on  M)  .  A 

, 

„

,

,

,

.

machine  on  which  a ll  p a r t i al  r e c u r s i ve 

f u n c t i o ns  are  programmable 

, 
is  u n i v e r s a l. 

A  program  l e n g th  measure  assigns  a  non-

n e g a t i ve  i n t e g r al 

. 
l e n g th  to  each  program  such 
- 

t h at  o n ly  a  f i n i te  number  of  programs  are  o£ 

any  p a r t i c u l ar  l e n g t h.  A  l e n g th  measure  need 

n ot  be  r e c u r s i v e, 

though  t h is  is  a  f r e q u e nt 

, 

assumption; 

f u r t h e r m o r e,  programs  are  o f t en 

program  d e s c r i p t i o n s.  T y p i c a l ly  a  program 
c—*- 

-* 

d e s c r i p t i on  might  s p e c i fy  r e l a t i o n s h i ps  between 

i n p u ts  and  o u t p u ts 

( e . g .,  p a r t i c u l ar 

i n p u t - o u t-

p ut  p a i r s ),  s t r u c t u r al  p r o p e r t i es 

( e . g ., 

the 

number  of  occurrences  of  a  p a r t i c u l ar  symbol 

in  the  program),  o p e r a t i o n al  p r o p e r t i es 

( e . g ., 

computational  c o m p l e x i t y ),  or  combinations  of 

such  p r o p e r t i e s. 

If  6  is  a  program  d e s c r i p t i o n, 

a  program  x  w i ll  be  s a id  to  r e a l i ze  6 
^ 

J. 

e x p r e s s ed 

p r o p e r f cy 

by 

^ 

if  x 

515 

expressed  as  a  t o t al 

f u n c t i on  t h is 

is 

Thus  a  mapping  whose  domain  contains  coded 

representations  of 

i n f i n i te  d e s c r i p t i o ns 

is  a 

f u n c t i o n a l. 

The  coded  v e r s i on  of  a  d e s c r i p t i on  o, 

whether 

it 

is 

f i n i te  or 

i n f i n i t e,  w i ll  be 

w r i t t en  as  6.  Since  no  confusion  can  r e s u l t, 

coded  r e p r e s e n t a t i o ns  of  d e s c r i p t i o ns  w i ll  also 

simply  be  c a l l ed  d e s c r i p t i o n s.  A  set  of 

d e s c r i p t i o ns  w i ll  be  c a l l ed 

i n f i n i t e ly 

diverse 

if  no  set  of  programs  r e a l i z i na 

the 

d e s c r i p t i o ns 

is 

f i n i t e. 

Theorem  1 

is  concerned  w i th 

I/O  d e s c r i p t i o ns 

o n l y,  w h i le  Theorems  3  and  4  w i ll  apply  to 

a r b i t r a ry  program  d e s c r i p t i o n s. 

Theorem  1. 

Let  M  be  a  u n i v e r s al 

programmable  machine  and 

l et  a  r e c u r s i ve 

length  measure  be  g i v e n. 

Then  the  program 

m i n i m i z a t i on  problem 

is  not  r e c u r s i v e ly 

solvable 

f or  any  e f f e c t i v e ly  enumerable, 

i n f i n i t e ly  diverse  set  of 

I/O  d e s c r i p t i o n s. 

Proof: 

Pager 

[8]  p r e v i o u s ly  noted  t h is 

f a ct 

f or 

the  case  when 

I/O  d e s c r i p t i o ns 

specify 

f i n i te 

f u n c t i o n s,  and  remarked 

t h at 

the  proof  involves 

the  Recursion  Theorem. 

I 

formulated  Theorem  1 

independently  and  proved 

i t, 

in  o u t l i n e,  as 

f o l l o w s.  The  negation  of 

the 

theorem  allows 

the  c o n s t r u c t i on  of  a 

program  which  enumerates  d e s c r i p t i o ns  and 

corresponding  minimal  programs  u n t il 

it 

f i n ds 

a  minimal  program 

longer 

than 

i t s e l f; 

it 

then 

simulates 

t h at  program,  and  c o n t r a d i c t i on 

r e s u l t s. 

The  p o s s i b i l i ty  of  a  program 

measuring 

i ts  own  length  and 

then  performing 

other  a r b i t r a ry  c a l c u l a t i o ns 

f o l l o ws 

from 

the 

existence  of  a  r e c u r s i ve  f u n c t i on  g  such  t h at 

516 

be  proved  from  the  S-m-n  Theorem  and  the 

Recursion  Theorem. 

To  demonstrate  the  u n s o l v a b i l i ty  of  a 

For  example,  suppose  the  minimal  programs  are 

required 

to  operate  w i t h in  a  c e r t a in  bound  on 

the  computational  complexity,  apart  from  an 

program  m i n i m i z a t i on  problem 

(for  a  u n i v e r s al 

a r b i t r a ry  a d d i t i ve  constant. 

Then 

it 

is  clear 

machine), 

it 

is 

t h e r e f o re  s u f f i c i e nt 

to  show 

t h at  the  proof  of  Theorem  1 

is  applicable 

t h at 

the  d e s c r i p t i o ns  concerned 

include  an 

w i t h o ut  change. 

e f f e c t i v e ly  enumerable, 

i n f i n i t e ly  diverse 

set  of 

I/O  d e s c r i p t i o n s. 

This 

i m p l i e s, 

f or 

example, 

t h at 

the  program  minimization 

problem 

f or 

the  s i n g l e t on 

f u n c t i o n s, 

f or 

the 

f i n i te  d e c i s i on 

f u n c t i o n s,  and  even  f or  the 

d e c i s i on 

f u n c t i o ns  of  c a r d i n a l i ty  2 

is 

These  u n s o l v a b i l i ty  r e s u l ts  do  not  mean 

t h at  a ll 

i n t e r e s t i ng  program  minimization 

problems  are  e n t i r e ly  beyond  the  reach  of 

mechanical  procedures,  as  Theorem  3  w i ll  show. 

The 

f o l l o w i ng  d e f i n i t i o ns  generalize 

the 

concept  of  l i m i t i ng  recursion 

introduced  bv 

unsolvable 

2 

,  whenever  the 

length  measure 

is 

Gold 

[ 1 ]. 

r e c u r s i v e. 

Pager 

[9]  has  shown 

t h at  the 

last-mentioned 

problem  is  unsolvable  even  when  the  length 

measure 

is  not  r e c u r s i v e. 

Further,  he 

established 

the  s u r p r i s i ng 

f a ct 

t h at 

the 

m i n i m i z a t i on  problem 

is  unsolvable 

f or  a 

c e r t a in 

f i n i t e ly  diverse  set  of  d e c i s i on 

f u n c t i o n s, 

regardless  of 

the 

length  measure 

employed 

[ 8 ]. 

In  view  of  Pager's  r e s u l ts 

it  may  be 

asked  whether 

the  requirement 

t h at 

the 

length 

measure  be  r e c u r s i ve 

is  superfluous 

in 

Theorem  1. 

The  answer  is  no 

(although  the 

requirement  can  be  weakened  somewhat).  To 

prove 

t h i s, 

it 

is  only  necessary 

to  specify 

some  sequence  of 

f i n i te  decision 

functions 

such  t h at  any  program  is  a  program  f or  at 

most  one  of  these  f u n c t i o n s,  plus  an 

a r b i t r a ry  procedure 

f or  o b t a i n i ng  a 

p a r t i c u l ar  program  f or  each 

f u n c t i on 

in  the 

sequence; 

then 

the 

length  measure  can  r e a d i ly 

be  defined 

to  guarantee  the  m i n i m a l i ty  of 

these  p a r t i c u l ar  programs. 

It 

is 

i n t e r e s t i ng 

to  note 

t h at  Theorem  1 

s t i ll  holds 

f or  c e r t a in  non-1/0  d e s c r i p t i o n s. 

understood) 

if 

there 

is  a  predicate  P  k - l i m i t i nq 

decidable  on  AxN  such  t h at  f or  Sea,  P(6,x) 

holds 

i ff  

A  set  of 

integers 

is  k - l i m i t i ng 

r . e. 

if 

it 

is  empty  or 

the  range  of  a 

f u n c t i on 

5 

k - l i m i t i ng  r e c u r s i ve  on  N. 
recursive  is  the  same  as  r e c u r s i v e,  and  1-
l i m i t i ng  recursive 
r e c u r s i v e. 

is  abbreviated  as 

O - l i m i t i ng 

l i m i t i ng 

Gold 

(also  Putnam  [10 J)  has  shown  t h at 

517 

so 

t h at  g 

is 

( k + 1 ) - l i m i t i ng  r e c u r s i v e. 

Roughly  speaking,  Theorem  3  s t a t es  t h at 

f i n d i ng  minimal  programs 

is  no  more  d i f f i c u lt 

than  enumerating  programs 

in  order  of  non-

decreasing 

length  or  deciding  whether  a  given 

program  r e a l i z es  a  given  d e s c r i p t i on 

Now 

if 

the  set  of 

indices  of 

the  minimal 

(whichever 

is  h a r d e r ),  where 

the  " d i f f i c u l t y" 

programs  r e a l i z i ng  6 

is  expressed  by 

i ts 

of  a  k - l i m i t i ng  r e c u r s i ve 

f u n c t i o n al 

is  k. 

canonical 

index 

Theorem  3.  Given: 

a  programmable  machine 

M,  a  length  measure  such  t h at  programs  are  k-

l i m i t i ng 

r . e. 

in  order  of  nondecreasing 

l e n g t h,  and  a  set  A  of  r e a l i z a b l e,  u n i f o r m ly 

k - l i m i t i ng  decidable  program  d e s c r i p t i o n s. 

is 

where  Cp 
w i th  P  defined  as 

in  Theorem  3, 

then 

the  c h a r a c t e r i s t ic 

f u n c t i on  of  P, 

Then  the  program  m i n i m i z a t i on  problem  f or 

a p p l i c a t i on  of  Lemma  2  shows 

i  . 

to  be  k-

A 

is  k - l i m i t i ng  r e c u r s i v e ly  s o l v a b l e. 

l i m i t i ng  r e c u r s i ve  on 

Proof: 

Since  programs  are  k - l i m i t i ng  r . e. 

Note 

t h at  because  of 

the  assumption 

in 

in  order  of  nondecreasing 

l e n g t h, 

there 

is  a 

Theorem  4 

t h at 

the 

length  measure 

is  k-

k - l i m i t i ng  r e c u r s i ve 

f u n c t i on 

f  which  maps  N 

l i m i t i ng  r e c u r s i v e.  Theorem  3  cannot  be 

regarded  as  a  consequence  of  Theorem  4. 

Note  also 

t h at  any 

( k - 1 ) - l i m i t i ng  r e c u r s i ve 

length  measure  s a t i s f i es 

the  c o n d i t i o ns  of 

Theorem  4 

(by  Theorem  2 ). 

Theorems  3  and  4  are  the  main  r e s u l ts  of 

t h is  paper. 

The  remaining 

theorems 

i l l u s t r a te 

t h e ir  a p p l i c a t i o n. 

Theorem  5. 

For  any  r e c u r s i ve 

length 

measure, 

the  problem  of 

f i n d i ng  a ll  minimal 

programs 

f or 

f i n i te  programmable 

f u n c t i o ns 

is 

l i m i t i ng  r e c u r s i ve 

(each 

f i n i te 

f u n c t i on 

is  assumed  to  be  s p e c i f i ed  by  a  program 

d e s c r i p t i on  which 

l i s ts 

the  argument-value 

p a i rs  of 

the 

f u n c t i on 

in  any  o r d e r ). 

Theorem  4.  Given: 

a  k - l i m i t i ng  r e c u r s i ve 

length  measure  such 

t h at  programs  are  k-

in  order  of  non-decreasing 

l i m i t i ng  r . e. 
l e n g th  and  a  set  A  of  r e a l i z a b l e,  u n i f o r m ly 
k - l i m i t i ng  decidable  program  d e s c r i p t i o n s. 

Then 

the  problem  of 

f i n d i ng  a ll  minimal 

programs  r e a l i z i ng  any  6eA 

is  k - l i m i t i ng 

r e c u r s i v e ly  s o l v a b l e. 

C l e a r ly  Q 

is  decidable  and 

r e p e t i t i o n ). 

f i n d i ng  a ll  minimal  programs 

f or  any 

f i n i te 

f u n c t i on 

is 

l i m i t i ng  r e c u r s i v e. 

Theorem  6.  Given  a  r e c u r s i ve  length 

Theorem  7.  For  any  M  and  any  l i m i t i ng 

recursive  length  measure, 

the  problem  of 

f i n d i ng  minimal  programs 

f or 

functions 

programmable  on  M  is  2 - l i m i t i ng  r e c u r s i ve 

(as 

in  Theorem  6, 

the  problem 

is 

i n t e r p r e t ed  in 

measure  and  a  machine  M  which  computes  t o t al 

terms  of  program  d e s c r i p t i o n s,  where  any 

f u n c t i o ns  o n l y, 

the  problem  of 

f i n d i ng 

d e s c r i p t i on 

l i s ts 

the  argument-value  p a i rs  of 

minimal  programs 

f or 

functions  programmable 

a  programmable 

f u n c t i on  in  any  o r d e r ). 

on  M  is 

l i m i t i ng  r e c u r s i ve  (each  programmable 

f u n c t i on  is  assumed  to  be  s p e c i f i ed  by  a 

program  d e s c r i p t i on  which 

l i s ts 

the  argument-

value  p a i rs  of 

the 

f u n c t i on 

in  any  o r d e r ). 

Gold  had  already  shown  t h at  the  problem 

of 

f i n d i ng  any  programs 

{not  necessarily 

minimal) 

f or  members  of  a  r . e,  class  of 

t o t al 

f u n c t i o ns 
[2] 

l i m i t i ng  r e c u r s i v e,  and  Feldman 
remarked  t h at  t h is  can  be  extended  in  an 

is 

e 

obvious  way 

to 

f i n d i ng  minimal  programs 

when  programs  are  r . e. 

in  order  of  non-

decreasing  l e n g t h.  Theorem  6  strengthens 

t h is  r e s u lt  s l i g h t l y,  as 

there  are  r e c u r s i ve 

length  measures 

f or  which  programs  are  not 

r . e. 

in  order  of  nondecreasing 

length 

( e . g ., 

d e f i ne 

so  t h at  the  sequence 

it 

t h at 

Note 
the  problem  is  not 

is  known 

t h at 
r e c u r s i v e. 

from 

the  work  of  Gold 

in  general 

l i m i t i ng 

to 

The 

theorem 

is  r e a d i ly  generalized 
descriptions  which  prescribe  divergent 
computations 
minimization  problem  remains  2 - l i m i t i ng 
r e c u r s i v e. 
4.  Remarks  on  Induction  and  I t e r a t ed  L i m i t i ng 

f or  some  i n p u t s. 

The 

Recursion 
Deduction 

is  concerned  w i th 

the  d e r i v a t i on 

enumerates  a  r . e .,  nonrecursive  set  without 

of  p a r t i c u l ar  conseauences 

from  oeneral 

521 

premises,  w h i le 

i n d u c t i on 

the  i ' th  t h i n k er  T. 

regards  as  h is  best 

proceeds 

in  the  opposite  d i r e c t i o n. 

The 

guess 

the  s h o r t e st  program 

( if  any)  he  has 

problem  of  f i n d i ng  an  a l g o r i t hm 

{minimal  or 

been  able 

to  f i nd  which, 

in 

the 

time 

otherwise) 

f or  a  f u n c t i o n,  a f t er 

i n s p e c t i on 

of  some  but  not  a ll  values  of 

the 

f u n c t i o n, 

is 

c l e a r ly  of 

the 

i n d u c t i ve 

t y p e: 

the  complete 

a v a i l a b l e,  has  given  c o r r e ct  outputs 
YO,Y1
i n p u ts 
a  c o r r e ct  output 

f or  any  other  argument 

a n (*  e i t h er  no  output  or 

 

f or 

a l g o r i t hm  proposed  on 

the  basis  of 

incomplete 

t e s t e d. 

It 

is  c l e ar 

t h at  each 

t h i n k er  w i ll 

i n f o r m a t i on  expresses  a  g e n e r a l i z a t i on  about 

e v e n t u a l ly  be  guessing  a  program  f or  a  subset 

the 

f u n c t i on  sampled.  N o n - t r i v i al 

i n d u c t i ve 

of  $; 

f u r t h e r m o r e,  a ll  but  a 

f i n i te  number  of 

problems  are 

i n h e r e n t ly  "unsolvable" 

in 

the 

the  t h i n k e rs  w i ll  be  guessing  programs  f or  <j> 

sense  t h at  no  t e r m i n a t i ng  procedure  e x i s ts 

e v e n t u a l l y. 

In 

t h is 

i t e r a t ed 

l i m i t i ng  sense 

f or  generating  " c o r r e c t"  g e n e r a l i z a t i o n s;  any 

the  expanding  community  s u c c e s s f u l ly 

u n v e r i f i ed  consequence  of  a  proposed 

i d e n t i f i es  *.  Of  course  there 

is  no  s t r a t e gy 

g e n e r a l i z a t i on  may  t u rn  out 

to  be 

in  e r r o r. 

e f f e c t i ve 

in 

the 

l i m it 

f or  deciding 

in  general 

This  motivated  Gold's  d e f i n i t i on  of 

l i m i t i ng 

which  t h i n k e rs  are  guessing  programs 

f or  $  at 

r e c u r s i ve  predicates  and 

f u n c t i o n a l s,  which 

any  t i m e. 

To  i n t e r p r et  t h i r d - o r d er 

l i m it 

are  more  powerful 

than 

t h e ir  n o n - l i m i t i ng 

processes,  one  might  envisage  a  growing 

c o u n t e r p a r t s.  He  noted  t h at  a  " t h i n k e r" 

number  of  expanding  communities  of 

the  above 

employing  a  procedure 

f or 

f u n c t i on 

(or  " b l a c k-

t y p e,  each  committed  to  a  d i s t i n ct  value  of  a 

box") 

i d e n t i f i c a t i on 

in 

the 

l i m it  and  using 

c e r t a in  parameter.  At  most 

f i n i t e ly  many  of 

the  c u r r e nt  guess  of  a 

f u n c t i o n 's 

i d e n t i ty  as 

the  unbounded  communities  would  in,, general 

a  basis 

f or  g o a l - d i r e c t ed  a c t i v i ty  would  be 

be  " u n s u c c e s s f u l ". 

S i m i l a r ly  s t i ll  h i g h e r-

a c t i ng  on  c o r r e ct 

i n f o r m a t i on  e v e n t u a l l y. 

order  processes  could  be 

i n t e r p r e t e d. 

In  t h is  sense, 

t h e r e f o r e,  some  unsolvable 

Acknow1edgement 

problems  are  w i t h in 

the  reach  of  mechanical 

procedures, 

The  most  general 

f u n c t i on 

i d e n t i f i c a t i on  problem,  however, 

is  2 - l i m i t i ng 

r e c u r s i v e.  Can  any  mechanical  system  be 

conceived  which 

in  some  sense  "solves"  a  2-

l i m i t i ng 

r e c u r s i ve  problem?  Not 

if  a t t e n t i on 

is  r e s t r i c t ed 

to  a  s i n g le  " t h i n k e r"  generating 

a  s i n g le  sequence  of  guesses;  however,  suppose 

t h at  instead  of  a  s i n g le  t h i n k e r,  each  of  an 

ever  growing  number  of  such 

t h i n k e rs  TD, T . , . .. 

w i th  u n i v e r s al  computational  power  observes 

the  non-terminating  sequence 

<Y0'Z0>,<Y1Z1>,......Which 
p a r t i al  r e c u r s i ve 

enumerates  some 
time 

f u n c t i on  O.  At  any 

I  am  indebted 

to  C.G.  Morgan 

f or  several 

s t i m u l a t i ng  and  h e l p f ul  discussions  and 

to 

J.R.  Sampson 

f or  h is  many  useful  comments  on 

the  manuscript. 

I . N.  Chen's  help  on  some 

aspects  of 

the  paper 

is  also  g r a t e f u l ly 

acknowledged.  The  research  was  conducted 

under  a  N a t i o n al  Research  Council  postdoctorate 

f e l l o w s h i p. 

Footnotes 
i 
A  code 

i n to 

t o t al 

f u n c t i o ns  would  also  be 

used 

f or  a  mixture  of 

f i n i te  and 

i n f i n i te 

d e s c r i p t i o n s;  one  d i g i t,  say  0,  would  be 

reserved  as 

t e r m i n a t or  and  a ll 

f u n c t i on  values 

corresponding  tp  p o i n ts  beyond  the  end  of  a 

Memo  AI-93 

(1969);  also  I n f.  and  Control 

f i n i te  d e s c r i p t i on  would  be  set  to  0. 
2 

2_0,  244-262  (1972)  . 

For 

the 

f i n i te  d e c i s i on 

f u n c t i o n s,  note 

t h at 

3.  R.  Solomonoff,  "A  Formal  Theory  of 

the 

f u n c t i o ns  computed  w i th  any 

f i n i te  set  of 

programs  can  be  diagonalized  to  y i e ld  a  f i n i te 

Inductive  I n f e r e n c e ," 
(1964), 
1-22,  224-254 

I n f.  and  Control  7, 

d e c i s i on  f u n c t i on  which  requires  a  program 

4.  G.  C h a i t i n,  "On  the  D i f f i c u l ty  of 

not  in  the  given  s e t. 

To  prove  i n f i n i te 

Computations," 

IEEE  Trans. 

I n f.  Theory 

d i v e r s i ty 

f or 

the  2-element  decision 

f u n c t i o n s, 

IT-16,  5-9 

(1970). 

it 

is  s u f f i c i e nt 

to  show 

t h at  no  set  of  n 

5.  D.G.  W i l l i s, 

"Computational  Complexity 

programs  can  include  a  program  f or  each  2-

element  d e c i s i on  f u n c t i on  whose  arguments  are 

and  P r o b a b i l i ty  Constructions,"  J.  Assoc. 
Comp.  Mach.  17,  241-259  (1970). 

in  a  f i x ed  set  of  2 

i n t e g e r s;  but 

f or 

t h is 

6.  A.N.  Kolmogorov,  "Three  Approaches 

to  the 

many  arguments  at  l e a st  2  of  the  programs 

q u a n t i t a t i ve  D e f i n i t i on  of 

I n f o r m a t i o n ," 

must  g i ve 

i d e n t i c al  r e s u l ts 

{ if  any),  so  t h at 

Inform.  Transmission  1,  3-11 

(1965);  also 

I n t.  J.  Comp.  Math  2,  157-168 

(1968). 

7.  P.  M a r t i n - L o f, 

"The  D e f i n i t i on  of  Random 

Sequences," 

I n f.  and  Control  9_,  602-619 

(1966). 

8.  D.  Pager, 

"On  the  Problem  of  Finding 

Minimal  Programs 

f or  Tables", 

I n f.  and 

Control  14,  550-554 

(1969)  . 

9.  D.  Pager,  "Further  Results  on  the  Problem 

of  Finding 

the  Shortest  Program  f or  a 

Decision  Table,"  presented  at  Symposium 

on  Computational  Complexity,  Oct.  25-26, 

1971;  abstracted  in  SIGACT  News,  No.  13 

(Dec.  1971)  . 

10.  H.  Putnam,  " T r i al  and  Error  Predicates 

and 

the  S o l u t i on  of  a  Problem  of 

Mostowski,"  J.  Symb.  Logic  30,  49-57 

(1965). 

two  unsymmetric  d e c i s i on 
3 
Functions  are  regarded  as  a  special  case  of 

functions  are  missed. 

f u n c t i o n a l s. 

The  equivalence 

f o l l o ws 

from  the  f a ct 

t h at 

F(6) 

is 

independent  of  n . , . . . , n ,,  so  t h at 

the 

l i m it  of  G  must  e x i s t. 

i t e r a t ed 
5 
This  d i f f e rs 

from  Gold's  d e f i n i t i o n,  which 

expresses 

l i m i t i ng  r e c u r s i ve  enumerability 

in 

terms  of 

l i m i t i ng  s e m i - d e c i d a b i l i t y. 

However, 

the  d e f i n i t i o ns  can  be  shown  to  be 

equivalent 

( f or  k = l ). 

A c t u a l l y,  Feldman  was  concerned  w i th  "occams 

enumerations"  of 

formal  grammars,  but  the 

problem  of 

f i n d i ng  minimal  grammars 

f or 

languages 

is  e s s e n t i a l ly 

the  same  as 

t h at  of 

f i n d i ng  minimal  programs 

f or  decision 

f u n c t i o n s. 

References 
1.  E.M.  Gold, 

" L i m i t i ng  Recursion,"  J. 

Symb.  Logic  30,  28-48 

(1965). 

2. 

J.  Feldman, 

"Some  D e c i d a b i l i ty  Results 

on  Grammatical  Inference  and  Complexity," 

Stanford  A r t i f i c i al 

I n t e l l i g e n ce  P r o j e ct 

