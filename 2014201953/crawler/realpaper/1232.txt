PLANNER:  A  LANGUAGE  FOR  PROVING  THEOREMS  IN  ROBOTS 

C a rl 
P r o j e ct  MAC  -  Massachuse 

H e w i tt 
s 

I n s t i t u te  of  Technology 

Summary 

PLANNER 

is  a 

language 

f or  p r o v i ng 

theorems 

is  b u i lt  out  of  a  number  of  problem 

in  a  r o b o t. 

The 

t o g e t h er  w i th  a  h i e r a r c h i c al 
Statements  can  be  a s s e r t ed 
the 

t he  s t a te  of 

C o n c l u s i o ns  can  be  drawn 

f r om 
in  s t a t e.  Goals  can  be 

t h ey  a re 

l a t er  w i t h d r a wn  as 

and  m a n i p u l a t i ng  models 
language 
s o l v i ng  p r i m i t i v es 
c o n t r ol  s t r u c t u r e. 
and  perhaps 
w o r ld  changes. 
t h e se  v a r i o us  changes 
e s t a b l i s h ed  and  d i s m i s s ed  when 
s a t i s f i e d. 
s u b o r d i n a te 
s t r u c t u re 
e f f i c i e n t. 
language  makes 

in  o r d er 

the 

The  d e d u c t i ve  system  of  PLANNER 
to 

t he  h i e r a r c h i c al  c o n t r ol 
language 

to  make 

is 

The  use  of  a  g e n e r al  purpose  m a t c h i ng 
t he  d e d u c t i ve  system  more  p o w e r f u l. 

P r e f a ce 

PLANNER 

is  a 

language 

f or  p r o v i ng 

theorems 

to 

t he 

The 

t h at 

from 

form  of 

t h at  we 

t h at 
t he 

language 

in  a  r o b o t. 

is  supposed 

is  a  d u a l i ty 

A l t h o u gh 
l a n g u a g e, 

in 
from  pure  LISP 

i m p e r a t i ve  and  d e c l a r a t i ve 
t he  s t a t e m e nt 

to  c o r r e ct  any 

language 
PLANNER 

t he  rough  o u t l i n e. 

i n d i r e c t ly 
t he 

For  example  c o n s i d er 

t h at  PLANNER  is  a  programming 

it  is  a  p u r e ly 
lambda  c a l c u l us 

t h en  a t t e m p t i ng 
t he 

r e a d er  m i g ht  have 
The  b a s ic 

f u n c t i on 
t he  a c t u al  name  of 

i m p ly 
l i ke 
is  d i f f e r e nt 

t he 
In  such  a  c a ll 
f u n c t i on 

f u n c t i on  c a l ls  can  be  made 
recommendations  s p e c i f y i ng 

and  m a n i p u l a t i ng  models 
we  say 
we  do  n ot  mean 
p r o c e d u r al 
pure  L I S P. 
in 
t h at 
t h r o u gh 
to 
t he  d a ta  on  w h i ch 
t he 
w o r k. 
is  u s u a l ly  unknown.  Many  of 
c a l l ed 
in  PLANNER  a re  concerned  w i th 
t he  p r i m i t i v es 
m a n i p u l a t i ng  a  d a ta  base. 
language  w i ll 
be  e x p l a i n ed  by  g i v i ng  an  o v e r - s i m p l i f i ed  p i c(cid:173)
t u re  and 
m i s a p p r e h e n s i o ns 
g a t h e r ed 
i d ea  b e h i nd 
f i nd  between  c e r t a in 
s e n t e n c e s. 
( i m p l i es  a  b ). 
a  p e r f e c t ly  good  d e c l a r a t i ve  s t a t e m e n t. 
a l so  has  c e r t a in 
For  example 
p r o c e d u re  w h i ch  w i ll  n o te  whether  a 
a s s e r t ed  and 
if  so 
t h en  be  a s s e r t e d. 
we  s h o u ld  set  up  a  p r o c e d u re 
to  see 
is  our  g o al 
b  and 
to  deduce  a. 
about 
( i m p l i es  a  b ). 
q u a n t i f i e r s,  c o n j u n c t i o n s,  d i s j u n c t i o n s,  e t c. 
a l so  have  b o th  d e c l a r a t i ve  and 
Of  c o u r se 
were  a ll 
t h e re  was 
would  be  no  p o i n t. 
we  have  c o n s t r u c t ed  a 
b o th 
s t a t e m e n ts 
PLANNER  uses  a  p a t t e rn  d i r e c t ed 

if  what  we  have  d e s c r i b ed 
l a n g u a g e, 

t he  statement 
Statements  w i th  u n i v e r s al 

t h at  we  s h o u ld  set  up  a 
is  ever 

t h at 
t h at  w i ll  watch 
to 

to  be  e a s i ly  m a n i p u l a t e d. 

if 
if  so  whether 

t he  c o n t r a p o s i t i ve  of 

i m p e r a t i ve  uses 

i m p e r a t i ve  and  d e c l a r a t i ve  a s p e c ts  of 

S i m i l ar  o b s e r v a t i o ns  can  be  made 

to  c o n s i d er  whether  b  should 
F u r t h e r m o re 

i m p e r a t i ve  u s e s. 

t he  s t a t e m e nt 

f or  PLANNER. 

t h at  p e r m i ts 

i n f o r m a t i on 

f ar 
t h e re 

to  deduce 

it  stands 

t h us 
t h en 

language 

is  w i se 

it  says 

it  says 

From  t he  above  o b s e r v a t i o n s, 

to  make  a  subgoal 

it  ever 

t he 

t he 

t ry 

As 

to 

is 

It 

it 

language  a re  e x t e n d a b le 

Procedures  can  make  recommendations 

in 

f or 

The 

t h at 

t h ey 

found 

t r y i ng 

t h an  a 

f or 
f a ct 

in  w h i ch 

language. 

l o n g er  be 

t h e ir  own 

P r o v i s i on 

t he  s t a te  of 

t r ue 
l a t er 
from 

is  more  p o w e r f ul 

in  a  model  may  no 

language  p e r m i ts  us 

theorems  should  be  used 

i n t e r f e r e n ce 
in 

The 
is  s u b o r d i n a te 

t he 
t h at  s t a t e m e n ts 

from  o t h er  p r o c e d u r e s. 
t he 

from  an  a s s e r t i o n,  and 
t he  o r d er 

l o g i c al  d e d u c t i ve  system  used 
the  h i e r a r c h i c al 

t h ey  can  make  use  of  new  knowledge 
it  be  p r i m a r i ly  d e c l a r a t i ve  or 

t i me  and 
t he 
f a ct 
A s s e r t i o ns  and  goals  c r e a t ed 

t h at  were 
t r ue  at 
t h at  consequences  must  be 
t h at 
t he  model 

r e t r i e v al  system 
r e t r i e v al  system  based  d i r e c t ly  on  a s s o c i a t i on 
l i s t s. 
to  set  up 
procedures  w h i ch  w i ll  make  a s s e r t i o ns  and 
a u t o m a t i c a l ly  draw  c o n c l u s i o ns 
from  o t h er 
a s s e r t i o n s. 
as 
to  w h i ch 
to  draw  c o n c l u s i o ns 
t h ey  can  recommend 
t he 
theorems  should  be  a p p l i e d.  Goals  can  be 
c r e a t ed  and  a u t o m a t i c a l ly  d i s m i s s ed  when 
f r om 
are  s a t i s f i e d.  O b j e c ts  can  be 
schematic  or  p a r t i al  d e s c r i p t i o n s. 
P r o p e r ly 
f o r m u l a t ed  d e s c r i p t i o ns  have 
i m p e r a t i ve  uses 
is  made 
t he 
once 
some 
drawn 
has  changed. 
w i t h in  a  procedure  can  be  d y n a m i c a l ly  p r o t e c t ed 
a g a i n st 
Procedures  w r i t t en 
t h at 
in 
whether 
in  n a t u r e. 
by  PLANNER 
c o n t r ol  s t r u c t u re  of 
language. 
a  s o p h i s t i c a t ed  d e d u c t i ve  system 
g i ve  us  g r e a t er  power  over 
t he  c o m p u t a t i o n. 
d e d u c t i ve  system 
q u a n t i f i c a t i o n al  c a l c u l us  of  o r d er  omega.  Our 
i d e al  d e d u c t i ve  system  c o n t r a st 
c r i t e r ia 
w i th 
r e s o l u t i on 
based  systems. 
i n f e r e n c e, 
p a r s i m o n i o us 
r e s o l u t i on  systems  hope 
be  made  e f f i c i e nt 
a n a l y s is  of 
d e d u c t i ve  system.  We  have 
s o p h i s t i c a t ed  d e d u c t i ve  system 
an  e l a b o r a te  c o n t r ol  s t r u c t u re  so 
c o m p u t a t i o ns  can  be  c a r r i ed  out  w i t h o ut  b l o w i ng 
up.  Of  course 
be  used  when  we 
l u t i on  as 
r u le  of 
R.  B u r s t a ll  has  suggested 
implement  some  of 
s t r a t e g i es 
h i e r a r c h i c al  c o n t r ol  and 
of  new 
knowledge, 
c h a i ns  of 

t he  c o n t r ol  s t r u c t u re  can  s t i ll 
to  u s i ng  r e s o(cid:173)
I n d e e d, 
to 

H a v i ng  o n ly  a  s i n g le 
r e s o l u t i on  p r o v i d es  a  v e ry 

t ry 
t he  w e ll  known  r e s o l u t i on 

i m p e r a t i ve  as  w e ll  as  d e c l a r a t i ve 

t h r o u gh  a c u te  m a t h e m a t i c al 

i n f e r e n c e. 
t h at  we  m i g ht 

to  d e s i gn  a 
t o g e t h er  w i th 

l o g i c al  system.  Workers  who  b u i ld 

the  s i m p le  s t r u c t u re  of 

Because  of 
i ts  a b i l i ty 

r e s p e c ts 
t h an 

t h e ir  systems  can 

to  c a r ry  out  v e ry 

is  more  p o w e r f ul 

t he  d i r e c t i on  of 

l i m it  o u r s e l v es 

t h at  a re  used 

PLANNER  has 

in  PLANNER. 

in  PLANNER. 

i ts  extreme 
to  make  use 

In  s e v e r al 

i n f e r e n ce 

f e a s i b le 

t he  s o le 

t he 
t he 

in  o r d er 

l e n g t hy 

j u s t i fy 

r u le  of 

f or  an 

those 

t r i ed 

t h e ir 

l o ng 

t h at 

t h at 

t he 

to 

to 

to 

is 

it 

i m p e r a t i ve 

MATCHLESS 

MATCHLESS 

is  a  p a t t e rn  d i r e c t ed  programming 

i n t e r n al 

t r e a t ed  as  a  p a t t e rn 

l a t er  when  we  d i s c u ss 

is  a s s i g n?  w h i ch  matches 

i m p l e m e n t a t i on  of 

t he 

t h at 

i t s e l f. 

t he 
t he 

f u n c t i on 

in  MATCHLESS 

in  MATCHLESS 

t he 
is  c a l l ed 

in 
in 
i m p o r t a nt 

is 
The  r e a s on  why 

t h at  have  v a l u e s. 
t h at 

f i r st  argument  w h i ch 
i ts  second  a r g u m e n t. 

in 
is  used  b o th 
t o ol 
The  most 

language 
is  used 
PLANNER.  MATCHLESS 
w o r k i n gs  of  PLANNER  and  as  a 
d e d u c t i ve  system 
f u n c t i on 
i ts 
to 
assignment 
a s s i g n?  w i ll  be  e x p l a i n ed 
f u n c t i o ns 
o p e r a t or  $_ 
it 
f o l l o ws 
is 
v a r i o us 
t y p es 
v i a t i o ns  a r e; 
seg 
f l o at 
s - e x p r e s s i o n. 
a s s i g n ed 
ment. 
v a l u es  of  p a t t e rn  v a r i a b l es  a f t er  assignment 
s t a t e m e n ts  have  been  e x e c u t e d.  We  use 
c h a r a c t er 
{  and 

i n d i c a t es 
to  be  a s s i g n ed  a  v a l u e. 
f or  v a r i a b l es  and 

f l o a t i ng  p o i nt  number,  and  expr 

Below  we  g i ve  some  examples  of 

f or 
is  a l w a ys 
l e f t m o st  s e g(cid:173)

t he  s m a l l e st  p o s s i b le 

to  d e l i m it  segments. 

f i x ed  p o i nt  number, 

A  segment  v a r i a b le 

f or  p o i n t e r,  atom 

f u n c t i on  c a l l s. 

f or  segment, 

t h e ir  a b b r e(cid:173)

}  a re  used 

The  p r e f ix 

to  d e l i m it 

t he  v a r i a b le  w h i ch 

The 

t he 

t he 

p tr 

f or 

f or 

f ix 

- 

f or  a t o m, 

The  c h a r a c t e rs 

{ p r og 

( (a  p t r) 

(h  atom) 

(c  s e g )) 

($_a  k  $_h  $_c) 

( ( 1)  k  b  1  a ) }} 

{ a s s i g n? 
a  g e ts 
h  g e ts 
c  g e ts 

( 1) 

t he  v a l ue 
t he  v a l ue  b 
t he  v a l ue 

-1  a-

{ p r og 

( (c  seg) 

(h  atom) 

(a  p t r )) 

($_c  $_h  k  $_a) 

(a 

l b k q ) )) 

{ a s s i g n? 
c  g e ts 
h  g e ts 
a  g e ts 

-a  1-

t he  v a l ue 
t he  v a l ue  b 
t he  v a l ue  q 

{ p r o g ( ( f i r st  p t r) 

( m i d d le  seg) 

( l a st  p t r )) 

( $ _ f i r s t $ _ m i d d l e $ _ l a s t)  (1,2,3,4)}} 
t he  v a l ue  1 

{ a s s i g n? 
f i r st  g e ts 
m i d d le  g e ts 
l a st  g e ts 

t he  v a l ue 
t he  v a l ue  4 

-2  3-

{ p r og 

( (a  p t r) 

(b  p t r )) 

{ a s s i g n? 

is  o n ly  one  element 

($_^$_b)  (d)  }} 
( d ). 

in 

f a i ls  because 

t h e re 

{ p r og 

( (a  a t o m )) 

is  n ot  an  a t o m. 

{ a s s i g n?  $_a 

(1  2 ) }} 

f a i ls  because 

(1  2) 

An  e x p r e s s i on 
o p e r a t or  $$ 
match  an  o b j e ct  e q u al 
v a r i a b l e. 

t h at  c o n s i s ts  of 

t he  p r e f ix 

f o l l o w ed  by  a  v a r i a b le  w i ll  o n ly 

to 

t he  v a l ue  of 

t he 

{ p r og 

( (a  s e g )) 

{ a s s i g n? ($_a$$a) (1,2,3,1,2,3)}} 
a  g e ts 

t he  v a l ue 

- 12  3-

{ p r og 

( (a  seg) 

(b  s e g )) 

($_a  x  $$a  $ - b ) ( a b x d x a b x d q ) }} 

[ a s s i g n? 
a  g e ts 
b  g e ts 

t he  v a l ue 
t he  v a l ue 

-a  b  x  d-
- q-

t h at  c o n s i s ts  of 

An  e x p r e s s i on 
o p e r a t or  $? 
t he  v a l ue  of 
w i se 
use 
to 
v a r i a b le  does  n ot  have  a  v a l u e. 

t he  v a r i a b le 
t he  pseudo  atom  NOVALUE 

f o l l o w ed  by  a  v a r i a b le  w i ll  match 
t he  v a r i a b le 
it  has  o n e,  o t h e r(cid:173)

if 

is  a s s i g n ed  a  v a l u e.  We  s h a ll 

i n d i c a te 

t h at  a 

t he  p r e f ix 

{ p r og 

( (a  p t r )) 

{ a s s i g n?  $?a  3 }] 
a  g e ts 

t he  v a l ue  3 

{ p r og 

( ( (a  5)  p t r )) 
{ a s s i g n?  $?a  4 )) 
a 
i n i t i a l i z ed 
is 
p r o g. 
C o n s e q u e n t ly 
f a i l s. 

t he 
to  5  on  e n t r a n ce 
t he  assignment  s t a t e m e nt 

to 

{ a s s i g n? 

($_a,$?a) 

( 12  3  2  1 ) }) 

f a i ls 

is  a s s i g n ed  a  v a l u e,  a  can  o n ly 

is  e q u al 

t h at 
in  an  assignment  s t a t e m e nt 

t he  v a l ue  of 

to 

t he  v a l ue  of 

t he  second  argument 

{ p r og 

( (a  s e g )) 

because  once  a 
match  a  segment 
a. 
If  a  p a t t e rn 
cannot  match 
of 
s t a t e m e nt 
v a l ue 

t. 

t he  assignment  s t a t e m e nt 
t he  v a l ue 

r e t u r ns 

t he  assignment 

t h en 
( ),  o t h e r w i se 

t he 

Examples  of  p a t t e rn 

f u n c t i o ns  a re  d i sj 

f or 

f or  n e g a t i o n,  c o nj 

d i s j u n c t i o n,  neg 
c o n j u n c t i o n,  and  s t ar 
f or  K l e e ne  s t ar 
g e n e r al  r e g u l ar  e x p r e s s i o n s.  We  use 
c h a r a c t e rs  <  and  > 
to  d e l i m it  p a t t e rn 
e x p r e s s i o ns 
t h at  a re 
segments. 

to  be 

f or 

in 
t he 

i n t e r p r e t ed  as 

[ p r og 

( (a  p tr 

(b  p t r) 

(c  p t r )) 

( a < c o nj  $_a$  b>$_c) 

( a ^ > J ) }} 

{ a s s i g n? 
a  g e ts 
b  g e ts 
c  g e ts 

t he  v a l ue 
t he  v a l ue 
t he  v a l ue 

-1  z-
-1  2-
- 3-

{ p r og 

( (x  seg) 

(c  s e g )) 

{ a s s i g n?  ( $ _ x < d i s j ( 3)  ( 2 ) > $ _ c)  ( a , 1 , 2 , 3 , }} 
x  g e ts 
c  g e ts 

t he  v a l ue 
t he  v a l ue 

-a  1-
- 3-

{ p r og 

( (x  p t r )) 

{ a s s i g n? 
x  g e ts 

t he  v a l ue  a 

( < s t ar  a>  $_x) 

(a  a  a  a ) }] 

It 

to  e v a l u a te 

f u n c t i o ns  do  n ot  produce  v a l u e s. 

(2)  >  ( 2 )}  s i n ce  a  segment 
to  s t a nd 
f u n c t i o ns 

P a t t e rn 
does  n ot  make  any  sense 
( 3) 
{ a s s i g n?  < d i sj 
( 2)  >  is  never  a l l o w ed 
l i ke  < d sj 
( 3) 
l i b r a ry  of  p a t t e rn 
is  a 
a l o n e. 
There 
t he 
in 
For  example 
a l r e a dy  d e f i n ed 
Thus 
{ " s s a]  w i ll  o n ly  match  $$a. 
" 
a  p a l i n d r o me 
is  d e f i n ed 
t he  same  backwards  and 
(a 
( ),  and 
p a l i n d r o m e s.  More 
p a l i n d r o me  can  be  d e f i n ed  as  a  p a t t e rn 
of  no  a r g u m e n t s: 

to  be  a 
f o r w a r d s. 
( (a  b) 
f o r m a l ly 

Thus 
(a  b ))  a re 

in  MATCHLESS,  a 

l a n g u a g e. 

is  q u o t e. 

(b)  a ), 

r e a ds 

t h at 

f u n c t i on 

l i st 

(b) 

- 2 9 6-

(def  palindrome 

( ( )) 

(kappa 
{ d i sj 0 
{block 

((x  p t r )) 

($_x<palindrome>$$x)}])) 

it 

it 

it 

is 

is  a 

()  or 

is  used 

in  pattern  functions. 
is  a 

l i st  such 
l i st  which  begins  and 

l i ke  the  lambda  of  LISP  except 
The  above 

The  form  kappa  is 
that 
d e f i n i t i on  reads  "a  palindrome 
that 
ends  w i th  x  w i th  a  palindrome  in  between."  The 
p a t t e rn  function  block  causes  the  variable  x 
to  rebound  to  the  pseudo-atom  NOVALUE  every 
time  that  palindrome 
reverse  is  defined  to  be  such  that  {assign? 
{reverse  $$x}  $$y} 
if 
x  is  the  reverse  of  the  value  of  y. 
d e f i n i t i on  of  reverse 

The  function 

the  value  of 

is  c a l l e d. 

true  only 

The 

is 

is 

(def 

reverse 

(kappa 

( ( (x  p t r ) )) 

(fatomicJ$$x) 
(UJ 
{block 

{assign? 
( r e v e r se 

( ( f i r s t - o f -x  p t r ) ( r e s t - o f -x  seg)) 
rest-of-x)$$x} 

( $ _ f i r s t - o f - x$ 
( $ $ r e s t - o f - x ) > $ $ f i r s t - o f - x)  ])  })) 
is 
it 

if  whenever  y 

to  x,  otherwise 

The  above  d e f i n i t i on  says  that  an  expression  y 
is  an  atom  then 
the  reverse  of  x 
is  equal 
f i r s t - o f -x  by  the 
f i r st  member  of  x  and  r e s t - o f -x  be  the  rest  of 
x  and  the  pattern  (<reverse  ($$rest-of-x)  > 
$ $ f i r s t - o f - x)  must  match  y.  Essentially  a ll 
ideas 
productions,  general  regular  expressions, 
CONVERT,  and  LISP. 

the  pattern  functions  come  from  Post 

for 

let 

the 

PLANNER 

Now  that  we  have  described  MATCHLESS,  we  are 

imperative  uses. 

in  a  p o s i t i on  to  begin  a  detailed  description  of 
PLANNER.  Consider  a  statement 
that  w i ll  match 
the  pattern  (implies  $  a  $_b).  The  statement  has 
several 
x l: 
If  we  can  deduce  $$a,  then  we  can  deduce  $$b. 
In  PLANNER  the  statement  xl  would  be  expressed  as 
(antecedent(O)  $$a  {assert  $$b})  which  means 
that  $$a  Is  declared  to  be  the  antecedent  of  a 
in  such 
theorem  such  that 
a  way  as  to  allow  the  theorem  to  become  activated 
then  $$b  w i ll  be  asserted. 
x2: 

is  ever  asserted 

If  we  want  to  deduce  $$b, 
a  subgoal  to  f i r st  deduce  $$a. 

then  establish 

if  $$a 

The  following  three  forms  are  the  ones 

which  are  presently  defined 
s a t i s f y i ng  requests  made  in  the  body  of 
procedures: 

in  the 

language  for 

that 

$$consequent 

(consequent  $_declaration  $_consequent 
is 

$_expression)  declares 
the  consequent  of  the  theorem.  The  theorem  can 
be  used  to  t ry  to  establish  goals  that  match  the 
pattern  $$consequent.  Whether  or  not  the 
theorem  w i ll  actually  succeed 
the  goal  depends  on  $$expression.  However,  no 
theorem  can  be  activated  for  a  goal  which  is 
already  currently  activated 
only  way  that  a  theorem  that  begins  w i th  the 
atom  consequent  can  be  called  is  by  the  function 
goal. 

In  establishing 

that  goal. 

The 

for 

that  $$antecedent 

(antecedent  $_declaration  $  antecedent 
is 

$_expression)  declares 
the 
antecedent  of  the  theorem.  The  theorem  can  be 
used  to  t ry  to  deduce  consequences 
that  a  statement 
been  asserted.  The  only  way  that  a  theorem 
that  begins  with  the  atom  antecedent  can  be 
called 
f rom. 

is  by  the  functions  assert  and  conclude-

that  matches  $$antecedent  has 

from  the  fact 

(erasing  $_declaration  $_statement  $_expres-

sion)  can  be  used  to  t ry  to  deduce  consequences 
from  the  fact 
$$statement  has  been  erased.  The  only  way  that 
a  theorem  that  begins  with  the  atom  erasing  can 
be  called  is  by  the  function  erase. 

that  a  statement 

that  matches 

is  highly  recursive. 

in  PLANNER  are  l i s t ed 

It 

the 

the 

functions 

to  understand 

is  doing  on  a ll 

t r y i ng 
language 

the  d e f i n i t i on  of 

t ry  to  remember  every(cid:173)

Some  of 
together  with  b r i ef  explanations  of 

t h e ir 
below 
t h e ir  use  w i ll  be  given 
f u n c t i o n.  Examples  of 
immediately  a f t er 
the  p r i m i t(cid:173)
ives  below.  The  p r i m i t i v es  probably  cannot  be 
understood  without 
examples  since  the 
In  general  PLANNER  w i ll 
levels  unless 
thing  that 
t h is 
is  some  reason  to 
the 
information. 
language  special  measures  must  be  taken  to 
ensure 
t h e ir  correct 
bindings. 
the  language  is  to  put  pointers  on  the  stack 
back  to 
Value  c e l ls  do  not  provide  an  e f f i c i e nt  means 
of 
response  of  the  language  when  a  simple  f a i l u re 
occurs 
that 

forget  some  part  of 
In  the  Implementation  of 

Implementing  the  language.  The  default 

The  most  e f f i c i e nt  way  to  implement 

to  back  track  to 
f ix 

the  l a st  decision 
it  up. 

that  variables  receive 

it  made  and 

t ry 

to 

is 

the  place  where  the  correct  bindings  are. 

there 

(goal  $$a} 

In  PLANNER  the  statement  x2  would  be  expressed  as 
(consequent  ( ( ))  $$b  {thprog  () 
{assert-consequent}})  which  means  that  $$b  is 
declared  to  be  the  consequent  of  a  theorem  such 
that 
if  the  subgoal  $$a  can  be  established  using 
any  theorem  then  the  consequent  $$b  w i ll  be 
asserted.  We  obtain  two  more  PLANNER  statements 
analogous  to  the  above  by  considering  the 
contrapositive  of 
(implies  $$a  $$b)  which 
(implies  (not  $$b) 

(not  $$a)). 

is 

{{"thval}$_expression  $_bindlngs  $state} 
$$expression  with 

w i ll  evaluate  the  value  of 
bindings  which  are  the  v a l uj  of  $$bindings  and 
l o c al  state  which  Is  the  va'ue  of  $$state.  At 
any  given  time  PLANNER  expressions  are  being 
evaluated 
in  a  l o c al  s t a t e.  This  local  state 
determines  what  changes  have  been  made  to  the 
data  base 
have  been  made. 

i . e .,  what  erasures  and  assertions 

-297-

{ {"  s t a t e }}  returns  as 

l o c al  s t a t e. 

i ts  value  the  current 

{ {"  update}  $_state}  w i ll  update 
the  state  which  is 

to 

base  according 
of  $$state. 

the  data 
the  value 

{ {"  assert}  $_statement 

{recommendation}) 

where 

(def  recommendation 

(kappa  ( ( )) 

( d i sj 

0 
? 
(or  <star 
{recommendation}>) 
(and  <star  {recommendation}>) 
(subset  <star{recommendation}>) 
(sequence  <star 

that 

to  be 

in  t r y i ng 

the  f u n c t i on 

(recommendation}>)})) 
If 
the  statement  $$statement  has  already  been 
asserted  then  the  f u n c t i on  assert  acts  as  the 
n u ll  i n s t r u c t i o n.  Otherwise, 
assert  causes  the  statement  $$statement 
asserted  w i th  a  recommendation  as  to  how  to  t ry 
to  draw  some  conclusions  from  the  fact 
$$statement  has  been  asserted.  The  ()  recom(cid:173)
mendation  means  that  we  should  take  no  a c t i o n. 
The  recommendation  ?  excludes  no  theorem  from 
to  deduce  consequences 
consideration 
The  d i s j u n c t i on 
from  the  value  of  $$statement. 
of  a  l i st  of  recommendations  requires 
that  each 
in  t u rn  u n t il  one  works. 
recommendation  be  t r i ed 
The  conjunction  of  a 
requires 
they  appear  in  the  conjuction. 
recommendations,  PLANNER  w i ll  t ry  each  recom(cid:173)
mendation  in  turn  regardless  of  whether  any 
given  one  succeeds  or  not. 
of  recommendations 
t r ys  a ll 
l i st 
in  a ll  possible  orders. 
f a i ls  or 
mendation  of  an  assertion  statement 
if  a  lower  l e v el  f a i l u re  backs  up 
the  asser(cid:173)
to 
t i on  then  the  assertion  that  $$statement  holds 
is  withdrawn. 

The  subset  of  a  l i st 
the  s u b l i s ts  of 
the  recom(cid:173)

l i st  of  recommendations 

in  which 
In  a  sequence  of 

they  a ll  work 

in  the  order 

that 

the 

If 

{ {"  conclude-from}  $_statement 

{recommendation})  w i ll  cause  PLANNER  to 
draw  conclusions 
using  the  recommendation. 

from  the  statement  $$statement 

t ry  to 

{ {"  assert-consequent} 

{recommendation}) 

the  consequent 

in  which  the  function 

causes 
assert-consequent  appears  to  be  asserted.  The 
function  should  be  used  only  in  theorems  that 
begin  w i th  the  atom  consequent.  A f t er  the 
f u n c t i on  assert-consequent  has  been  evaluated, 
execution  w i ll  cease 
f u n c t i on  appears. 

in  the  theorem  in  which  the 

{ {"  permanent-assert}  $_statement 

{recommendation}) 
except 
if  a  f a i l u re  backs  up  to 
assert. 

that  $$statement  continues 
the  c a ll 

l i ke 

the 

is 

function  assert 

to  hold  even 
to  permanent-

{ {" 

temporary-assert} 

is 

{recommendation}) 
$$statement  w i ll  be  withdrawn 
works  out. 
temporary  r e s u lt 
solve  our  current  problem. 

$_statement 
l i ke  assert  except 

that 
if  everything 

In  other  words,  $$statement 

is  a 

that  w i ll  go  away  a f t er  we 

{ {"  erase}  $_statement  {recommendation}  ) 

that  matches  $$statement, 
then  the  recommendation  is 
the  function  erase  gen(cid:173)
If  a  simple  f a i l u re 

is  a  statment 
If 
there 
then  it 
is  erased  and 
followed.  Otherwise, 
erates  a  simple  f a i l u r e. 
then  the  s t a t e(cid:173)
backs  up  to  the  function  erase, 
ment 
is  restored 
that  was  o r i g i n a l ly  erased 
and  the  whole  process  repeats  w i th  another 
statement  that  has  been  proved.  The  function 
erase  is  a  p a r t i al 
the  function 
assert. 

inverse  of 

l e ft 

{ {"  proved?}  $_statement} 

t e s ts 

to  see 

if  a 

If 

to 

then  the  variables 

the  appropriate  values. 

the  whole  process 
that  has  been 

that  matches  $$statement  has  already 

If  there  is  such  a  statement, 
in  the  pattern  $$statement 
there 
then  a  simple  f a i l u re  is 
If  a  simple  f a i l u re  backs  up  to  the 
that  were 

statement 
been  asserted. 
then  the  variables 
are  bound 
Is  no  such  statement, 
generated. 
function  proved?, 
bound  to  the  elements  of  the  statement  that  was 
found  f i r st  are  unbound  and 
repeats  with  another  statement 
proved.  PLANNER  is  designed  so  that 
takes  to  determine  whether  a  statement 
matches  $$statement 
e s s e n t i a l ly 
evant  statements  that  have  already  been  asserted. 
When  an  s-expression  is  asserted  PLANNER  rememb(cid:173)
ers 
the  s-expression.  Two  expressions  are  s i m i l ar 
on  r e t r i e v al  only  to 
they  have 
the  extent  that 
the  same  atoms  in  the  same  p o s i t i o n. 
MATCHLESS  had  an  e f f i c i e nt  p a r a l l el  processing 
c a p a b i l i ty  then  the  r e t r i e v al  could  be  even 
faster  since  we  would  do  the  look-ups  on  atoms 
by  p o s i t i on  in  p a r a l l e l. 

in  the  data  base  or  not 
i r r e l(cid:173)

the  p o s i t i on  of  every  atom  that  occurs 

independent  of 

the  number  of 

the  time  it 

that 

in 

is 

is 

If 

{ {"  proven}$__pattern}  w i ll  r e t u rn  as  value 

the  number  of 
a  l i st  whose  f i r st  element 
in  the  l i st  and  such  that 
remaining  elements 
remaining  elements  of 
the  l i st  are  statements 
that  have  been  asserted  and  match  the  pattern 
$$pattern. 

is 

the 

{ {" 

for-proved}  $_declaration  $__pattern 

$__body)  where  body 
type  seg  w i ll  attempt 
to  excecute  $$body  once  f or  every  proved  s t a t e(cid:173)
ment 

that  matches  the  pattern  $pattern. 

is  of 

{ {"  proveable}  $_pattern  { g o a l-

is 

in  the  l i st  and  such  that 

i ts  value  a  l i st 
the  number  of  remaining 

recommendation}}  w i ll  return  as 
whose  f i r st  element 
elements 
elements  of 
that  match  the  pattern  $$pattern  and  can  be 
proved  using  the  recommendation.  Note  that 
there  are  an  i n f i n i te  number  of  proveable  s t a t e(cid:173)
ments  that  match  the  pattern  $$pattern  then  the 

the  remaining 
the  l i st  are  the  proveable  statements 

if 

-298-

f u n c t i on  proveable  w i ll  not  converge. 

{ {"  goal}  $_statement  (goal-recommendation}} 

where 

(def  goal-recommendation 

(kappa  ( ( )) 

{block 

((theoremlist  seg)) 

( d i sj 

( f i r st  $_theoremlist) 
(only  $_theoremlist)}})) 

A  goal-recommendation  of  ( f i r st  $_theoremlist) 
means  that  the  theorems  on  $$theoremlist  are  the 
f i r st  to  be  used  to  t ry  to  achieve  the  goal  which 
is  the  value  of  $$statement.  On  the  other  hand 
a  goal  recommendation  of  (only  $_theoremlist) 
means  that  the  theorems  on  $$theoremlist  in  the 
order  given  are  the  only  ones  to  be  used  to  t ry 
to  achieve  the  goal.  The  f i r st  thing  that  the 
function  goal  does  is  to  evaluate  {proved? 
$$statement}. 
f a i l u re  then  the  goal  recommendation  is  followed 
to  t ry  to  f i nd  a  theorem  that  can  establish 
$$statement. 

If  the  evaluation  produces  a 

{ {"  goals}  $_pattern}  returns  as  i ts  value 

a  l i st  of 

the  c u r r e n t ly  active  goals. 

{ {"  g e n f a i l })  causes  a  simple  f a i l u re  to  be 

reported  above. 

{ {"  g e n f a i l}  $_message)  causes  a  f a i l u re 

to  be  reported  above  with  the  message  the  value 
of  $$message. 

{ {" 

f a i l ?}  $__expr  $_failclauses}  where 
f a i l c l a u s es  is  of 
type  seg  evaluates  $$expr. 
If  the  evaluation  does  not  produce  a  f a i l u r e, 
then  the  value  of  $$expr  is 
the  value  of  the 
function  f a i l ?. 
If  the  message  of  the  f a i l u re 
matches  the  f i r st  element  of  a  clause  then  the 
rest  of  the  elements  of  the  clause  are  evaluated. 
Otherwise, 
upward. 

the  f a i l u re  continues  to  propagate 

{ {"  f a i l t o}  $_tag}  causes 

f a i l u re  to  the 

tag  $$tag  which  must  previously  have  been  passed 
over. 

{{M  b l k f a i l }}  causes  the  current  block  to 

{ {"  t h f a i l }} 

causes  the  current 

theorem  to 

f a i l. 

f a i l. 

{ {"  end}}  causes  the  current  theorem  to 

cease  execution. 

{ {"  goal-end}} 

causes  execution  to  cease 

on  the  current  theorem  and  the  current  goal  to  be 
dismissed  without  being  asserted. 

{ {" 

f i n a l i z e - f r o m}  $_tag}  causes  a ll  actions 
that  have  been  taken  since  the  l a st  time  that  the 
tag  $$tag  was  passed  over  to  be  f i n a l i z e d. 
F i n a l i ze  statements  are  mainly  used  to  save 
storage.  The  next  statement  to  be  executed  is 

-299-

the  one  immediately  a f t er  the  c a ll 
from. 

to  f i n a l i z e-

{ {"  t h f i n a l i z e }}  causes  a ll  actions 

that 
have  been  taken  in  the  current  theorem  to  be 
f i n a l i z e d. 

{ {"  b l k f i n a l i z e }}  causes  a ll  actions 

have  been  taken  in  the  current  block  to  be 
f i n a l i z e d. 

that 

{ {"  defth}  $_theorem-name  $__theorem} 

defines  $$theorem-name  to  be  the  name  of  the 
theorem  $$theorem. 

{ {"  thcond}  $__clauselist  }  where  c l a u s e l i st 

if  of  type  seg  is 
except 
f i r st  element  of  a  clause  l i ke  a  ( ). 

l i ke  the  LISP  function  cond 
in  the 

treats  a  simple  f a i l u re 

that 

it 

{ {" 

thprog}  $ _ v a r i a b l e l i st  $__progbody} 

where  progbody  is  of  type  seg  is  l i ke  the  LISP 
function  prog  except  that 
mechanism  of  f a i l u r e. 

it  can  handle  the 

{ {"  thand}  $__conjuncts}  where  conjucts 

of  type  seg  is  l i ke  the  LISP  function  and. 

is 

{ {" 

thor}  $_disjuncts}  where  disjuncts 

of  type  seg  is  l i ke  the  LISP  function  o r. 

is 

{ {"  thrplaca}  $_a  $_b} 

is  l i ke  the  LISP 
function  rplaca  except  that  the  old  value  of 
$$a  is  remembered  so  that 
it  can  be  restored 
In  case  of 

f a i l u r e. 

Suppose  that  we  know  that  (subset  a  b ), 

(subset  a  d ),  (subset  b  c ),  and  ( f o r - a ll  (x  y  z) 
(implies  (and  (subset  x  y) 
(subset 
x  z ) ))  are  t r u e.  How  can  we  get  PLANNER  to 
prove  that  (subset  a  c)  holds?  We  would  give 
the  system  the  following  theorems. 

(subset  y  z)) 

(subset  a  b) 
(subset  a  d) 
(subset  b  c) 
(defth  backward 
(consequent 
(subset  $?x  $?z) 
{thprog 
((y  p t r )) 

( ( (x  p t r) 

(z  p t r ) )) 

{goal  (subset  $?x  $?y) 
{goal  (subset  $$y  $?z) 
{aasert-consequent}})) 

( f i r st  backward)} 
(only  backward)} 

looks  for  a  theorem  that 

Now  we  ask  PLANNER  to  evaluate  {goal  (subset  a  c)} 
it  can  activate 
then  it 
to  work  on  the  goal. 
It  finds  backward  and  binds 
x  to  a  and  z  to  c.  Then  it  makes  (subset  a  $?y) 
a  subgoal  with  the  recommendation  that  backward 
should  be  used  f i r st  to  t ry  to  achieve  the  sub-
g o a l.  The  system  notices  that  y  might  be  d,  so 
it  binds  y  to  d.  Next  (subset  d  c) 
subgoal  w i th  the  recommendation  that  only  back(cid:173)
ward  be  used  to  t ry  to  achieve  i t.  Thus  back(cid:173)
ward  is  called  r e c u r s i v e l y,  x  is  bound  to  d,  and 
z  is  bound  to  c.  The  subgoal  (subset  d  $?y) 
Is 
established  causing  backward  to  again  be  called 

is  made  a 

it 

is 

So 

the  new  subgoal 

in  trouble  because 

is  already  working. 

it  was  a  mistake  to 
in  the  f i r st  place. 

is  the  same  as  a  subgoal  on 
it  decides 

r e c u r s i v e ly  w i th  x  bound  to  d  and  z  determined 
to  be  the  same  as  what  the  old  value  of  y  ever 
turns  out  to  be.  But  now  the  system  finds  that 
it 
(subset  d  $?y) 
which 
that 
d  c) 
b  instead  of  d.  Now  the  system  sets  up  the 
subgoal  (subset  b  c)  which  is  established 
immediately.  We  use  the  above  example  only 
to  show  how  the  rules  of  the  language  work 
in  a  t r i v i al  case. 
interested 
about  the  l a t t i ce  of  sets, 
construct  a  f i n i te  l a t t i ce  as  a  model  and 
use 

t ry  to  prove  (subset 
Thus  y  is  bound  to 

it 
Suppose  we  give  PLANNER  the  f o l l o w i ng 

in  f i n d i ng  the  proof. 

If  we  were  seriously 

in  proving  theorems 

then  we  would 

to  guide  us 

in  PLANNER 

in  a d d i t i on  to  backward: 

theorems 
(subset  d  b) 
(subset  a  b) 
(defth 
(antecedent 
( ( (y  Ptr) 
subset  $_y  $_z) 
thprog 
((x  p t r )) 

forward 

(z  p t r ) )) 

{goal  (subset  $?x  $$y)} 
(subset  $$x  $$z) 
{assert 

(or  forward  ? ) } ) )) 

to  evaluate  {assert 
look  around 

Now  if  PLANNER  is  asked 
(subset  b e)  ?}, 
it  w i ll 
theorem  which  w i ll  enable 
quences  of  (subset  b  c ). 
y  to  b  and  z  to  c  in  forward,  and  then  generate 
the  subgoal  (subset  $?x  b ).  The  subgoal  (subset 
a  b  ) 
(subset  a  c)  as  a  fact  and  are  unable  to  deduce 
any  consequences  from  (subset  a  c ). 

is  e a s i ly  established.  Thus  we  assert 

it 
The  system  w i ll  bind 

to  deduce  conse(cid:173)

for  a 

Theorems  in  PLANNER  can  be  proved  in  much 

the  same  way  used  for  ordinary  theorems. 
For  example  suppose  that  we  has  the  f o l l o w i ng 
two  theorems: 
(defth 
( ( (a  p t r) 

th4  (consequent 

(c  p t r ) )) 
subset  $?a  $?c) 
thprog  () 
{thprog 

( ( (x 

{ a r b i t r a r y })  p t r )) 

{hypothetical  (element  $$x  $?a) 

(element  $$x  $?c)}} 

{assert-consequent  ? } } )) 

On  entrance  to  the  inner  thprog  the  v a r i a b le  x 
w i ll  be  bound  to  a  f r e s h ly  created  symbol.  The 
function  hypothetical  w i ll  v e r i fy 
(element 
$$x  $?c)  can  be  proved  from  (element  $$x  $?a). 
The  above  theorem  is  the  constructive  analogue 
of  ( f o r - a ll  (a  c) 
(implies 
(element  x  a) 
(defth  th3 

(implies  ( f o r - a ll  (x) 

(subset  a  c ) ) ). 

(element  x  c ) )) 

(consequent 

(s  p t r ) )) 

( ( (x  p t r) 

that 

element  $?x  $?s) 
thprog 
( (r  p t r )) 

fgoal  (element  $?x  $ ? r j} 
{goal  (subset  $?r  $?s)J 
{assert-consequent  ? } } )) 

The  above  theorem  is  the  constructive  analogue 
for 
( f o r - a ll  (x  s) 
(and  (element  x  r) 
From  the  above  two  theorems  we  can  now  prove  the 

{implies  ( t h e r e - e x i st 
(subset  r  s ) )) 

(element  x  s ) ) ). 

( r) 

f o l l o w i ng  theorem: 
(consequent 

( ( (a  p t r) 

subset  $?a  $?c) 
thprog 
((b  p t r )) 

(c  p t r ) )) 

goal  (subset  $?a  $?b)) 
goal  (subset  $$b  $?c)J 
{assert-consequent  ?}}) 

The  above  theorem  is  the  constructive  analogue 
(implies  (and  (subset  a  b) 
f or  ( f o r - a ll  (a  b  c) 
(subset  b e )) 
(subset  a  c ) ).  One  way  in  which 
the  theorem  can  be  established  is  by  showing 
that 
w i ll  not  r e s u lt 
{thprog 

the  evaluation  of  the 

f o l l o w i ng  expression 

f a i l u r e: 

in  a 

( ( (a 
((b 
((c 

{ a r b i t r a r y })  p t r) 
{ a r b i t r a r y ])  p t r) 
{ a r b i t r a r y })  p t r) 

assert  (subset  $$a  $$b)} 
assert  (subset  $$b  $$c)} 
{goal  (subset  $$a  $$c)}J 

is  sometimes 

for  PLANNER  to  regard 

The  above  example  shows  how  it 
convenient 
the  statement 
of  a  theorem  simply  as  an  abbreviation  for  the 
proof  of  the  theorem.  We  would  l i ke  to  be  able 
to  prove  PLANNER  theorems  w i th  loops  in  them. 
In  order  to  do 
the 
theorem. 

is  necessary  to  know 
i n t e r n al  structure  of 

intentions  of 

it 
the 

t h is 

the 

-300-

Conclusion 

Acknowledgements 

The  most  natural  way  to  do  a  proof  by 

the  point  the 

lengthy  but 

in  robot 

There  are 

is  to 

there 

the 

lapse  into 

the  h e u r i s t i cs 

It  w i ll  sometimes 

for  a  problem  are 

In  any  p a r t i c u l ar  case, 

is  a  kind  of  hybrid  between  the  c l a s s i c al 

The  semantical  d e f i n i t i on  of 
logic  complicated  by  the 

c o n t r a d i c t i o n.  Another  type  of  problem  that 
PLANNER  w i ll  not  solve  very  n a t u r a l ly 
is  some 
nonconstructively  show  that 
object  x  such  that  (p  x) 
is  t r u e.  We  shall 
c a ll  the  l o g i s t ic  system  based  purely  on  the 
p r i m i t i v es  of  PLANNER  "robot 
l o g i c ".  Robot 
logic 
logics  such  as  the  q u a n t i f i c a t i o n al  calculus 
and  i n t u i t i o n i s m,  and  the  recursive  functions 
as  represented  by  the  lambda  calculus  and  Post 
productions. 
t r u th 
existence  of  the  p r i m i t i ve  erase. 
i n t e r e s t i ng  p a r a l l e ls  between  theorem  proving 
and  algebraic  manipulation.  The  two  f i e l ds 
face  similar  problems  on  the  issues  of 
s i m p l i f i c a t i o n,  equivalence  of  expressions, 
intermediate  expression  bulge,  and  man-machine 
i n t e r a c t i o n. 
theorems  need  not  allow  PLANNER  to 
i ts  default  conditions. 
happen  that 
very  good  and  that  the  proof  proceeds  smoothly 
u n t il  almost  the  very  end.  At 
program  gets  stuck  and 
conditions  to 
On  the  other  hand  the  program  might  grope  for  a 
while  t r y i ng  to  get  started  and  then  latch 
onto  a  theorem  that  knows  how  to  polish  o ff  the 
problem  in  a 
foolproof  computation. 
PLANNER  is  designed  for  use  where  one  has  great 
number  of 
(theorems) 
that  might  be  of  use  in  solving  some  problem 
along  w i th  a  general  plan  for  the  solution  of 
the  problem.  The  language  helps  to  select 
procedures  to  r e f i ne  the  plan  and  to  sequence 
through  these  procedures  in  a 
f l e x i b le  way  in 
case  everything  doesnft  go  exactly  according  to 
plan.  The  fact  that  PLANNER  is  phrased  in  the 
form  of  a 
systematically  about 
problem  solving.  We  do  not  believe  that 
computers  w i ll  be  able  to  prove  deep  mathe(cid:173)
matical  theorems  without 
h i e r a r c h i c al  control  structure.  Nor  do  we 
believe 
that  computers  can  solve  d i f f i c u lt 
problems  where  t h e ir  domain  dependent  knowledge 
is 
of  connections  between  goals  and  methods. 

language  forces  us  to  think  more 
the  p r i m i t i v es  needed 

t ry  to  push  through  the  proof. 

i n t e r r e l a t ed  procedures 

f i n i t e - s t a te  difference 

lapses  into  default 

l i m i t ed 

to 

tables 

for 

the  use  of  a 

The  preceeding  is  a  report  on  some  of  the 

is  permitted 

f u ll  or 
for  any  purpose  of  the 

work  that  I  have  done  as  a  graduate  student 
at  Project  MAC.  Reproduction  in 
in 
part 
United  States  government.  We  would  l i ke  to 
thank  the  various  system  "hackers" 
that  have 
made  t h is  work  possible:  D.  East lake,  R. 
Greenblatt,  J.  Holloway,  T.  Knight,  G.  M i t c h e l l, 
S.  Nelson,  and  J.  White.  We  had  several 
useful  discussions  w i th  H.  V.  Mcintosh  and  A. 
Guzman  on  the  subject  of  pattern  matching. 
S.  Papert  and  T.  Winograd  made  suggestions  for 
improving  the  presentation  of 
t h is  paper. 

the  material 

in 

Bibliography 

I.  memo  137,  July  1967. 

1  Black,  F.  A  Deductive  Question  Answering 
System,  doctoral  d i s s e r t a t i o n,  Harvard. 
2  Green,  C.  C.  and  Raphael,  B.  The  Use  of 
Theorem-proving  Techniques 
in  Question-answering 
Systems.  Proceedings  of  23rd  National  Conf.  ACM. 
3  Guzman,  A.  and  Mcintosh,  H.  V.,  Convert, 
Communications  of  ACM,  Aug.  1966. 
4  Hewitt,  C. ,  PLANNER:  A  Language  for*  Proving 
Theorems,  A. 
5  McCarthy,  J .;  Abrahams,  P.  W.;  Edwards  D.  J .; 
Hart,  T.  P.;  and  Levin,  Michael  I. 
Programmers  Manual. 
6  McCarthy,  J.  and  Hayes,  P.,  Some  Philosophical 
Problems 
I n t e l l i g e n c e.  Stanford  A. 
7  Newell,  A.,  Shaw,  J.  C.,  and  Simon,  H.  A., 
1959.  Report  on  a  General  Problem-solving  Program, 
Proceedings  of 
on  Information  Processing,  Paris:  UNESCO  House. 
8  Slagle,  J.  Experiments  w i th  a  Deductive  Ques(cid:173)
tion-answering  Program,  Communications  of  ACM 
December  1965. 

from  the  Standpoint  of  A r t i f i c i al 

the  I n t e r n a t i o n al  Conference 

I.  Memo  73. 

Lisp  1.5 

- 3 0 1-

