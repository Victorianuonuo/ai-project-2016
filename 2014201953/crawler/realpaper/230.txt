The Rules of Constraint Modelling

Alan M. Frisch and Chris Jefferson and Bernadette Mart´ınez Hern´andez
Artiﬁcial Intelligence Group, Dept. of Computer Science, Univ. of York, UK

ffrisch,caj,bernag@cs.york.ac.uk

Ian Miguel

School of Computer Science, Univ. of St Andrews, UK

ianm@dcs.st-and.ac.uk

Abstract

Many and diverse combinatorial problems have
been solved successfully using ﬁnite-domain con-
straint programming. However, to apply constraint
programming to a particular domain, the problem
must ﬁrst be modelled as a constraint satisfaction
or optimisation problem. Since constraints provide
a rich language, typically many alternative models
exist. Formulating a good model therefore requires
a great deal of expertise. This paper describes
CONJURE, a system that reﬁnes a speciﬁcation of a
problem in the abstract constraint speciﬁcation lan-
guage ESSENCE into a set of alternative constraint
models. Reﬁnement is compositional: alternative
constraint models are generated by composing re-
ﬁnements of the components of the speciﬁcation.
Experimental results demonstrate that CONJURE is
able to generate a variety of models for practical
problems from their ESSENCE speciﬁcations.

1 Introduction
To employ ﬁnite-domain constraint programming technology
to solve a problem, the problem ﬁrst must be characterised,
or modelled, by a set of constraints on decision variables that
solutions must satisfy. Modelling can be difﬁcult and requires
expertise, thus limiting widespread use of constraint technol-
ogy. The vast majority of research on constraint modelling
presents alternative models to a particular problem and eval-
uates these alternatives through analysis and/or experiment.
The process by which the alternative models are generated is
rarely, if ever, discussed. Each constraint programmer must
learn the art of modelling by forming generalisations from
these studies.

We show that a set of rules can formalise the generation of
alternative models. Doing this requires a language in which to
express the abstract problem structure of which models are a
function. If all modelling choices are to be open to the rules,
the language must have a level of abstraction above that at
which modelling decisions are made. We have designed such
a language and call it ESSENCE.

The rules are embedded in the CONJURE system, which,
given an ESSENCE speciﬁcation, generates models of the type

supported by existing constraint solvers. Hence, we refer to
our rules as reﬁnement rules. Our current focus is on gener-
ating a set of correct models that includes those that a human
expert would generate. Future work will focus on generating
only good models.

2 Challenges and Contributions
A central task, arguably the central task, of modelling most
combinatorial problems is choosing a representation of com-
plex decision variables. Current ﬁnite-domain constraint
solvers provide decision variables whose domains contain
atomic elements, which we call atomic variables.1 Yet, com-
binatorial problems often require ﬁnding a more complex
combinatorial structure. For example, the Social Golfers
Problem (SGP, see [9] problem 10) requires partitioning a set
G of golfers in each week of play. Thus, the goal is to ﬁnd
a multiset of partitions of G, i.e. a multiset of sets of sets
of G. Modelling the SGP requires deciding how to represent
this complex decision variable as a constrained collection of
atomic variables.

In concert with choosing a representation of complex de-
cision variables is the task of representing the constraints
of the problem.
In its natural form, a combinatorial prob-
lem imposes constraints on the combinatorial structure that is
sought. These constraints must be “translated” so that they
are imposed on the representation of the decision variables.

This paper shows how these two central tasks of modelling
can be formalised and automated, and in doing so reports two
principal contributions. First, we have designed a language,
called ESSENCE, that enables combinatorial problems to be
stated at a high level of abstraction. This level of abstrac-
tion is a consequence of three features: (1) The language sup-
ports a wide range of types (including sets, multisets, rela-
tions, functions, partitions) and decision variables can be of
these types. (2) All types can be nested to arbitrary depth; for
example, a decision variable can be of type set, set of sets,
set of set of sets, and so forth. (3) Constraints can contain
quantiﬁers that range over decision variables. For example, if
a decision variable X is of type set of sets, a constraint can

1Some ﬁnite-domain constraint solvers support variables whose
domain elements are ﬁnite sets of atomic elements. Though all as-
pects of our work have considered this, for the sake of simplicity this
paper pretends such variables do not exist.

be of the form 8x 2 X:(cid:30). The ESSENCE language is out-
lined in Sec. 3, though only in enough detail to enable the
presentation of our second principal contribution.

Our second major contribution is the formulation and au-
tomation of a set of rules that can reﬁne constraints on com-
plex variables in an ESSENCE speciﬁcation into constraints
on atomic variables, which is the level of abstraction pro-
vided by existing constraint languages and toolkits. Our for-
mal rules are presented in Sec. 4.

An attempt to formulate such a set of reﬁnement rules con-
fronts two primary difﬁculties and many secondary ones. Be-
fore proceeding it is worth considering the primary ones.

The ﬁrst difﬁculty arises because expressions, particularly
decision variables of non-atomic type, can usually, if not al-
ways, be reﬁned in multiple ways. Furthermore, the reﬁne-
ment of an operator depends on how its operands are reﬁned.
For example, in reﬁning the constraint S1 = S2, where S1
and S2 are atomic set variables, the treatment of equality is
different for every combination of ways that S1 and S2 can
be reﬁned. Indeed, it is possible that an operator is inapplica-
ble to certain reﬁnements of its operands.

The second major difﬁculty arises from arbitrary nesting
of types. Reﬁning an operator that is applied to expressions
whose types are nested provides the biggest challenge. Con-
sider reﬁning the constraint A = B, where A and B are de-
cision variables of some type (cid:28) that is nested arbitrarily deep.
The generated constraint must involve all components of both
A and B. Since there is no bound on the nesting of (cid:28), this
complex constraint would have to be generated through re-
cursive rule applications, none of which can look arbitrarily
deep into the nesting of (cid:28). Furthermore, we wish to produce
reﬁnements in which A and B do not have the same kind of
representation. An especially tricky case is when a quanti-
ﬁer ranges over a decision variable of a nested type, such as
8x (cid:18) A (cid:30), where A is as above.

Modelling in constraints involves more than just represent-
ing decision variables and problem constraints. Constraint
models often contain many symmetries, often enormous
numbers of them, which result in redundancies in the search
space. Expert modellers are able to identify such symmetries
and break them, either by introducing symmetry-breaking
constraints or using a symmetry-aware search method. It has
been argued that detecting symmetries in a model is as hard
as graph isomorphism. We maintain that symmetries enter a
model from two sources: either a symmetry is inherent to the
combinatorial problem or it is introduced by the modelling
process. An automated modelling system ought to identify
the symmetry that it introduces into a model. Sec. 5 explains
how this can be integrated into our architecture for model
generation.

Another technique used by expert modellers is to repre-
sent a complex decision variable with multiple representa-
tions simultaneously and impose channelling constraints to
keep the representations consistent with each other [4; 8;
11]. This sometimes yields more propagation, and therefore
reduced search, than a single representation. As will be seen,
the rules of CONJURE generate models with multiple repre-
sentations. Sec. 6 explains how our reﬁnement rules can gen-
erate the information that is needed to automatically generate

Given n, put n integer ticks on a ruler of size m such that all inter-tick distances
are unique. Minimise m.

given
where
letting
find
minimising
such that

n: int
n (cid:21) 0
bound be 2n
T icks: set (size n) of 0::bound
max(T icks)
8fi; jg(cid:18)T icks:8fk; lg(cid:18)T icks:

fi; jg 6= fk; lg ! ji (cid:0) jj 6= jk (cid:0) lj

Figure 1: ESSENCE speciﬁcation of the Golomb Ruler prob-
lem.

the appropriate channelling constraints.

We conjecture that the good models of a problem can
be generated automatically by formulating the problem in
ESSENCE and then reﬁning the speciﬁcation using rules of
the kind presented in this paper. We have implemented a
program, called CONJURE, that currently reﬁnes a subset of
ESSENCE, called mini-ESSENCE. This gives us a platform
with which we have experimentally tested our conjecture, as
reported in in Sec. 7.

the abstract

It

section brieﬂy introduces

3 An Introduction to ESSENCE
This
speciﬁca-
tion language ESSENCE.
is an evolving and grow-
ing language; version 1.0 is used within this paper.
A full speciﬁcation of
the language can be found at
www.cs.york.ac.uk/aig/constraints/AutoModel/.
Let us begin by considering the speciﬁcation of the
Golomb Ruler Problem (GRP, problem 6 at www.csplib.org),
shown in Fig. 1).
A speciﬁcation is a list of state-
ments, of which there are seven kinds, signalled by the
keywords given, where, letting, find, maximising,
minimising and such that. Statements are composed
into speciﬁcations according to the regular expression

(given j letting j where)(cid:3) find+
[minimising j maximising] (such that)(cid:3)

Identiﬁers in CONJURE come in four categories: constant,
parameter, quantiﬁed variable, and decision variable. “Let-
ting” statements declare constant symbols and give their val-
ues. “Given” statements declare the problem’s parameters;
the values of the parameters are provided to specify the in-
stance of the problem class. Parameter values are not part of
the problem speciﬁcation; as in other modelling languages,
they are provided elsewhere. “Where” statements impose
restrictions on the parameter values; only parameter values
meeting the restrictions specify a problem instance. “Find”
statements declare decision variables. A “minimising” or
“maximising” statement gives the objective function, if any.
Finally, “such that” statements give the problem’s constraints.
The GRP speciﬁcation begins by declaring n to be a pa-
rameter, restricting it to be non-negative and declaring bound
to be a constant. Since n is used in the declaration of bound,
the declaration of bound must come after the declaration of
n. Every symbol must be deﬁned before it is used. This re-
striction prevents cyclical deﬁnitions and means that decision
variables cannot be used in the deﬁnitions of constants and
parameters.

The speciﬁcation language is strongly typed and every ex-
pression and subexpression has a type. The type of the deci-
sion variable T icks indicates that the goal of the problem is to
ﬁnd a set containing n elements, each of which is an integer
in the range 0 to bound. The types supported by ESSENCE
include the atomic types int (integer), bool (Boolean) and
l..u (an integer range type), where l and u are integer expres-
sions. ESSENCE also provides enumerated types and a new
and very useful atomic type: type (size (cid:11)), a type of (cid:11)
unnamed elements.

ESSENCE is the ﬁrst constraint language to support fully-
compositional type constructors. So, for example, a decision
variable may be of type integer, set of integer, set of set of
integer, and so forth. If (cid:28) is a type, (cid:11) is an integer expres-
sion, and I1; : : : ; In are expressions of type range then the
following are types that appear in this paper:

set (size (cid:11)) of (cid:28) , set (maxsize (cid:11)) of (cid:28)
mset (size (cid:11)) of (cid:28) , mset(maxsize (cid:11)) of (cid:28) two kinds of multiset
matrix [indexed by I1; : : : ; In] of (cid:28)

two kinds of set

matrix

Also among the types of ESSENCE are relations between any
two types, partial and total functions from any type to any
type, partitions of a set of any type and permutations of any
type.

Constraints in this speciﬁcation language are built from
the parameters, constants and decision variables using opera-
tors commonly found in mathematics and in other constraint
speciﬁcation languages. The language also includes variable
binders such as 8x, 9x and Px, where x can range over any
speciﬁed ﬁnite type (e.g., integer range but not integer). The
constraint in the GRP can be paraphrased as “For any un-
ordered pair fi; jg of ticks and any unordered pair fk; lg of
ticks, if the two pairs are different then the distance between
i and j is not the same as the distance between k and l.” To
clarify the notation, the expression fi; jg (cid:18) T icks means that
two distinct elements are drawn from T icks and, without loss
of generality, one is called i and the other is called j.

Now consider the speciﬁcation of the Sonet problem shown
in Fig. 2. Notice that Nodes is declared to be a range. A subtle
point is that the third line of the speciﬁcation is declaring two
parameters. When the demand parameter is instantiated to a
particular set of sets, the size of the outer set will be known.
Hence, the value of m is given indirectly. This declaration
also requires the inner sets to have cardinality two. The goal
is to ﬁnd a multiset (representing the rings), each element of
which is a set of Nodes (representing the nodes on that ring).
The objective is to minimise the sum of the number of nodes
installed on each ring. The constraint ensures that any pair
of nodes that must communicate are installed on a common
ring.

The Target Language: ESSENCE0
ESSENCE speciﬁcations are reﬁned into a target language
called ESSENCE0, which is a subset of ESSENCE with a level
of abstraction similar to that of existing constraint languages,
OPL [19] being the closest. The only types ESSENCE0 has
are integers, integer ranges, Booleans and matrices; it does
not have enumerated types or types of unnamed elements.
Binders, such as quantiﬁers and summations, range only over
integer ranges. From this generic constraint language, it is

A Sonet communication network comprises a number of rings, each joining a num-
ber of nodes. A node is installed on a ring using an ADM and there is a capacity
bound on the number of nodes that can be installed on a ring. Each node can be
installed on more than one ring. Communication can be routed between a pair of
nodes only if both are installed on a common ring. Given the capacity bound and
a speciﬁcation of which pairs of nodes must communicate, allocate a set of nodes
to each ring so that the given communication demands are met. The objective is to
minimise the number of ADMs used. (This is a common simpliﬁcation of the full
Sonet problem, as described in [8])

nrings:int, nnodes:int, capacity:int
nrings(cid:21) 1, nnodes(cid:21) 1, capacity(cid:21) 1
Nodes be 1..nnodes
demand:set (size m) of set (size 2) of Nodes
rings: mset (size nrings) of set (maxsize capacity) of Nodes

given
where
letting
given
find
minimising Pr2rings
such that 8pair 2 demand: 9r 2 rings : pair (cid:18) r

jrj

Figure 2: ESSENCE speciﬁcation of the Sonet problem.

a short step to an established constraint language, such as
OPL, Solver, or Eclipse. To perform this step, we are de-
veloping a suite of back-end translators. In future, we also
intend to translate to more restricted languages, such as SAT
and Pseudo-Boolean formulations.

4 The Architecture of CONJURE
This section discusses the reﬁnement rules CONJURE uses to
reﬁne an ESSENCE expression into a set of ESSENCE0 ex-
pressions. For concision we give only a small subset of all
the reﬁnement rules2; the remainder follow a similar pattern.

Reﬁning a Simple ESSENCE Speciﬁcation
Reﬁnement of an ESSENCE speciﬁcation begins by reﬁning
each constraint and the objective function in turn. Let us be-
gin by considering the single-constraint MicroSonet1 speci-
ﬁcation (Fig. 3), where the goal is to ﬁll two rings with the
same nodes.

A key consideration in reﬁning MicroSonet1 is the repre-
sentation of each ring, each of which is a ﬁxed-size set. This
paper uses two representations of ﬁxed-size sets. The explicit
representation is a one-dimensional matrix of Nodes indexed
by 1..capacity. Each element of the matrix corresponds to an
element of the set. To represent the set properly, the elements
of the matrix are constrained to take distinct values. The oc-
currence representation is a one-dimensional Boolean matrix
indexed by Nodes, where a true entry indicates that the corre-
sponding node is in the set. To represent the set properly, the
number of true entries must be equal to capacity (for count-
ing we treat true/false as 1/0). Fig. 3 gives ESSENCE0 mod-
els using both representations. Note that some symbols of
ESSENCE, such as “8” and “(cid:6)”, can also be written textually,
such as “forall” and “sum”. In writing ESSENCE0 we use the
textual version.

The reﬁnement operator, (cid:26), is a function that maps ev-
ery ESSENCE expression to a set of ESSENCE0 expressions.
As explained later, each of these ESSENCE0 expressions is
tagged with further information necessary to construct the

2See http://www.cs.york.ac.uk/aig/constraints/AutoModel/ for

the complete set.

given
where
letting
find

such that

nnodes : int, capacity : int
nnodes (cid:21) 1, capacity (cid:21) 1
Nodes be 1::nnodes
ring1 : set (size capacity) of Nodes
ring2 : set (size capacity) of Nodes
ring1 = ring2

decision variables (since ring1 is a decision variable).

Deﬁnitions via genSymbol and type information (except
for the input expression) are given on the right of the long
vertical bar. The bar itself has no meaning beyond separating
the details of the rule from the types and deﬁnitions.

given
where
letting
find

nnodes : int, capacity : int
nnodes (cid:21) 1, capacity (cid:21) 1
Nodes be 1::nnodes
ring0
ring0

AllDifferent(ring0
AllDifferent(ring0

1)
2)

1 : matrix [indexed by 1.. capacity] of Nodes
2 : matrix [indexed by 1.. capacity] of Nodes

such that forall (i : 1::capacity) exists (j : 1::capacity) ring0

1[i] = ring0

2[j]

given
where
letting
find

such that

nnodes : int, capacity : int
nnodes (cid:21) 1, capacity (cid:21) 1
Nodes be 1::nnodes
ring0
ring0
forall (i : Nodes) ring0
sum (i : Nodes) ring0
sum (i : Nodes) ring0

1[i]= ring0
1[i]= capacity
2[i]= capacity

2[i]

1 : matrix [indexed by Nodes] of bool
2 : matrix [indexed by Nodes] of bool

Figure 3: ESSENCE speciﬁcation and two ESSENCE0 models
of the MicroSonet1 problem.

ﬁnal model. (cid:26) is deﬁned inductively by a set of uniquely-
named equations of the form R (cid:26)(e) = e0
n,
2 [ (cid:1) (cid:1) (cid:1) [ e0
where R is the name of the equation, e is an ESSENCE expres-
sion and each e0
i is a set of ESSENCE0 expressions, usually
given via set comprehension. For perspicuity, each equation
is split into rules, written: R1 (cid:26)(e) ref! e0
2, : : :,
Rn (cid:26)(e) ref! e0
n.

1, R2 (cid:26)(e) ref! e0

1 [ e0

The SIZEDSETEQUALITY equation is responsible for re-
ﬁning expressions of the form S1 = S2, where both S1 and
S2 are expressions of type ﬁxed-size set. Fig. 4 gives two
rules of this equation. The complete version of SIZEDSETE-
QUALITY gives one rule for for each combination of a repre-
sentation of S1 and a representation of S2 and a constraint for
imposing equality between the them.

To illustrate the operation of a rule, we now discuss
how the SIZEDSETEQUALITY1 rule reﬁnes ring1 = ring2.
SIZEDSETEQUALITY1 reﬁnes S1 and S2 into explicit one-
dimensional matrices denoted by S 0
2. The SIZED-
SETEQUALITY2 rule proceeds similarly. The reader may
wonder at the strategy of reﬁning the arguments of the equal-
ity constraint inside the equality rule itself. This is explained
in the next sub-section.

1 and S0

When a rule needs to introduce a new identiﬁer, such
as that denoted by S0
1, it does so by making use of the
genSymbol function. This function takes two arguments.
The ﬁrst is either an explicit category (see Sec. 3), or an
identiﬁer from which the category information is copied.
The second is the type of the new identiﬁer, such as a
one-dimensional matrix used for the explicit representation.
The genSymbol function creates a new identiﬁer of the
required category and type that appears nowhere else in
the ESSENCE0 model being constructed. When, for ex-
ample, reﬁning ring1 with SIZEDSETEQUALITY1, S0
1 =
genSymbol(ring1; matrix [indexed by Nodes] of 1::n),
and so S0
1 will denote a unique identiﬁer for a matrix of

1[i] = S0

Since SIZEDSETEQUALITY1 chooses to represent both
sets explicitly, the expression e =“(8i9jS 0
2[j]) ^
(n1 = n2)” is used to constrain the two explicit matrices to
represent the same set (note the introduction of the quantiﬁed
variables denoted by i and j). Since, in general, it may be
the case that e is not yet in ESSENCE0, it is reﬁned further
and the result, denoted by (cid:30), is returned. In this example,
e = “8i 9j ring0
2[j] ^ (capacity = capacity)”
is in ESSENCE0, so (cid:26)(e) = e. For brevity, the model shown
in Fig. 3 omits capacity = capacity; a simpliﬁer could eas-
ily remove it. This convention is followed in all subsequent
models generated by SIZEDSETEQUALITY1.

1[i] = ring0

Recall that the explicit representation of a set(size n)
of (cid:28) is a matrix of n distinct elements, each of type (cid:28). Thus,
when a rule generates this explicit representation, it must in-
troduce into the generated model a constraint that the ele-
ments of the matrix are all different. In particular, the SIZED-
SETEQUALITY1 rule must introduce two such constraints:
AllDifferent(S0
2). And, since the ele-
ments of S0
2 have not been reﬁned, (cid:26) must be ap-
plied to these two constraints, resulting in the ESSENCE0 con-
straints named (cid:31) and   in the rule.

1) and AllDifferent(S0

1 and S0

Consider where (cid:31) and   should occur in the generated
model. From the ESSENCE0 model of Fig. 3 it might appear
that (cid:31) and   should be conjoined to (cid:30), returning (cid:30) ^ (cid:31) ^  .
To see that this is incorrect, observe that this treatment would
reﬁne :(ring1 = ring2) to :((cid:30) ^ (cid:31) ^  ), whereas the de-
sired reﬁnement is (:(cid:30)) ^ (cid:31) ^  . The correct reﬁnement is
obtained by returning (cid:30) as the reﬁnement, tagging the reﬁne-
ment with (cid:31) ^  , and once the ESSENCE0 model is generated,
adding (cid:31) ^   to its constraints. Since, in this case, the tag is
a constraint, it is labelled by such that.

When a rule builds a reﬁnement R, a part P of which
has been generated from a recursive call to (cid:26), the tags of
P are, by default, added to the tags of R. Hence,
in
SIZEDSETEQUALITY1, the tags attached to a reﬁnement of
(cid:30), (cid:31) and   are implicitly added to the such that tag explic-
itly given in the rule. As will be seen later, this default can be
overridden.

Space precludes giving the full derivation of the explicit
ESSENCE0 model (Fig. 3). The reﬁnements triggered via
SIZEDSETEQUALITY1 in the example are, however, straight-
forward. Universal quantiﬁcation over a ﬁnite range of inte-
gers is in ESSENCE0 and can be viewed as a conjunction or
simple ‘for’ loop. Similarly, existential quantiﬁcation over a
ﬁnite range of integers can be treated as disjunction. Hence,
the ﬁrst constraint in the explicit ESSENCE0 model comes di-
rectly from SIZEDSETEQUALITY1. The occurrence model
follows similarly.

After reﬁning the constraints and the objective function of
an ESSENCE speciﬁcation, the given find and letting
statements are generated. This is done by scanning the set
of constraints and adding an appropriate deﬁnition for each
unique identiﬁer. where statements are reﬁned in the same

SizedSetEquality1 (cid:26)(S1 : set (size n1) of (cid:28) = S2 : set (size n2) of (cid:28) )

ref
!

f

(cid:30)
such that (cid:31) ^  
j
(cid:30) 2 (cid:26)((8i9jS 0
(cid:31) 2 (cid:26)(AllDifferent(S 0
  2 (cid:26)(AllDifferent(S 0

1[i] = S 0
1))
2))

2[j]) ^ (n1 = n2))

1 = genSymbol(S1; matrix [indexed by 1::n1] of (cid:28) )
2 = genSymbol(S2; matrix [indexed by 1::n2] of (cid:28) )

S 0
S 0
i = genSymbol(“Quantiﬁed variable”,1..n 1)
j = genSymbol(“Quantiﬁed variable”,1..n 2)

g

SizedSetEquality2 (cid:26)(S1 : set (size n1) of (cid:28) = S2 : set (size n2) of (cid:28) )

ref
!

f

(cid:30)
such that (cid:31) ^  
j
(cid:30) 2 (cid:26)((8iS 0
(cid:31) 2 (cid:26)((cid:6)iS 0
  2 (cid:26)((cid:6)iS 0

1[i] = S 0
1[i] = n1)
2[i] = n2)

2[i]) ^ (n1 = n2))

(cid:28) is [a::b] or bool
S 0
S 0
i = genSymbol(“Quantiﬁed variable”; (cid:28) )

1 = genSymbol(S1; matrix [indexed by (cid:28) ] of bool)
2 = genSymbol(S2; matrix [indexed by (cid:28) ] of bool)

g

ForallRange1 (cid:26)(8i : n1::n2 (cid:30) : bool)

ref
!

f

forall (i : n1::n2) (cid:30)0
such that forall (i : n1::n2) (cid:0)
j
((cid:30)0 with such that (cid:0)) 2 (cid:26)((cid:30)) g

ForallSizedSet1 (cid:26)(8i : (cid:28) 2 S : set (size n) of (cid:28):(cid:30) : bool)

ref
!

f

forall (j : 1::n) (cid:30)0
such that (cid:31)^ forall (j : 1::n) (cid:0)
j
((cid:30)0 with such that (cid:0)) 2 (cid:26)((cid:30)[i 7! S 0[j]])
(cid:31) 2 (cid:26)(AllDifferent(S 0))

g

j = genSymbol(i; 1::n)
S 0 = genSymbol(S; matrix [indexed by 1::n] of (cid:28) )

SizedSubset1 (cid:26)(S1 : set (size n1) of (cid:28) (cid:18) S2 : set (size n2) of (cid:28) )

ref
!

f

(cid:30)
such that (cid:31) ^  
j
2[S 0
(cid:30) 2 (cid:26)(8i:S 0
(cid:31) 2 (cid:26)((cid:6)j S 0
2[j] = n2)
  2 (cid:26)(AllDifferent(S 0

1[i]])

1)) g

1 = genSymbol(S1; matrix [indexed by 1::n1] of (cid:28) )
2 = genSymbol(S2; matrix [indexed by (cid:28) ] of bool)

(cid:28) is [a::b] or bool
S 0
S 0
i = genSymbol(“Quantiﬁed variable”; 1::n 1)
j = genSymbol(“Quantiﬁed variable”; (cid:28) )

Figure 4: Example Reﬁnement rules.

way that constraints are.

Reﬁning Nested Types: A Simple Example
To see how expressions of a nested type are reﬁned, con-
sider the Microsonet2 speciﬁcation (Fig. 5), where the goal
is to generate two identical sets of rings. The key decision
is the representation of rings1 and rings2, two sets of sets.
Reﬁnement begins with (cid:26)(rings1 = rings2), requiring SIZED-
SETEQUALITY. Of the rules given in Fig. 4, only SIZED-
SETEQUALITY1 is applicable, since “set (size capacity)
of Nodes” is neither a range of integers nor Boolean:
in-
dexing a matrix by a complex type (here each index would
correspond to one of the possible sets of Nodes) would often
lead to unfeasibly large matrices. Future work will consider
relaxing this condition in certain cases.

The justiﬁcation for reﬁning the arguments of the equal-
ity constraint inside the equality rule itself becomes clear in
the context of nested types. A seemingly more-natural ap-
proach to reﬁning S1 = S2 would be to reﬁne S1 and S2 and
constrain the results to be equal. However, given unbounded
nesting of types and multiple possible reﬁnements of each
type, constraining the results to be equal is not straightfor-
ward. Consider the case where S1 and S2 are not sets of inte-
gers, but sets of sets of : : : sets of integers. Having reﬁned S1
and S2 there is no ﬁxed constraint on their reﬁnements that
enforces equality on S1 and S2. Instead of this approach, our
rules are designed to “peel off” a layer of nesting so that the
associated constraint/operator can be formed without looking
arbitrarily deep inside a reﬁned expression.

Performing SIZEDSETEQUALITY1 requires reﬁning the

two such that tags, both of which impose that all the el-
ements of a matrix of sets must be different. Since these el-
ements may be of a non-atomic type, this AllDifferent con-
straint must be reﬁned. For space reasons the deﬁnition of
the ALLDIFFERENT reﬁnement rules are omitted.

1[i] = rings0

The main constraint generated by SIZEDSETEQUALITY1
is (cid:26)(8i9jrings0
2[j]). The FORALLRANGE equa-
tion is now applicable (Fig. 4 gives FORALLRANGE1). This
rule works by reﬁning (cid:30), which contains the free variable i.
Each resulting reﬁnement (cid:30)0 and its tag (cid:0), both of which con-
tain the free variable i, are wrapped in “forall i : n1::n2.”
Reﬁnement continues with (cid:26)(9j rings0
2[j]). EX-
ISTSRANGE operates in the same way as FORALLRANGE,
so we omit the details.

1[i] = rings0

1[i] = rings0

1[i] and rings0

We now have (cid:26)(rings0

2[j]), for which SIZED-
SETEQUALITY is used. Both rules are applicable, since
2[i] are sets of Nodes. The reﬁnement
rings0
in Fig. 5 uses SIZEDSETEQUALITY2 to generate an occur-
rence representation of the inner sets. The rule operates as
described earlier, but we highlight how genSymbol treats in-
dexed matrices. genSymbol respects the index structure of
its ﬁrst argument. Hence, given the indexed one-dimensional
array rings0
1[i]; matrix:::) creates a
two-dimensional Boolean matrix, rings00
1 (see Fig.5), and re-
turns the partially-indexed rings00[i], which is the reﬁned ver-
sion of an element of the set of sets.

1[i], genSymbol(rings0

The remaining reﬁnements are straightforward. Note that
2 are not in the model. These are intermediate
rings0
representations which, although more concrete than rings1

1, rings0

given
where
letting
find

such that

nrings : int, nnodes : int, capacity : int
nrings (cid:21) 1, nnodes (cid:21) 1, capacity (cid:21) 1
Nodes be 1::nnodes
rings1 : set (size nrings) of set (size capacity) of Nodes
rings2 : set (size nrings) of set (size capacity) of Nodes
rings1 = rings2

given
where
letting
find

nrings : int, nnodes : int, capacity : int
nrings (cid:21) 1, nnodes (cid:21) 1, capacity (cid:21) 1
Nodes be 1::nnodes
rings00
rings00

1 : matrix [indexed by 1::nrings; Nodes] of bool
2 : matrix [indexed by 1::nrings; Nodes] of bool

such that forall (i : 1::nrings) exists (j : 1::nrings)

forall (k : Nodes) rings00

1 [i][k] = rings00

2 [j][k]

forall (i : 1::nrings) sum (j : Nodes) (rings00
forall (i : 1::nrings) sum (j : Nodes) (rings00
forall (i; j : 1::nrings) i < j implies

1 [i][j]) = capacity
2 [i][j]) = capacity

exists (k : Nodes) rings00

1 [i][k] 6= rings00

1 [j][k]

forall (i; j : 1::nrings) i < j implies

exists (k : Nodes) rings00

2 [i][k] 6= rings00

2 [j][k]

Figure 5: ESSENCE speciﬁcation and an ESSENCE0 model of
the MicroSonet2 problem.

given
where
letting
given
find
such that

nrings : int, nnodes : int, capacity : int
nrings (cid:21) 1, nnodes (cid:21) 1, capacity (cid:21) 1
Nodes be 1::nnodes
demand : set (size m) of set (size 2) of Nodes
rings : set (size nrings) of set (size capacity) of Nodes
8pair 2 demand: 9r 2 rings : pair (cid:18) r

given
where
letting
given
find
such that forall (i : 1::m) exists (j : 1::nrings) forall (k : 1::2)

nrings : int, nnodes : int, capacity : int
nrings (cid:21) 1, nnodes (cid:21) 1, capacity (cid:21) 1
Nodes be 1::nnodes
demand 00 : matrix [indexed by 1::m; 1::2] of Nodes
rings00 : matrix [indexed by 1::nrings; Nodes] of bool

rings00[j][demand00[i][k]]

forall (i : 1::nrings) sum (j : Nodes) (rings00[i][j]) = capacity
forall (i; j : 1::nrings) i < j implies

exists (k : Nodes) rings00[i][k] 6= rings00[j][k]

Figure 6: ESSENCE speciﬁcation and an ESSENCE0 model of
the MicroSonet3 problem.

and rings2, are matrices of sets, and so not in ESSENCE0.

Reﬁning Nested Types: A Complex Example
Our ﬁnal example illustrates a difﬁcult case when reﬁning
nested types: quantiﬁcation over nested types. Consider
MicroSonet3 (Fig. 6), a variant of a large piece of SONET,
where the goal is to ﬁll a given number of rings such that the
inter-node communication demand is met. Reﬁnement begins
with (cid:26)(8pair 2 demand:9r 2 rings:pair (cid:18) r), using the
FORALLSIZEDSET1 rule (Fig. 4). The ﬁrst step is to reﬁne
the binding expression, pair 2 demand, which is, in turn, de-
pendent on the reﬁnement of the given set demand. FORALL-
SIZEDSET1 represents demand explicitly in the same way as
SIZEDSETEQUALITY1. The returned expression quantiﬁes
over the indices of this matrix.

The quantiﬁed expression (cid:30) (which is 9r 2 rings:pair (cid:18)
r in the example) is reﬁned in the context of the decision
to represent the set S explicitly as the matrix S 0. In doing
so, S0[j] is substituted for i via (cid:30)[i 7! S 0[j]] (in the exam-
ple demand0[j] is substituted for pair). As per FORALL-
RANGE1, the tags associated with this reﬁnement must also
be quantiﬁed to hold for each possible value of j. Having

highlighted this case, space precludes giving further details of
the reﬁnement. One particular rule, SIZEDSUBSET1, which
is central to this speciﬁcation, is presented in Fig. 4. This rule
shows two expressions, S1 and S2, of the same type being
reﬁned to two different representations. The design of CON-
JURE means this is no more complicated than the previously
presented rules, which produce identical representations.

Reﬁning Nested Operators
None of the reﬁnement examples considered so far have used
an ESSENCE speciﬁcation with nested operators. We have
avoided the extremely difﬁcult task of formulating reﬁnement
rules that recur on both the type of an expression and its syn-
tactic structure. Each recursive rule either works recursively
on syntactic structure and handles only atomic types or it
works recursively on nested types and handles only expres-
sions that are syntactically “primitive” (in a sense not deﬁned
here). A constraint containing both nested types and non-
primitive syntactic structure is reﬁned by ﬁrst rewriting it to
an equivalent one containing only primitive syntactic struc-
ture. For example, the constraint A\(B[C) (cid:18) D is rewritten
to 9X; Y (X = B [ C) ^ (Y = A \ X) ^ (X (cid:18) D). Each
conjunct of the resulting constraint is a primitive constraint
that has a dedicated reﬁnement rule. CONJURE performs this
rewriting in a preprocessing stage called ﬂattening.

5 Some Symmetry Detection is Free
Reﬁnement often introduces symmetries into the models it
generates; that is, the generated model contains symmetries
that do not correspond to symmetries in the original speciﬁ-
cation. This always happens when a variable X in the speciﬁ-
cation is represented by a collection of variables X 0
1; : : : ; X 0
n
in the model such that an instantiation of X corresponds to
multiple instantiations of X 0
n. For example, if X is
of type set (size 3), its explicit representation is a matrix of
three variables, X 0[1::3]. An instantiation of X corresponds
to 3! instantiations of X 0[1::3]. The matrix X 0 has index sym-
metry [6], which can broken by the symmetry-breaking con-
straint X 0[1] (cid:20) X 0[2] (cid:20) X 0[3].

1; : : : ; X 0

Since certain rules always introduce symmetry, such a rule
can tag the reﬁned expression with a description of the sym-
metry. For example, (though not shown in Fig. 4) SIZED-
SETEQUALITY1 tags (cid:30) with “symmetry indexsym((cid:30), 1),”
which indicates that (cid:30) has symmetry in its ﬁrst index. Once a
model has been generated, the symmetry tags can be used to
add appropriate symmetry-breaking constraints, or to guide a
symmetry-aware search method such as SBDS or SBDD.

Detecting symmetry as reﬁnement introduces it is a consid-
erably cheaper operation than symmetry detection on a ﬁn-
ished model.
In future, we intend to extend our system of
symmetry tags to include other types of symmetry, such as
partial index symmetry and value symmetry.

6 Generating Models with Channelling
As we have seen, ESSENCE expressions have multiple pos-
sible reﬁnements.
If the same expression appears multiple
times in a speciﬁcation, then, different reﬁnements of it may
appear in an ESSENCE0 model. Sometimes these concrete

representations have a different name but they are equivalent.
In those cases CONJURE automatically uniﬁes them into a
single representation. However, CONJURE often produces
distinct concrete representations for the same abstract sym-
bol. At ﬁrst sight, this may appear to be a weakness. On the
contrary, some of the most effective models in the literature
take this approach, since some representations allow certain
constraints to be modelled more easily than others. To main-
tain consistency among the different representations, chan-
nelling constraints are used [4].

To facilitate channelling, (though not shown in Fig 4) the
reﬁnement rules add represent tags to the reﬁnements to
record the relationship between ESSENCE identiﬁers and their
representations in the concrete model. For example, when re-
ﬁning a decision variable S of type set (size n) of int it
is possible for S to be represented by both occurrence and
explicit representations in the same model. If that is the case
the model will contain the tags “represent S by expset(S1)”
and “represent S by occset(S2),” connecting S with its con-
crete representations S1 and S2. By following the chain of
tags it is possible to connect each concrete object to the orig-
inal entity it is representing, and from these it is possible to
construct channelling constraints.

7 Experimental Results
This paper makes an empirically testable conjecture:
it is
possible to develop good constraint models for combinatorial
problems by specifying the problem in ESSENCE and reﬁning
this speciﬁcation with CONJURE. At this point we can test the
conjecture up to certain limits. The ﬁrst limitation is that we
currently are concerned only with the kernel of the model,
which lacks channelling constraints and symmetry-breaking
constraints and which has not had any transformations ap-
plied. The second limitation is that the implementation of
CONJURE currently has rules for only certain types:
inte-
gers, integer ranges, Booleans, bounded and ﬁxed-size sets,
bounded and ﬁxed-size multisets, and all compositions of
these. The implemented rules can generate ESSENCE0 models
with occurrence and explicit representations and with vari-
ables whose domains contain sets of integers.

We test this conjecture by identifying problems that can
be speciﬁed using only the supported types, and checking
whether CONJURE generates the kernel of all reasonable
models, particularly models appearing in the literature. Most
problems in the literature cannot be speciﬁed abstractly with
the supported types since they involve associating together
elements from two or more sets, which requires types such
as functions or relations. We have found seven problems in
the literature that can be speciﬁed abstractly with only the
supported types: Schur’s Lemma (SL), Balanced Incomplete
Block Design (BIBD), Steiner Triple Systems (STS), SONET
(SONET), Social Golfers Problem (SGP), RL Design (RLD),
and Balance Code Generation (BCG). Though we know of
no published models for RLD and BCG (both come from [5]),
we have included them simply to test whether CONJURE can
generate reasonable, correct models.

The results of running CONJURE on ESSENCE speciﬁca-
tions of these seven problems are summarised in the Table 1.

Problem
BIBD
SL
RLD
STS
BCG
SONET

SGP

54

# Choices
9
9
9
27
3
27

dv: mset of sets (2)
dv: mset of sets (2)
dv: mset of sets (2)
dv: mset of sets (3)
dv: mset of sets (1)
dv: mset of sets (2)
in: set of sets (1)
dv: mset of set of sets (2)

Yes
[12]
[6]
-

[12][13]

-

4(cid:2)[8]

No
-
[6]
-
-
-

4(cid:2)[8]

[12][13]

[16]

Table 1: Results of running CONJURE on seven problems.

To see how to interpret the table, consider the row labelled
SONET. This indicates that CONJURE generated 27 models
for this problem. The choices it had to make were how to
represent each of the two occurrences of the decision variable
(whose type is set of set) and the one occurrence of the input
parameter (whose type is set of sets). Our survey of the liter-
ature uncovered four published models (all in [8]) that were
among those generated by CONJURE and four (all in [8]) that
were not. The entry for SGP indicates that CONJURE gener-
ated two of the three models that we found in the literature.
Though some models appear in multiple published papers,
the table cites only one.

Examining the results of the experiments, we observed that
all of the models generated by CONJURE were correct. The
kernels of many models found in the literature were gener-
ated by CONJURE; that is, the models use the same decision
variables and the same problem constraints (as opposed to
implied or channelling constraints).

It is more enlightening to consider the models not gener-
ated by CONJURE. The four models of SONET not generated
by CONJURE arise straightforwardly by considering the deci-
sion variable to be a relation between rings and nodes. The
rules for reﬁning a relation in this way could be expressed
easily in the framework of CONJURE and would enable the
generation of these four additional models. This illustrates
that there are important issues involved in writing speciﬁca-
tions in ESSENCE, which in this case are also intertwined with
the detection of symmetry; all of this is outside the scope of
this paper.

The missing model of SL could be generated easily from
the most natural expression of the problem, which takes the
decision variable to be a partition. Again, it would be straight-
forward to add to CONJURE the necessary rules for partitions.
Finally, the model of SGP not generated by CONJURE uses
a novel modelling technique that was created through insight
into the structure of the problem. We have not yet considered
whether that technique can be generalised and then captured
in CONJURE rules.

8 Related Work in Modelling Support
OPL [19], a modelling language similar to ESSENCE0, has
been extended by ESRA [7] to provide relation variables and
by F [11] to provide function variables. ESRA currently
compiles to only a single representation, but F can produce
alternative models, some with multiple representations and
channelling. Other work has extended constraint languages

to support a single representation of both sets [10] and mul-
tisets [20]. However our work is unique in providing nested
types.

Other languages have been used to specify combinatorial
problems. NP-SPEC [3] uses existential second-order logic to
express executable speciﬁcations of every NP-complete prob-
lem. Renker et al. [15] discuss representing abstract speciﬁ-
cations in Z, an expressive abstract language that is supported
by automatic type-checkers and interactive tools. However,
reﬁnement and transformation of the Z speciﬁcation is man-
ual.

Multi-tac [14] and CACP [2; 1] are systems that perform
small-scale transformations of constraint speciﬁcations and
use heuristics and search to try to improve the search strat-
egy used in the solving of CSPs. These and similar systems
are important steps towards automating the solving of CSPs,
and complement our work on CONJURE, which at present is
only concerned with reﬁning of high-level speciﬁcations and
not the search strategy to be used, and does not implement
transformation rules as of yet.

The area of automatic program reﬁnement

is a long-
standing and mature area of computer science. KIDS [17]
and Specware [18] are among the many domain-independent
systems that support the interactive or automatic reﬁnement
of formal speciﬁcations into imperative programs. Our work
on CONJURE operates in a simpler setting of transforming
speciﬁcations into ﬁnite-domain constraint models, which are
declarative. Because our setting is simpler, we can be more
ambitious about the extent of automation achieved.

9 Conclusion

This paper has made two major contributions towards real-
ising the possibility of formalising and automating the gen-
eration of constraint models. First, the paper has presented
a language that enables combinatorial problems to be speci-
ﬁed at a level above that at which modelling decisions take
place. Second, the paper has shown how a system of for-
mal rules could reﬁne such a speciﬁcation into model kernels
at the level of abstraction supported by existing constraint
solvers. We have also outlined an approach to integrating
other aspects of model generation—channelling and symme-
try breaking—into the existing system.

A rigorous account of model generation would be valuable
in several ways. It could make our study of modelling more
systematic, revealing gaps in our understanding. It could also
guide the study of model selection by identifying the decision
points and the set of alternatives available at each. Further-
more, it would be useful in teaching and presenting modelling
and in constructing a catalogue of modelling constructs.

The automation of model generation offers further oppor-
tunities. CONJURE currently uses its rules to generate all
possible models; but the rules could also be used within an
interactive system, which, like an interactive theorem prover,
allows the user to chose from among the alternatives available
at a decision point. Our ultimate dream is that the automation
of model generation takes us one step closer to automating
the entire modelling process.

Acknowledgements Ian Miguel
is supported by a UK-Royal
Academy of Engineering/EPSRC Postdoctoral Fellowship. We
thank Adam Bakewell for contributing to an early version of this
work, and Brahim Hnich and Toby Walsh for useful discussions.

References
[1]

J. Borrett and E.P.K. Tsang. A context for constraint satisfac-
tion problem formulation. Constraints, 6:299–327, 2001.

[2] R. Bradwell, R. Ford, J. Mill, E.P.K. Tsang, and R. Williams.
An overview of the CACP project: Modelling and solv-
ing constraint satisfaction/optimisation problems with mini-
mal expert intervention. Wkshp. on Analysis & Visualization
of Constraint Programs & Solvers, 2000.

[3] M. Cadoli, G. Ianni, L. Palopoli, A. Schaerf, and D. Vasile.
NP-SPEC: An executable speciﬁcation language for solving
all problems in NP. Computer Languages, 26:165–195, 2000.
[4] B. M. W. Cheng, K. M. F. Choi, J. Ho-Man Lee, and J. C. K.
Wu. Increasing constraint propagation by redundant model-
ing: An experience report. Constraints, 4:167–192, 1999.

[5] C. J. Colbourn and J. H. Dinitz. The CRC Handbook of Com-

[6]

[7]

binatorial Designs. CRC, 1995.
P. Flener, A. Frisch, B. Hnich, Z. Kiziltan, I. Miguel, J. Pear-
son, and T. Walsh. Breaking row and column symmetries in
matrix models. Proc. 8th Int. Conf. on Princ. & Pract. of CP,
LNCS 2470, 462–476, 2002.
P. Flener, J. Pearson, M. Agren Introducing ESRA, a relational
language for modelling combinatorial problems. LOPSTR’03:
Revised Selected Papers, LNCS 3018, 214-232, 2004.

[8] A.M. Frisch, B. Hnich,

I. Miguel, B.M. Smith, and
T. Walsh. Transforming and reﬁning abstract constraint spec-
iﬁcations. Proc. of CSCLP04: Joint Annual Workshop of
ERCIM/Colognet on Constraint Solving & Constraint Logic
Programming, 74–88, 2004.
I. P. Gent and T. Walsh. CSPLib: A benchmark library for
constraints. Technical Report APES-09-1999, APES, 1999.

[9]

[10] C. Gervet. Conjunto: Constraint logic programming with ﬁ-
nite set domains. Proc. Int. Symposium in Logic Program-
ming, 339–358. The MIT press, 1994.

[11] B. Hnich. Function Variables for Constraint Programming.

PhD thesis, Dept. Information Science, Uppsala Univ, 2003.

[12] Z. Kiziltan. Symmetry Breaking Ordering Constraints. PhD

thesis, Dept. Information Science, Uppsala Univ., 2004.

[13] V. Lagoon and P. J. Stuckey. Set domain propagation using
ROBDDs. Proc. 10th Int. Conf. on Principles & Practice of
Constraint Programming, 347–361, 2004.

[14] S. Minton.

Integrating heuristics for constraint satisfaction

problems: A case study. Nat. Conf. on AI, 120–126, 1993.

[15] G. Renker and A. Ahriz. Building models through formal
speciﬁcation. Proc. CP-AI-OR-04, LNCS 3011, 295–401,
2004.

[16] B. M. Smith. Reducing symmetry in a combinatorial design

problem. Proc. CP-AI-OR, 351–359, 2001.

[17] D. R. Smith. KIDS: A knowledge-based software develop-
ment system. Automating Software Design, 483–514. MIT
Press, 1991.

[18] Specware 4.0 User Manual. Kestrel Institute, October 1994.
[19] P. van Hentenryck. The OPL Optimization Programming Lan-

guage. MIT Press, 1999.

[20] T. Walsh. Consistency and propagation with multiset con-
straints: A formal viewpoint. Proc. 9th Int. Conf. on Princ.
& Pract. of CP, LNCS 2833, 724–738, 2003.

