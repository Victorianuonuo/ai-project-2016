608 

Session No.  15  Heuristic  Problem Solving 

STRIPS:  A NEW  APPROACH  TO THE  APPLICATION 

OF THEOREM PROVING TO PROBLEM SOLVING 

Richard  E.  Fikes 
Ni Is  .J.  Ni lsson 

Stanford  Research  Institute 

Menlo  Park,  California 

L' , o . A , 

ABSTRACT 

We  describe  a  new  problem  solver  called  STRIPS 

that  attempts  to  find  a  sequence  of  operators  in 
a  space  of  world  models  to  transform  a  given 
i n i t i al  world  model  into  a  model  in  which  a  given 
goal  formula  can  be  proven  to  be  true.  STRIPS 
represents  a  world  model  as  an  arbi trary  collec(cid:173)
tion  of  first-order  predicate  calculus 
formulas 
and  is  designed  to  work  with  models  consisting  of 
1arge  numbers  of  formulas.  1t  employs  a  resolu(cid:173)
tion  theorem  p rover  to  answer  (jues t ions  of  partic(cid:173)
ular  models  and  uses  means-ends  analysis  to  guide 
it 

to  the  desired  goal-satisfying  model  . 

DESCRIPTIVE TERMS 

Probl em solv J ng, t heorem prov i rig, robot 
planning  F  heuristic  search. 

1 

INTRODUCTION 

This  paper  describes  a  new  problem-solving 

ind  one  in  w hich  a  given  goal  is  achieved . 

program  cal led  STRIPS  (STanford  Research  Ins11tute 
Problem  Solver).  An  i n i t i al  version  of  the  pro(cid:173)
gram  has  been  implemented  in  LISP  on  a  PDP-10  and 
is  being  used  in  conjunction  with  robot  research 
at  SRI.  STRIPS  is  a  member  of  the  class  of  prob(cid:173)
lem  solvers  that  search  a  space  of  "world  models" 
to 
For  any  world  model,  we  assume  that  there  exists 
a  set  of  appllcable  ope rators,  each  of  w hi eh  trans-
forms  the  world  model  to  some  other  world  model. 
The  task  of  the  problem  solver  is  to  find  some 
composl11on  of  ope rat ors  that  trans forms  a  given 
i n i t i al  worId  mode] 
into  one  t hat  satisfies  some 
stated  goa1  condltion . 

Operators  are  the  basic  elements  from  which  a 

solution  is  b u i l t.  For  robot  problems,  each 
operator  corresponds  to  an  action  routine*  whose 
execution  causes  a  robot  to  take  certain  actions. 
For  example,  we  might  have  a  rout ine  that  causes 
it  to  go  through  a  doorway,  a  routine  that  causes 
it  to  push  a  box,  and  perhaps  dozens  of  others. 

Green  (4)  implemented  a  problem-solving  system 

that  depended  exclus ively  on  formal  theorem-
proving  methods  to  search  for  the  appropri ate 
sequence  of  operators.  While  Green fs  formulation 
represented  a  significant  step  in  the  development 
of  problem-solvers, 
it  suf fered  some  serious  dis-
advant ages  connected  with  the  'frame  problem" 
t hat  prevented  it 

f rom  solving  nont r i v i al  problems. 

In  STRIPS,  we  surmount  these  d i f f i c u l t i es  by 

separatlng  entirely  the  processes  of  theorem 
proving  from  those  of  searching  through  a  space 
ot  world  models.  This  separation  allows  us  to 
employ  separate  st rategies  tor  these  two  a c t l v i-
tles  and  t hereby  improve  the  overal1  performance 
of t he sys t em . Theorem-p rovi ng met hods a re used 
only  within  a  given  world  model  to  answer  ques-
tIons  about  it  concerning  which  operators  are 
applicable  and  whether  or  not  goals  have  been 
satisfied.  For  searching  through  the  space  of 
world  models,  STRIPS  uses  a  GPS-like  means-ends 
analysis  strategy (6) .  This  combination  of  means-end^ 
analysis  and  formal  t heorem-proving  methods  allows 
objects  (wor1d  mode Is)  much  more  complex  and  gen(cid:173)
eral  than  any  of  t hose  used  in  GPS  and  provides 
more  powerfu1  search  heuristics  t han  t hose  found 
in  t heorem-proving  programs. 

We  proceed  by  describing  the  operat ion  of 
STRIPS  in  terms  of  the  conventions  used  to  rep(cid:173)
resent  the  search  space  for  a  problem  and  the 
search  methods  used  to  find  a  solution  .  We  t hen 
discuss  t he  detaiIs  of  implementation  and 
present  some  examples . 

This  f rarnewo rk  for  probl em  so 1 v i ng  has  l>een 

cen t ra 1  to  much  of  t he  research  I n  a r t i f i c i al 
Intel licence  ( 1 ) .  Ou r  p nmary  interest  he re  is 
in  the  class  of  p robJ ems  faced  by  a  robot  in  re-
a rranging  ob]ec t s  and  in  navigatlng,  l .e . f  p rob 1 ems 
t hat  requi re  quit e  complex  and  genera 1  world  mode Is 
compared  to  t hose  needed  ln  t he  solution  of  pu//1es 
and  games. 
In  puzzles  and  games,  a  simple  matrix 
or  list  s t ruet ure  is  usually  adequate  to  represent 
a  state  of  t he  p roblem.  The  wor Id  mode 1  for  a 
robot [J robl em sol ve r, however, mus t i nc 1 ude a 1 arge 
numbe r  of  facts  and  re 1 ations  deallng  with  t he  posi-
tion  of 
the  robot  and  the  positions  and  attributes 
of vjrious ob jec t s , open spaces , and hound a r it-1 s . 
In  STRI PS,  a  world  mode 1  is  represent ed  by  a  set 
o(  wt  11-formed  formulas  (wffs)  of  1 he  first-order 
predicate en 1cu1 us . 

The  reader  should  keep  in  mind  the  distinction 
between  an  operator  and  its  associated  action 
routine.  Execution  of  action  routines  actually 
causes  the  robot  to  take  actions.  Application 
of  operators  to  world  models  occurs  during  the 
planning  ( i . e .,  problem  solving)  phase  when  an 
attempt  is  being  made  to  find  a  sequence  of 
operators  whose  associated  action  routines  wi11 
produce  a  desired  state  of  the  world. 
(See  the 
papers  by  Munson  (2)  and  Fikes  (3)  for  discus(cid:173)
sions  of  the  relationships  between  STRIPS  and 
the  robot  executive  and  monitoring  functions. 

Space  does  not  allow  a  full  discussion  of  the 
frame  problem;  for  a  thorough  treatment,  see 
Ref.  (5). 

Session No.  15  Heuristic  Problem Solving 

609 

R.  F.  PIKES,  N.  J.  NILSSON 

II  THE  OPERATION  OF  STRIPS 

A .  The  Problem  Space 

The  problem  space  for  STRIPS  is  defined  by  the 

the  set  of  available  opera(cid:173)
i n i t i al  world  model, 
tors  and  their  effects  on  world  models,  and  the 
goal  statement. 

As  already  mentioned,  STRIPS  represents  a 

world  model  by  a  set  of  well-formed  formulas  (wfls). 
For  example,  to  describe  a  world  model  in  which  t he 
robot  is  at  location  a  and  boxes  B  and  C  are  at 
locations  b  and  c  we  would  lnclude  t he  following 
wt fs : 

ATR(a) 
AT(B, h) 
AT(C,c) 

We might also Inc1ude t he w f i 

("u  "x  Vy) 

[AT(u,x)  A  (x=  y)]  =>  AT(u,y)) 

to state  the  general  rule  that  an object  in one place 
is  not  in  a  different  place.  Using  first-order 
predicate calculus wffs,  we can represent  quite 
complex world models  and can use existing theorem-
proving programs  to answer questions  about  a model. 

The available operators  are grouped  into  fam-
llies  called  schemata.  Consider  for example  t he 
operator goto  for moving  the  robot  from one  point 
on  the  floor  to  another,  Here  there  is  really  a 
distinct  operator  for  each  different  pair  of 
points,  but  it  is  convenient  to  group  all  of 
these  into a family goto(m,n)  parameterized  by 
the initial posit ion* m and t he final position 
n.  We say  that goto(m,n)  is  an operator schema 
whose members  are obtained by substituting speci(cid:173)
fic constants  for the parameters  m and  n.  In 
STRIPS,  when an operator is  applied  to a world 
model,  specific const ants will  already  have  been 
chosen  for  the  operator  parameters. 

Each operator is defined  by  an operator descrip-

t ion consisting  of  two main parts:  a description 
of  the  effects  of  the  operator,  and  the  conditions 
under which  the  operator  is  applicable.  The  effects 
of  an operator are simply defined  by  a  list  of wffs 
that  must  be  added  to  the model  and  a  list of wfls 
that  are no longer t rue and therefore must  be 
deleted.  We shall discuss  the process of calcula(cid:173)
ting  these  effects  in  more  detail  later. 
It  is 
convenient  to  state  the  applicability  condition, 
or precondition,  for an operator schema as  a wff 
schema.  To determine whether or not  there  is  an 
instance  of  an operator  schema  applicable  to 
a world model, we must be able to prove 

The parameters m and n are each really vector-
valued,  but we avoid vector notation here for 
simplicity.  In general,  we denote constants  by 
letters  near  the  beginning  of  the  alphabet 
(a,b,c, . . . ),  parameters  by  letters  in the middle 
of  the  alphabet (m,n, . . . ),  and  quantified  vari-
ables  by  letters  near the end of  the  alphabet 
(x,y,z) . 

that  there is  an  instance of  t he correspondIng 
wff schema  that  logically  follous  from  t he model . 
For example,  cons ider t he question oi  applying 

instances of t he operator subschema got O(m,b) to 
a world model  containing  the  wff  ATR(a)  where  a 
and  b are  constants.  If  the  precondition wff 
schema of goto(m,n)  is  ATR(m),  then we  find  that 
the instance ATR( a) can be proved from t he world 
model.  Thus,  an  appllcable  instance of  goto(m,b) 
is  goto(a,b). 

It  is  important  to distinguish  between  t he 

parameters  appearing  in wff  schemata  and  ordinary 
existentially  and  universally  quantifiedd  variables 
that may also appear - Certain modifications mus t 
be made to theorem-provlng programs to enable t hem 
to handle w ff schemata, t hese a re discussed later. 

Goal statements  are also represented  by wffs . 
For example,  the t ask  "Get Boxes B and C to Loca-
tion a" might be s tated as the wff: 

AT(B,a)  AT(C,a) 

To summarize, the problem space  for STRIPS  is 

deflned  by  t hree  entities: 

(1)  An initial  world model,  which is  a set 
of  wffs  describing  the  present  state  of 
the world . 

(li)  A set  of  operators,  including  a descrip(cid:173)
tion  of  their  effects  and  their  precon(cid:173)
dition wff  schemat a. 

(3)  A goal  condition stated as  a wff. 

The problem is solved when STRIPS produces a world 
model  that  satisfies  the  goal  wff. 

B.  The Search Strategy 

In a very simple problem-solving system, we 

might  first  apply  all  of  the  applicable  operators 
to  the  initial  world  model  to create  a set  of 
successor models.  We would continue to apply  all 
applicable  operators  to  these successors  and  to 
their  descendants  (say  in  breadth-first  fashion) 
untill  a model was  produced  in which  the goal 
formula was a theorem.  However,  since we envision 
uses  in which the  number of  operators  applicable 
to any given world model might  be quite  large, 
such a simple system would generate an undesirably 
large  tree of world models  and would  thus  be 
impractical. 

Instead, we have adopted the GPS strategy of 
extracting  "differences"  between  the present world 
model and  the goal  and of  identi fying operators 
that  are  "relevant"  to  reducing  these differences 
(6).  Once a relevant operator has  been determined, 
we  attempt  to solve  the subproblem of producing 
If  such 
a  world  model  to which  it  is  applicable. 
a model  is  found,  then we apply  the relevant oper(cid:173)
ator  and  reconsider  the  original  goal  in  the 
resulting model.  In  this  section,  we  review  this 
basic GPS search strategy as employed by STRIPS. 

610 

Session No.  15 Heuristic Problem Solving 

R. E. FIKES,  N. J. NILSSON 

In  this  case,  the  uncompleted  proof  is 

STRIPS begins by employing a theorem prover 
to  attempt  to  prove  that  the  goal  wff GO follows 
from the set  M  of wffs  describing  the  initial 
world model.  If GQ does  follow  from M(,f the task 
is  trivially  solved  in  the  initial  model.  Other-
wise,  the  theorem prover will  fail  to  find  a 
proof. 
taken to be the 'difference" between MO and GO, 
Next,  operators  that might  be relevant  to  "redu(cid:173)
cing1'  this  difference  are sought.  These  are  the 
operators whose effects on world models would 
enable  the proof  to  be  continued.  In determining 
relevance,  the parameters of the operators may  be 
partially  or  fully  instantiated.  The  correspond-
ing  instantiated  precondition wff  schemata  (of 
the relevant operators)  are then taken to be new 
subgoals. 

Consider  the  trivially  simple  example  in which 

the  task  is  for  the  robot  to go  to  location  b. 
The goal wff  is  thus  ATR(b),  and  unless  the  robot 
is  already  at  location  b,  the  initial  proof  attempt 
will  be unsuccessful.  Now,  certainly  the  instance 
goto(m,b)  of  the  operator  goto(m,n)  is  relevant 
to  reducing  the  difference  because  its  effect 
would  allow  the  proof  to  be continued  (in  this 
case,  completed).  Accordi ngly,  the corresponding 
precondition wff schema,  say  ATR(m),  is used  as 
a subgoal• 

STRIPS works on a subgoal using the same tech(cid:173)

nique.  Suppose  the precondition wff schema G  is 
selected  as  the  first subgoal  to be worked on. 
STRIPS again uses a theorem prover in an attempt 
to  find  instances  of G  t hat  follow  from  the  ini-
tial  world  model  MO.  Here  again,  there  are  two 
possibilities.  If  no proof can  be  found,  STRIPS 
uses  the incomplete proof as a difference,  and 
sets  up  (sub)  subgoals  corresponding  to  their 
precondition wffs.  If  STRIPS does  find  an  in-
stanee of G that follows from MO, then t he cor(cid:173)
respond 1 ng operator instance is used to t ransform 
MO into a new world model M1. In our previous 
simple example,  the subgoal wff schema G  was 
ATR(m). 
If  the  initial  model  contains  the  wff 
ATR(a),  then an  instance of G--namely  ATR(a)—can 
be proved  from Mf).  In this  case,  the correspond(cid:173)
ing  operator  instance  goto(a,b)  is  applied  to  M() 
to produce the new model,  M1.  STRIPS t hen con-
tinues by at tempting to prove GO from M1 . In our 
example, GO trivially follows  from M1 and we are 
through.  However,  if  no proof  could  be  found, 
subgoals for t his problem would be set up and t he 
process would continue. 

The hierarchy of goal,  subgoals,  and models 

generated  by  the search process  is  represented  by 
a search tree.  Each node of  the search t ree has 
the  form  ( (world  model)1  (goal  list>),  and  repre(cid:173)
sents  the  problem of  trying  to  achieve  the  sub-
goals  on the goal  list  (in order)  f rom  t he  indi-
cated world model. 

An example of such a search tree is shown in 
Figure  1.  The  top node  (M ,(GO ))  represents  the 

main  task of  achieving goal GO from world model 
MQ.  In this case, two alternative subgoals Ga 
and Gb. are set up.  These are added  to  the  front 
of  the goal  lists  in  the  two  successor  nodes. 
Pursuing  one  of  these  subgoals,  suppose  that  in 
the  node (MQ,(Ga,G0)), goal Ga is  satisfied  in 
M();  the  corresponding  operator,  say  OPa,  is  then 
applied to Mo to yield M1 . Thus, along this 
branch,  the problem is now to satisfy goal GO 
from M1, and  this  problem is  represented  by  the 
node  (M1(G0).  Along  the other path,  suppose 
Gc is set up as a subgoal  for achieving G.  and 
thus the node (MO, (Gc, Gb, GO) ) is created . Suppose 
Gc  is  satisfied  in MO and  thus  OP  is  applied  to 
M0 yielding M2.  Now STRIPS must still solve the 
subproblem Gb before attempting  the main goal GO. 
Thus,  the result of applying OP  is to replace MQ 
by M2, and  to  remove Gc from  the goal  list  to 
produce the node (M2,(Gb,GO)). 

This  process  continues  until  STRIPS produces 

the node (M4, (G())) .  Here suppose G() can be 
proved directly  from M- so that  this  node  is 
terminal.  The  solution  sequence  of  operators  is 
thus (OPc,OPb, OPe). 

This  example search  t ree  indicates  clearly 
that when an operator is  found  to  be  relevant, 
it  is  not  known  where  it  will  occur  in  the  com-
pleted  plan,  that  is,  it  muy  be  applicable  to 
the  initial  model  and  therefore  be  the  first 
operator  applied,  i ts  effects  may  imply  the  goal 
so  that  it  is  the  last  operator  applied,  or  it 
may be some intermediate step toward the goal. 
This  flexible  search  strategy  embodied  in  STRIPS 
combines  many  of  the  advantages  of  both  forward 
search (from t he initial  model  toward  the goal) 
and  backward search  (from the goal  toward  the 
initial  model). 

Whenever STRIPS generates a successor node, 

it  immediately  tests  t  o  see  if  the  first  goal  on 
the  goal  list  is  satisfied  in  the  new  node's 
model .  If  so,  the  corresponding  operator  i s 
applied, generating a  new  successor  node,  if  not, 
the  difference  (i.e.,  the  uncompleted  proof)  is 
stored with t he node . Except for t hose successor 
nodes generated  as  a resuIt  of  applying operators, 
the  process  of  successor generation  is  as  follows: 
STRIPS selects  a node and uses  the difference 
stored with  the  node  to  select  a  relevant  opera-
tor. 
It  uses  the  precondition  of  this  operator 
to generate  a  new  successor.  (If  all  of  the  node's 
successors  have already been generated,  STRIPS 
selects  some  other  node  still  having  uncompleted 
successors .)  A flowchart  summarizing  the  STRIPS 
search process is s hown in Figure 2. 

STRIPS has  a heuristic mechanism to select 

nodes with uncompleted successors  to work on 
next .  For this purpose we use an evaluat ion  func-
tion  that  takes  into  account  such  factors  as  the 
number of  remaining goals  on  the goal  list,  the 
number and  types  of  predicates  in  t he  remaining 
goal  formulas ,  and t he complexi ty of t he difference 
attached to the node • 

Session No.  15  Heuristic  Problem Solving 

611 

612 

Session No.  15  Heuristic  Problem Solving 

R. E. FIKES, N. J. NILSSON 

III  IMPLEMENTATION 

A.  Theorem-Proving with Parameters 

In this section,  we discuss the more impor(cid:173)

tant details  of our implementation of STRIPS,  we 
begin by describing t he automatic theorem-proving 
component. 

STRIPS uses  the resolution t heorem-prover 

QA3.5  (7) when attempting to prove goal  and sub-
goal wffs .  We assume that  the reader is  familiar 
wi th  resolution  proof  techniques  for  the  predicate 
calculus  (1).  Those  techniques must  be extended 
to  handle  the  parameters  occurring  in wff  schemes; 
we discuss t hese extensions next. 

The general situation is  thnt we have some 
goal  wff  schema G(p),  say,  that  is  to  be  proved 
from a set M of clauses where p is a set of schema 
parameters.  Following  the  general  strategy  of 
resolution theorem provers, we  attempt  to prove 
the  inconsistency  of  the  set  [M  U~G(p)].  That 
is,  we attempt  to find an instance p' of P for 
which  [M U ~ G(p ') ] is  inconsistent  . 

We have been able to use the standard unifi(cid:173)
cation  algorithm of  the  resolution method  to com(cid:173)
pute  the  appropriate  ins t ances  of schema variables 
during  the  search  for  a  proof.  This  algorithm 
has  the  advantage  that  it  finds  the  most  general 
instances  of  parameters  needed  to  effect  unifica(cid:173)
tion.  To use the unification algorithm we must 
sped fy  how  it  is  to  treat  parameters .  The  follow-
lng  substitution  types  are  allowable  components 
of  the  output  of  the  modified  unification  algorithm: 

•  Terms  that can be substituted  for a var(cid:173)
(cid:173)able:  variables,  constants,  parameters , 
and  functional  terms  not  containing  the 
vari able. 

•  Terms that can be substituted for a param(cid:173)

eter:  constants,  parameters,  and  func-
tional  terms  not  containing  Skolem  func-
tions, variables, or t he parameter. 

The  fact  that  the same parameter may  have multiple 
occurrences  in  a set  of  clauses  demands  another 
modificat ion  to  the  theorem prover.  Suppose  two 
clauses C1 and C2 resolve to form clause C and 
that  in  t he process  some  term t  is  substituted 
for parameter p.  Then we must make sure that p 
is  replaced  by  t  in  all  of  the  clauses  that  are 
descendants  of C. 

B.  Operator Descriptions  and  Applications 

We have already mentioned that to define an 
operator,  we must state the preconditions under 
which  it  is  applicable  and  its  effects  on  a  world 
model schema.  Preconditions  are stated  as wff 
schemata.  For example,  suppose G(p)  is  the oper(cid:173)
ator precondition schema of  an operator 0(p),  p 
is a set of parameters,  and M is a world model. 
Then  if  p'  is  a  constant  instance  of  p  for which 
{M U ~ G(p')]  is contradictory,  then STRIPS can 
apply operator O(p')  to world model  M. 

We next need a way to state the effects of 

operator application on world models.  These 
effects are simply described by two lists.  On 
the delete  list we specify  those clauses  in  the 
original model  that might  no  longer be true  in 
the new model. On the add list are those clauses 
that  might  not  have  been  true  in  the original 
model  but  are true in the new model. 

For example, consider an operator push(k,m,n) 

for pushing object k from m to n • Such an oper-
ator might be described as follows: 

The parameters of an operator schema are 

instantiated  by constants  at  the time of opera-
tor application.  Some  instantiations  are made 
while deciding what instances of an operator 
schema are relevant to reducing a difference,  and 
the rest are made while deciding what instances 
of an operator are applicable in a given world 
model . Thus, when the add and delete lis ts are 
used to create new world models,  all parameters 
occurring in them will have been replaced by con-
stants  . 

(We can make certain modifications to STRIPS 
to  allow  it  to  apply  operators  with  uninstantiated 
parameters•  These applications will produce world 
model schemata.  This generalization complicates 
somewhat the simple add and delete-list rules  for 
computing new world models and needs further s tudy. 

For certain operators  it  is  convenient  to  be 
able merely  to specify  the form of clauses  to be 
deleted .  For example,  one of the effects of a 
robot goto operator must be to delete information 
about  the direction  that  the  robot was  originally 
f acing even though such information might not 
have been represented by one of the parameters of 
the operator.  In this case we would include the 
atom FACING($)  on the delete  list of goto with 
the convention that any atom of the form FACING($), 
regardless of the value of $,  would be deleted. 

When an operator descripti on is written,  it 
may not  be possible to name explicitly all the 
atoms  that should appear on the delete  list.  For 
example,  it may be the case that a world model 
contains clauses  that are derived from other 
clauses  in the model.  Thus,  from AT(Bl,a)  and 
from AT(B2,a + A), we might derive NEXTT0(B1, B2) 
and  insert  it  into  the model.  Now,  if  one of 
the clauses on which the derived clause depends 

Session No.  15  Heuristic  Problem Solving 

613 

R. E. KIKES, 

N.J. N1LSSON 

is  deleted,  t hen  the derived  clause must  also  he 
deleted  . 

We deal with this problem by defining a set 

of primitive predicates  (e.g.,  AT,  ATK)  and 
relating  all  other  predicates  to  this  primitive 
set .  In particular,  we  require  t he delete  list 
of  an  operator description  to  indicate  all  the 
atoms  centaining  primitive  predicates  that  should 
be deleted  when  the operator  is  applied.  Also, 
we require t hat any nonprimitive clause in t he 
world  model  have  associated  with  it  those  primi(cid:173)
tive  clauses  on which  its  validity  depends .  (A 
primitive  clause  is  one  which  contains  only  prim(cid:173)
itive  predicates.)  For example,  t he  clause 
NEXTT0(B1,B2)  would  have  associated  with  it  the 
clauses AT(B1,a) and AT(B2,a +  A), 

IiV  using  these conventions,  we can be assured 

that  primitive  clauses  will  be  correctly  deleted 
during operator  applications,  and  that  t he  valid-
ity  of  nonprimitive  clauses  can  be  deterimined 
whenever they are  to be used  in a deduction by 
checking  to see  if  all of t he  primitive  c 1 auses 
on which  t he nonprimitive clause depends  are still 
in  t he  worId  model. 

C .  Computinig  Difference  and Relevant Operators 

STRIPS uses the GPS strategy  of  attempting  to 

apply  those  operators  that  are  relevant  to  redu-
cing a difference between a world model  and a goal 
or subgoal .  We use the theorem prover as a key 
part  of  this  mechainsm . 

Suppose we have jus t created a new node in the 

search tree represented by (M, ((G1,GN-1, . . ., G()) ) . 
The  t heorem  prover  is  called  to  attempt  to  find 
a contradiction  for  the set  I M U ~ G1} •  If one 
can be found, the operator w hose precondition 
was G1 IS applied to M and t he process continues. 

Here, t hough, we are interested l n t he case 

in which  no  contradition  is  obtained  after 
investing some prespecified amount  of  theorem-
proving  effort .  The  uncompleted  proof  p  is 
represented  by  the  set  of  clauses  that  form 
the  negation  of  the  goal  wff,  plus  all  ot  their 
descendant s  (if  any ),  less  any  clauses  eliminated 
by  editing  strategi  (such  as  suhsumption  and 
predicate evaluation).  We take P to be the dif-
ference between M and G1 and attach P to the node. 

Later,  in  attempting  to  compute  a  successor 
to  this  node with  incomplete  proof  P attached, 
we  firs t  must  select  a  relevant  operator.  The 
quest  for  relevant  operators  proceeds  in  two 
steps . 
In  the  first  step  an  ordered  list  oi 
candidate  operators  is  created.  The  selection 
of candidate operators  is  based on a simple com(cid:173)
parison  of  the  predicates  in  the  difference  clauses 
with  those  on  the  add  lists  of  the operator 

If  P is  very  large we  can  heuristica1ly  select 
some part of P as  the difference. 

descriptions .  For  example,  if  t he  difference 
contained  a  clause  having  in  it  t he  negation  of 
a position predicate AT, t hen t he opera tor push 
would be considered as  a candidate  for  this 
difference. 

The second s tep  in  finding  an operator  rele-

vant  to  a  Riven  difference  involves  employing 
the  theorem  prover  to  determine  It  clauses  on 
t he add list of a candidate operator can be used 
to  "resolve  away  clauses  in  t he  difference  (i.e., 
to see if  t he proof can be continued based on t he 
effects of t he operator) , If t he t heorem prover 
can  in  fact  produce  new  resolvents  that  are 
descendants  of  the  add  list  clauses,  then  the 
candidate  operator  (properly  instantiated)  is 
considered to be a  relevant  opterator  for  t he 
differenee  set . 

Note that  the  consideration  of  one  candidate 

operator  schema may  produce  several  re levant 
operator  instances.  For  examp]e,  If  t he  differ-
ence  set  contains  the  unit  clauses ~ ATK(a)  and 
— ATR(b), t hen there are two relevant instances 
of goto(m,n),  namely  got o(m,a)  and goto(m,b) . 
Each  new  resolvent  that  is  a  descendant  of  the 
operator's  add  list  clauses  is  used  to  form  a 
relevant  instance  of  the  operator  by  applying  to 
t he operator's parameters  t he same substitutions 
that  were  made  during  the  production of  the 
resolvent . 
I).  Efficient  Representation of  WorI  Model s 

A primary design issue in t he implementation 

of  a system such  as STRIPS is  hou  to  satisfy  the 
storage  requirements  of  a  search  tree  in  which 
each node may contain a different world model . 
We would like to use STRIPS  in a robot  or question-
answering environmen t w he re t he initial world 
model  may  consist  of  hundreds  of  wffs.  For  such 
applications  it  is  infeasIhie  to  recopy  completely 
a worId  model  each time a new model  is  produced 
by application of  an operator. 

We have dealt with this problem in STRIPS by 

first  assuming  that  most  of  the  wffs  in  a  prob-
lem's  initial WORLd mode 1  will  not  be  changed 
by  the  application  of  operators.  This  is  cer(cid:173)
tainly  true  for  the  class  of  robot  problems  with 
which we are currently concerned .  For t hese 
probl ems most of t he w f f s I n a mode 1 describe 
rooms,  walls,  doors,  and  objects,  or specify 
general  properties  of  the  world,  which  are  true 
in  all models .  The  only  wffs  t hat  might  be 
changed "• n this  robot  environment are the ones 
that  describe  the  status  of  the  robot  and  any 
objects  which  it  manipulates. 

Given this assumption, we have implemented 
t he  following  scheme  for handling multiple world 
models.  All  the  wffs  for  al1  world  models  are 
stored  in a common memory s t ructure,  Assoclated 
with  each  wft  (i.e.,  clause)  is  a  visibility 
flag,  and QA3.0 has  been modifled  to  consider 
only  clauses  from  the memory  structure  that  are 
marked as visi ble.  Hence, we can  define"  a 

614 

Session No.  15  Heuristic  Problem Solving 

R.  E.  FIKES,  N.  J.  NILSSON 

particular  world  model  for  QA3.5  by  marking  that 
model's  clauses  visible  and  a ll  other  clauses 
invisible.  When  clauses  are  entered  into  the 
i n i t i al  world  model,  they  are  a ll  marked  as  vis(cid:173)
i b l e.  Clauses  that  are  not  changed  remain  visible 
throughout  STRIPS'  search  for  a  solution. 

Each  world  model  produced  by  STRIPS  is  defined 

by  two  clause  l i s t s.  The  f i r st  l i s t,  DELETIONS, 
names  a ll  those  clauses  from  the  i n i t i al  world 
model  that  are  no  longer  present  in  the  model 
being  defined.  The  second  l i s t,  ADDITIONS,  names 
a ll  those  clauses  in  the  model  being  defined  that 
are  not  also  in  the  i n i t i al  model.  These  lists 
represent  the  changes  in  the  i n i t i al  model  needed 
to  form  the  model  being  defined,  and  our  assump(cid:173)
tion  implies  they  w i ll  contain  only  a  small  number 
of  clauses. 

To  specify  a  given  world  model  to  QA3.5,  STRIPS 
marks  visible  the  clauses  on  the  model's  ADDITIONS 
l i st  and  marks  invisible  the  clauses  on  the  model's 
DELETIONS  l i s t.  When  the  call  to  QA3.5  is  com(cid:173)
pleted, 
the  v i s i b i l i ty  markings  of  these  clauses 
are  returned  to  their  previous  settings. 

When  an  operator  is  applied  to  a  world  model, 

the  DELETIONS  l i st  of  the  new  world  model  is  a 
copy  of  the  DELETIONS  l i st  of  the  old  model  plus 
any  clauses  from  the  i n i t i al  model  that  are 
deleted  by  the  operator.  The  ADDITIONS  l i st  of 
the  new  model  consists  of  the  clauses  from  the 
old  model's  ADDITIONS  l i s t,  as  transformed  by 
the  operator,  plus  the  clauses  from  the  operator's 
add  l i s t. 

E.  An  Example 

Tracing  through  the  main  points  of  a  simple 
example  helps  to  i l l u s t r a te  the  various  mechan(cid:173)
isms  in  STRIPS.  Suppose  we  want  a  robot  to 
gather  together  three  objects  and  that  the  i n i-
t i al  world  model  is  given  by: 

We  attach  this 
then  select  the  node  to  have  a  successor  computed 

incomplete  proof  to  the  node  and 

The  only  candidate  operator  is  push(k,m,n). 

Using  the  add  l i st  clause  AT(k,n),  we  can  con(cid:173)
tinue  the  uncompleted  proof  in  one  of  several 
ways  depending  on  the  substitutions  made  for  k 
and  n.  Each  of  these  substitutions  produces  a 
relevant  instance  of  push.  One  of  these  i s: 

OP  :  push(B0X2,m, b) 

given  by  the  substitutions  B0X2  for  k  and  b  for 
n. 
is : 

Its  associated  precondition  (in  negated  form) 

Suppose OP1 Is selected and used  to create a 
successor  node.  (Later  in  the  search process 
another  successor  using  one  of  the  other  rele(cid:173)
vant  instances  of  push might  be  computed  if  our 
original  selection did  not  lead  to  a  solution.) 
Selecting OP1 leads  to  the computation of  the 
successor node (M(), (G1 , GO ) ) . 

Session No.  15  Heuristic  Problem Solving 

615 

R.  E.  FIKES,  N.  J.  NILSSON 

The  f i r st  task  is  to  turn  on  the  lightswitch. 
The  robot  can  solve  this  problem  by  going  to  the 
largest  of  the  three  boxes,  BOX1,  pushing  it  to 
the  lightswitch,  climbing  on  the  box*  and  turning 
on  the  lightswitch.  The  second  task  is  to  push 
the  three  boxes  in  ROOM1  together. 
a  more  realistic  elaboration  of  the  three-box 
problem  used  as  an  example  in  the  last  section.) 
The  third  task  is  for  the  robot  to  go  to  a  desig(cid:173)
nated  location, 

in  ROOM4. 

(This  task  is 

f, 

The  operators  that  are  given  to  STRIPS  to 
solve  these  problems  are  described  in  Table  1. 
For  convenience  we  define  two  "goto"  operators, 
gotol  and  goto2.  The  operator  gotol(m)  takes  the 
robot  to  any  coordinate  location  m  in  the  same  roo 
as  the  robot.  The  operator  goto2(m)  takes  the 
robot  next  to  any  item  m  (e.g.,  lightswitch,  door, 
or  box)  in  the  same  room  as  the  robot.  The  oper(cid:173)
ator  pushto(m,n)  pushes  any  pushable  object  m  next 
any  item  n  (e.g., 
the  same  room  as  the  robot.  Additionally,  we  have 
operators  for  turning  on  lightswitches,  going 
through  doorways,  and  climbing  on  and off  boxes .  The 
precise  formulation  of  the  preconditions  and  the 
effects  of  these  operators  is  contained  in  Table  1 

lightswitch,  door  or  box)  in 

In  Table  2,  the  figures  in 

We  also  l i st  in  Table  1  the  goal  wffs  for  the 
three  tasks  and  the  solutions  obtained  by  STRIPS. 
Some  performance  figures  for  these  solutions  are 
shown  in  Table  2. 
the  "Time  Taken"  column  represent  the  CPU  time 
(excluding  garbage  collection)  used  by  STRIPS  in 
finding  a  solution.  Although  some  parts  of  our 
program  are  compiled,  most  of  the  time  is  spent 
running  interpretive  code;  hence,  we  do  not 
attach  much  importance  to  these  times.  We  note 
that  in  a ll  cases  most  of  the  time  is  spent  doing 
theorem  proving  (in  QA3.5). 

The  next  columns  of  Table  2  indicate  the 

number  of  nodes  generated  and  the  number  of  oper(cid:173)
ator  applications  both  in  the  search  tree  and 
along  the  solution  path. 
(Recall  from  Fig.  2 
that  some  successor  nodes  do  not  correspond  to 
operator  applications.)  We  see  from  these  figures 
that  the  general  search  heuristics  built  into 
STRIPS  provide  a  highly  directed  search  toward 
the  goal.  These  heuristics  presently  give  the 
search  a  large  "depth-first"  component,  and  for 
this  reason  STRIPS  obtains  an  interesting  but 
nonoptimal  solution  to  the  "turn  on  the  light-
switch"  problem. 

This  task  is  a  robot  version  of  the-  so-called 
"Monkey and  Bananas"  problem.  STRIPS  can  solve 
the  problem  even  though  the  current  SRI  robot 
is  incapable  of  climbing  boxes  and  turning  on 
lightswitches. 

The  resulting  successor  node  is  (M2,(G  ) ),  and 
thus  STRIPS  reconsiders  the  original  problem  but 
now  beginning  with  world  model  M2.  The  rest  of 
the  solution  proceeds  in  similar  fashion. 

Our  implementation  of  STRIPS  easily  produces 
the  solution  {goto(a,  c),push(BOX2, c, b),  goto(b,d), 
push( B0X3, d, b) } . 
(Incidentally,  Green's  theorem-
proving  problem-solver  (4)  has  not  been  able  to 
obtain  a  solution  to  this  version  of  the  3-Boxes 
problem. 
It  did  solve  a  simpler  version  of  the 
problem  designed  to  require  only  two  operator 
applications.) 

IV  EXAMPLE  PROBLEMS  SOLVED  BY  STRIPS 

STRIPS  has  been  designed  to  be  a  general-

purpose  problem  solver  for  robot  tasks,  and  thus 
must  be  able  to  work  with  a  variety  of  operators 
and  with  a  world  model  containing  a  large  number 
of  facts  and  relations.  This  section  describes 
its  performance  on  three  different  tasks.  The 
i n i t i al  world  model  for  a ll  three  tasks  consists 
of  a  corridor  with  four  rooms  and  doorways  (see 
Fig.  3)  and  is  described  by  the  l i st  of  axioms 
in  Table  1. 
I n i t i a l l y,  the  robot  is  in  ROOM1 
at  location  e.  Also  in  R00M1  are:  A  large  box, 
BOX1  at  location  a;  two  smaller  boxes,  BOX2  at 
location  b,  and  BOX3  at  location  c;  and  a  l i g h t-
switch,  LIGHTSWITCH1  at  location  d.  The  light-
switch  is  high  on  a  wall  out  of  normal  reach  of 
the  robot. 

616 

Session No.  15 Heuristic  Problem Solving 

R.  E.  FIKES,  N.  J.  NLSSON 

Table  1 

FORMULATION FOR  STRIPS  TASKS 

Session No.  15  Heuristic  Problem Solving 

617 

R.  F.  FIKES,  N.  J.  NILSSON 

618 

Session No.  15 Heuristic Problem Solving 

R.  E.  FIKES,  N.  J.  NILSSON 

Table  2 

PERFORMANCE OF STRIPS ON THREE TASKS 

V  FUTURE PLANS AND PROBLEMS 

The  current  implementation  of  STRIPS  can  be 

extended  in  several  directions.  These  exten(cid:173)
sions  w i ll  be  the  subject  of  much  of  our  problem-
solving  research  activities  in  the  immediate 
future.  We  mention  some  of  these  briefly. 

We  have  seen  that  STRIPS  constructs,  a  problem-

solving  tree  whose  nodes  represent  subproblems. 
In  a  problem-solving  process  of  this  sort, 
there 
must  be  a  mechanism  to  decide  which  node  to  work 
on  next.  Currently,  we  use  an  evaluation  func(cid:173)
tion  that  incorporates  such  factors  as  the  number 
and  the  estimated  d i f f i c u l ty  of  the  remaining 
subgoals, 
the  cost  of  the  operators  applied  so 
far,  and  the  complexity  of  the  current  difference. 
We  expect  to  devote  a  good  deal  of  effort  to 
devising  and  experimenting  with  various  evalua(cid:173)
tion  functions  and  other  ordering  techniques. 

Another  area  for  future  research  concerns 
the  synthesis  of  more  complex  procedures  than 
those  consisting  of  simple  linear  sequences  of 
operators.  Specifically,  we  want  to  be  able  to 
generate  procedures  involving  iteration  (or 
recursion)  and  conditional  branching. 
In  short, 
we  would  like  STRIPS  to  be  able  to  generate  com(cid:173)
puter  programs.  Several  researchers  (4),  (8),  (9) 
have  already  considered  the  problem  of  automatic 
program  synthesis  and  we  expect  to  be  able  to  use 
some  of  their  ideas  in  STRIPS. 

We  are  also  interested  in  getting  STRIPS  to 

'learn"  by  having  it  define  new  operators  for 
i t s e lf  on  the  basis  of  previous  problem  solu(cid:173)
tions.  These  new  operators  could  then  be  used 
to  solve  even  more  d i f f i c u lt  problems. 
be  important  to  be  able  to  generalize  to  param(cid:173)
eters  any  constants  appearing  in  a  new  operator, 
otherwise,  the  new  operator  would  not  be  general 
enough  to  warrant  saving.  One  approach  (10)  that 
appears  promising  is  to  modify  STRIPS  so  that  it 

It  would 

solves  every  problem  presented  to  it  in  terms  of 
generalized  parameters  rather  than  in  terms  of 
constants  appearing  in  the  specific  problem 
statements.  Hewitt  (11)  discusses  a  related 
process  that  he  calls  "procedural  abstraction." 
He  suggests  that,  from  a  few  instances  of  a 
procedure,  a  general  version  can  sometimes  be 
synthesized. 

This  type  of  learning  provides  part  of  our 

rationale  for  working  on  automatic  problem 
solvers  such  as  STRIPS.  Some  researchers  have 
questioned  the  value  of  systems  for  automatically 
chaining  together  operators 
procedures  that  themselves  could  have  been  "hand 
coded"  quite  easily  in  the  f i r st  place.  Their 
viewpoint  seems  to  be  that  a  robot  system  should 
be  provided  a  priori  with  a  repertoire  of  all 
of  the  operators  and  procedures  that  it  w i ll  ever 
need . 

into  higher-level 

Wo  agree  that  it  is  desirable  to  provide 

a  priora  a  large  number  of  specialized  operators, 
but  such  a  repertoire  w i ll  nevertheless  be  f i n i t e. 
To  accomplish  tasks  just  outside  the  boundary  of 
a  priori  abilities  requires  a  process  for  chaining 
together  existing  operators  into  more  complex  ones. 
We  are  interested  in  a  system  whose  operator 
repertoire  can  "grow"  in  this  fashion.  Clearly 
one  must  not  give  such  a  system  a  problem  too  far 
away  from  the  boundary  of  known  a b i l i t i e s,  because 
the  combinatorics  of  search  w i ll  then  make  a  solu(cid:173)
tion  unlikely.  However,  a  truly  "intelligent" 
system  ought  always  to  be  able  to  solve  slightly 
more  d i f f i c u lt  problems  than  any  it  has  solved 
before . 

ACKNOWLEDGEMENT 

The  development  of  the  ideas  embodies  in  STRIPS 

has  been  the  result  of  the  combined  efforts  of  the 
present  authors,  Bertram  Raphael,  Thomas  Garvey, 
John  Munson,  and  Richard  Waldinger,  all  members  of 

Session No.  15  Heuristic Problem Solving 

619 

R.  E.  FIKES,  N.  J.  NILSSON 

620 

Session No.  15  Heuristic  Problem Solving 

R.  E.  FIKES,  N.  J.  NILSSON 

the  A r t i f i c i al  Intelligence  Group  at  SRI. 

The  research  reported  herein  was  sponsored  by 

the  Advanced  Research  Projects  Agency  and  the 
National  Aeronautics  and  Space  Administration 
under  Contract  NAS12-2221. 

REFERENCES 

(1)  N.  J.  Nilsson,  Problem-Solving  Methods  in 
Intelligence  (McGraw-Hill  Book 

A r t i f i c i al 
Company,  New  York,  New  York,  1971). 

(2) 

J.  H.  Munson,  "Robot  Planning,  Execution, 
and  Monitoring  in  an  Uncertain  Environment," 
Proc.  2nd  I n t ' l.  Joint  Conf.  A r t i f i c i al 
Intelligence,  London,  England  (September  1-3, 
1971). 

(3)  R.  E.  Fikes,  Monitored  Execution  of  Robot 
Plans  Produced  by  STRIPS,"  Proc.  IFIP  71, 
Ljubljana,  Yugoslavia  (August  1971). 

(4)  C.  Green,  Application  of  Theorem  Proving  to 

Problem  Solving,"  Proc.  I n t ' l.  Joint  Conf. 
A r t i f i c i al 
Intelligence,  Washington,  D.C. 
(May  1969). 

(5)  B.  Raphael,  The  Frame  Problem  in  Problem-
Solving  Systems,"  Proc.  Adv.  Study  Inst,  on 
A r t i f i c i al 
Programming,  Menaggio, 

Italy  (August  1970). 
(6)  G.  Ernst  and  A.  Newell,  GPS:  A  Case  Study 

Intelligence  and  Heuristic 

in  Generality  and  Problem  Solving,  ACM 
Monograph  Series  (Academic  Press,  New  York, 
New  York  1969) . 

(7)  T.  Garvey,  and  R.  Kling,  User's  Guide  to 
QA3.5  Quest ion-Answering  System,"  Stanford 
Research  Institute  A r t i f i c i al 
Intelligence 
Group  Technical  Note  15,  Menlo  Park, 
California  (December  1969). 

(8)  R.  Waldinger  and  R.  Lee,  "PROW:  A  Step 
Toward  Automatic  Program  Writing,"  Proc. 
I n t ' l.  Conf.  A r t i f i c i al 
Washington,  D.C.  (May  1969) 

Intelligence, 

(9)  Z.  Manna  and  R.  Waldinger,  Towards  Automatic 
Program  Synthesis,"  Comm.  ACM,  Vol.  14,  No.  3, 
(March  1971) . 

(10)  P.  E.  Hart  and  N.  J.  Nilsson,  "The  Construc(cid:173)

tion  of  Generalized  Plans  as  an  Approach 
Toward  Learning,"  Stanford  Research  Institute 
A r t i f i c i al  Intelligence  Group  Memo,  Menlo 
Park,  California  (5  April  1971). 

(11)  C.  Hewitt,  "PLANNER:  A  Language  for  Manip(cid:173)

ulating  Models  and  Proving  Theorems  in  a 
Robot,"  A r t i f i c i al  Intelligence  Memo  No.  168 
(Revised),  Project  MAC,  Massachusetts 
Institute  of  Technology,  Cambridge,  Massa(cid:173)
chusetts  (August  1970). 

