Semantics for a useful fragment of the situation calculus

Gerhard Lakemeyer

Dept. of Computer Science

RWTH Aachen
52056 Aachen

Germany

gerhard@cs.rwth-aachen.de

Abstract

In a recent paper, we presented a new logic called
ES for reasoning about the knowledge, action, and
perception of an agent. Although formulated using
modal operators, we argued that the language was
in fact a dialect of the situation calculus but with
the situation terms suppressed. This allowed us to
develop a clean and workable semantics for the lan-
guage without piggybacking on the generic Tarski
semantics for (cid:2)rst-order logic. In this paper, we re-
consider the relation between ES and the situation
calculus and show how to map sentences of ES into
the situation calculus. We argue that the fragment
of the situation calculus represented by ES is rich
enough to handle the basic action theories de(cid:2)ned
by Reiter as well as Golog. Finally, we show that
in the full second-order version of ES, almost all of
the situation calculus can be accommodated.

1 Introduction
In a recent paper, we [Lakemeyer and Levesque, 2004] pre-
sented a new logic called ES for reasoning about the knowl-
edge, action, and perception of an agent. Our main justi(cid:2)ca-
tion for introducing yet another knowledge representation for-
malism was twofold. First, we claimed that the language was
not a new formalism at all, but merely a situation-suppressed
version of part of the situation calculus, as originally pre-
sented by McCarthy and Hayes [McCarthy and Hayes 1969]
and subsequently formalized by Reiter [Reiter 2001a]. Sec-
ond, we claimed that because the language was de(cid:2)ned se-
mantically rather than axiomatically, certain mathematical ar-
guments about the formalism were considerably simpler than
in the original situation calculus. We presented evidence for
this by showing a very compact proof of the correctness of
Reiter’s regression operator, and another involving a property
called the determinacy of knowledge.

However, our (cid:2)rst claim, which was that ES is in fact just
an alternate way of writing some formulas of the situation
calculus, was left unsubstantiated. In this paper, we remedy
this. The main result we prove is the correctness of a simple
mapping between sentences of ES and their counterparts in
the classical language of the situation calculus. In addition,
we show that the fragment of the situation calculus expressed

Hector J. Levesque

Dept. of Computer Science

University of Toronto

Toronto, Ontario
Canada M5S 3A6
hector@cs.toronto.edu

by ES is rich enough to handle (among other things) basic ac-
tion theories (as de(cid:2)ned by Reiter) and the Do operator which
is the basis of the Golog language [Levesque et al. 1997]. We
also illustrate this richness more informally using an exam-
ple involving the knowledge, action, and sensing of a simple
robot. However, there are sentences of the situation calcu-
lus that cannot be expressed directly in ES, and which may
be useful in some contexts. In the (cid:2)nal part of the paper, we
show that if we are prepared to use second-order quanti(cid:2)ca-
tion, there is a way to encode (almost) every sentence of the
situation calculus in ES. This encoding is a bit of a trick,
and not something we advocate for everyday use. But it does
exist. So we gain the clarity that comes from having a real
semantic basis, and the ability to present concise semantic ar-
guments, without any signi(cid:2)cant loss of expressiveness.

The rest of the paper is organized as follows. In the next
section, we de(cid:2)ne the full language of ES, its syntax and
semantics. This generalizes the version of ES presented in
[Lakemeyer and Levesque, 2004] in a variety of ways, the
most important of which is that it allows functions, predi-
cates, and second-order variables that are ﬂuent (vary from
situation to situation) as well as rigid ((cid:2)xed for all situations).
In Section 3, we consider the mapping from ES to the situa-
tion calculus and prove that a sentence of ES is valid iff its
mapping is a logical entailment of a suitable situation calcu-
lus theory. In Section 4, we consider the expressiveness of
ES, (cid:2)rst with an example basic action theory and then with
Do. In Section 5, we consider the inverse mapping from the
situation calculus to ES, followed by some remarks on related
work and conclusions. Then we stop.

2 The language: syntax and semantics
The full language ES consists of formulas over symbols from
the following vocabulary:

(cid:15) (cid:2)rst-order variables: x1; x2; : : : ; y1; y2; : : : ; a1; a2; : : :;
(cid:15) (cid:3)uent second-order variables of arity k: P k
(cid:15) rigid second-order variables of arity k: Qk
(cid:15) standard names: n1; n2; : : :;
(cid:15) (cid:3)uent function symbols of arity k: f k

2 ; : : :;
2; : : :;

1 ; P k
1; Qk

1 ; f k

2 ; : : :;

for example, location, bestAction;

(cid:15) rigid function symbols of arity k: gk

1 ; gk

2 ; : : :;

for example, block5, repair;

(cid:15) (cid:3)uent predicate symbols of arity k: F k

1 ; F k

2 ; : : :;

for example, Broken;1

(cid:15) rigid predicate symbols of arity k: Gk

1; Gk

2; : : :;

for example, Fragile;

(cid:15) connectives and other symbols: =, ^, :, 8, Know, (cid:3),

round and square parentheses, period, comma.

We assume that (cid:2)rst-order variables, standard names, and
function symbols come in two sorts, action (like repair and
bestAction) and object (like block5 and location). Constants
are function symbols of 0 arity.2 We let N denote the set of
all standard names and Z denote the set of all sequences of
standard names for actions, including h i, the empty sequence.
2.1 Terms and formulas
The terms of the language are of sort action or object, and
form the least set of expressions such that

1. Every standard name and (cid:2)rst-order variable is a term of

the corresponding sort;

2. If t1, . . . , tk are terms and h is a k-ary function symbol

then h(t1; : : : ; tk) is a term of the same sort as h.

By a primitive term we mean one of the form h(n1; : : : ; nk)
where h is a ((cid:3)uent or rigid) function symbol and all of the
ni are standard names.
The well-formed formulas of the language form the least set
such that

1. If t1, . . . , tk are terms, and H is a k-ary predicate symbol

then H(t1; : : : ; tk) is an (atomic) formula;

2. If t1, . . . , tk are terms, and V is a k-ary second-order

variable, then V (t1; : : : ; tk) is an (atomic) formula;
3. If t1 and t2 are terms, then (t1 = t2) is a formula;
4. If t is an action term and (cid:11) is a formula, then [t](cid:11) is a

formula;

5. If (cid:11) and (cid:12) are formulas, v is a (cid:2)rst-order variable, and
V is a second-order variable, then the following are also
formulas: ((cid:11) ^ (cid:12)); :(cid:11); 8v: (cid:11); 8V: (cid:11); (cid:3)(cid:11); Know((cid:11)).
We read [t](cid:11) as (cid:147)(cid:11) holds after action t(cid:148), and (cid:3)(cid:11) as (cid:147)(cid:11) holds
after any sequence of actions.(cid:148) As usual, we treat ((cid:11) _ (cid:12));
((cid:11) (cid:27) (cid:12)); ((cid:11) (cid:17) (cid:12)); 9v: (cid:11); and 9V: (cid:11) as abbreviations. We
call a formula without free variables a sentence. By a primi-
tive sentence we mean a formula of the form H(n1; : : : ; nk)
where H is a ((cid:3)uent or rigid) predicate symbol and all of the
ni are standard names.
2.2 The semantics
The language contains both (cid:3)uent and rigid expressions. The
former vary as the result of actions and have values that may
be unknown, but the latter do not. Intuitively, to determine
whether or not a sentence (cid:11) is true after a sequence of ac-
tions z has been performed, we need to specify two things: a
world w and an epistemic state e. We write e; w; z j= (cid:11): A

1We assume this list includes the predicates Poss and SF.
2The standard names can be thought of as special extra constants
that satisfy the unique name assumption and an in(cid:2)nitary version of
domain closure.

world determines truth values for the primitive sentences and
co-referring standard names for the primitive terms after any
sequence of actions. An epistemic state is de(cid:2)ned by a set of
worlds, as in possible-world semantics. More precisely:

(cid:15) a world w 2 W is any function from the primitive sen-
tences and Z to f0; 1g, and from the primitive terms and
Z to N (preserving sorts), and satisfying the rigidity
constraint:
if r is a rigid function or predicate symbol,
then w[r(n1; : : : ; nk); z] = w[r(n1; : : : ; nk); z0]; for all
z and z0 in Z:

(cid:15) an epistemic state e (cid:18) W is any set of worlds.

We extend the idea of co-referring standard names to arbitrary
ground terms as follows. Given a term t without variables, a
world w, and an action sequence z, we de(cid:2)ne jtjz
w (read: the
co-referring standard name for t given w and z) by:

1. If t 2 N , then jtjz
2. jh(t1; : : : ; tk)jz

w = t;

w = w[h(n1; : : : ; nk); z];

where ni = jtijz
w.

To interpret formulas with free variables, we proceed as fol-
lows. First-order variables are handled substitutionally using
the standard names. To handle the quanti(cid:2)cation over second-
order variables, we use second-order variable maps de(cid:2)ned
as follows:

The second-order primitives are formulas of the
form V (n1; : : : ; nk) where V is a ((cid:3)uent or rigid)
second-order variable and all of the ni are stan-
dard names. A variable map u is a function from
worlds, second-order primitives, and Z to f0; 1g;
satisfying the rigidity constraint:
if Q is a rigid
second-order variable, then for all w and w0 in W;
and all z and z0 in Z, u[w; Q(n1; : : : ; nk); z] =
u[w0; Q(n1; : : : ; nk); z0]:

Let u and u0 be variable maps, and let V be a ((cid:3)uent or rigid)
second-order variable; we write u0 (cid:24)V u to mean that u and
u0 agree except perhaps on the second-order primitives in-
volving V . Finally, to interpret what is known after a se-
quence of actions possibly including sensing has taken place,
we de(cid:2)ne w0 ’z w (read: w0 and w agree on the sensing
throughout action sequence z) inductively by the following:

1. w0 ’h i w iff w0 and w agree on the value of

every primitive rigid term and sentence;

2. w0 ’z(cid:1)n w iff

w0 ’z w and w0[SF(n); z] = w[SF(n); z].

Putting all these together, here is the semantic de(cid:2)nition of
truth. Given e (cid:18) W and w 2 W , we de(cid:2)ne e; w j= (cid:11) (read:
(cid:11) is true) as e; w; h i j= (cid:11), where for any z 2 Z and any
second-order variable map u:

1. e; w; z; u j= H(t1; : : : ; tk) iff

w[H(n1; : : : ; nk); z] = 1, where ni = jtijz
w;

2. e; w; z; u j= V (t1; : : : ; tk) iff

u[w; V (n1; : : : ; nk); z] = 1, where ni = jtijz
w;

3. e; w; z; u j= (t1 = t2) iff

n1 and n2 are identical, where ni = jtijz
w;

4. e; w; z; u j= [t](cid:11) iff e; w; z (cid:1)n; u j= (cid:11), where n = jtjz
w;

5. e; w; z; u j= ((cid:11) ^ (cid:12)) iff

e; w; z; u j= (cid:11) and e; w; z; u j= (cid:12);
6. e; w; z; u j= :(cid:11) iff e; w; z; u 6j= (cid:11);
7. e; w; z; u j= 8v: (cid:11) iff e; w; z; u j= (cid:11)x
n;

for every standard name n (of the same sort as v);

8. e; w; z; u j= 8V: (cid:11) iff

e; w; z; u0 j= (cid:11); for every u0 (cid:24)V u;

9. e; w; z; u j= (cid:3)(cid:11) iff

e; w; z (cid:1) z0; u j= (cid:11); for every z0 2 Z;

10. e; w; z; u j= Know((cid:11)) iff

e; w0; z; u j= (cid:11); for every w0 2 e such that w0 ’z w.
When (cid:11) is objective (has no Know operators), we can leave
out the e and write w j= (cid:11). When (cid:6) is a set of sentences and
(cid:11) is a sentence, we write (cid:6) j= (cid:11) (read: (cid:6) logically entails
(cid:11)) to mean that for every e and w, if e; w j= (cid:11)0 for every
(cid:11)0 2 (cid:6), then e; w j= (cid:11): Finally, we write j= (cid:11) (read: (cid:11) is
valid) to mean fg j= (cid:11).

3 Mapping to the situation calculus
How do we know that the semantics of ES is correct? In this
section, we argue that it is indeed correct by showing how
formulas (cid:11) in ES can be translated in a direct way to formulas
(cid:11)(cid:3) in the situation calculus as de(cid:2)ned by Reiter.3

The most desirable and simplest outcome of this translation
would be that j= (cid:11) iff (cid:6) j=FOL (cid:11)(cid:3); where j= is validity
in ES, (cid:6) is the set of foundational axioms of the situation
calculus (see [Levesque et al, 1998], for example), and j=FOL
is ordinary classical logical consequence. Unfortunately, we
do not get exactly this correspondence for a variety of reasons
we will discuss below. But we do get something close:

j= (cid:11) iff (cid:6) [ (cid:7) j=FOL (cid:11)(cid:3);

where (cid:7) is a set of four axioms that we will justify separately.
To prove this result it will be necessary to work with or-
dinary Tarski models of sentences of the situation calculus.
As argued in [Lakemeyer and Levesque, 2004], this is dif(cid:2)-
cult and painstaking, and is indeed one of the main reasons to
prefer ES over the situation calculus. So while the proof of
the theorem is quite laborious, we remind the reader that this
can be thought of as a (cid:2)nal reckoning for a formalism that is
unworkable semantically. For space reasons, we do not re-
view the conventional notation used for talking about Tarski
interpretations, denotations, extensions, variable maps. See,
for example, [Enderton 1972].
3.1 Deﬁnition of the translation
Before describing (cid:7), we present the translation from ES
into the situation calculus. In the simplest case, the idea is
that a formula like Broken(c); where Broken is a (cid:3)uent, will
3We assume that this language has functional and relational (cid:3)u-
ents, functions and predicates that are not (cid:3)uents, the distinguished
constant S0, function do, predicates v, Poss and SF, and a two-place
predicate K for knowledge. We take Knows((cid:11); (cid:27)) in the situation
calculus as an abbreviation for the formula 8s(K(s; (cid:27)) (cid:27) (cid:11)now
),
where (cid:11)now
is the result of replacing by s in (cid:11) every occurrence of
now that is not within the scope of a further Knows.

s

s

be mapped to the situation calculus formula Broken(c; S0),
where we have restored the distinguished situation term
S0 for the (cid:3)uent. Similarly, [repair(c)]:Broken(c) will be
mapped to :Broken(c; do(repair(c); S0)). So ES formulas
can be thought of as (cid:147)situation-suppressed(cid:148) (in situation-
calculus terminology) and the (cid:3) mapping restores the situa-
tion argument to the (cid:3)uents, leaving the rigids unchanged.

More precisely, we have the following:

Deﬁnition 3.1 Let (cid:11) be any term or formula of ES without
standard names. The expression (cid:11)(cid:3) is deﬁned as (cid:11)[S0] where,
for any situation term (cid:27), (cid:11)[(cid:27)] is deﬁned inductively by:

1. v[(cid:27)], where v is a ﬁrst-order variable, is v;
2. g(t1; : : : ; tk)[(cid:27)], where g is a rigid function, predicate,

or second-order variable, is g(t1[(cid:27)]; : : : ; tk[(cid:27)]);

3. f (t1; : : : ; tk)[(cid:27)], where f is a ﬂuent function, predicate,

or second-order variable is f (t1[(cid:27)]; : : : ; tk[(cid:27)]; (cid:27));

is :(cid:11)[(cid:27)];

is (t1[(cid:27)] = t2[(cid:27)]);

is (cid:11)[do(t[(cid:27)]; (cid:27))];
is ((cid:11)[(cid:27)] ^ (cid:12)[(cid:27)])

4. (t1 = t2)[(cid:27)]
5. ([t](cid:11))[(cid:27)]
6. ((cid:11) ^ (cid:12))[(cid:27)]
7. (:(cid:11))[(cid:27)]
8. (8v: (cid:11))[(cid:27)]
9. (8V: (cid:11))[(cid:27)]
10. ((cid:3)(cid:11))[(cid:27)]
11. Know((cid:11))[(cid:27)]
Note that the translation of (cid:3)(cid:11) introduces quanti(cid:2)cation over
situations, where the introduced variable s0 is assumed to be
one that does not appear in situation term (cid:27).

is 8v: (cid:11)[(cid:27)];
is 8V: (cid:11)[(cid:27)].

is 8s0((cid:27) v s0 (cid:27) (cid:11)[s0]);

is Knows((cid:11)[now]; (cid:27)).

3.2 The situation-calculus axioms (cid:7)
The axioms we assume in (cid:7) are the following:
1. domain of objects is countably in(cid:2)nite;4
2. domain of actions is countably in(cid:2)nite (as above);
3. equality is the identity relation:

8x8y: (x = y) (cid:17) 8Q(Q(x) (cid:17) Q(y)):

4. the K predicate:5 8s(K(s; S0) (cid:27) Ini(s)) ^
8s08s: K(s0; s) (cid:17) 8P (: : : (cid:27) P (s0; s));

where the ellipsis stands for the universal closure of

[K(s1; S0) ^ Ini(s2) (cid:27) P (s1; s2)] ^
[P (s1; s2) ^ SF(a; s1) (cid:17) SF(a; s2) (cid:27)

P (do(a; s1); do(a; s2))]:

Axioms (1) and (2) talk about the cardinality of the set of
objects and actions respectively: they are both countable and
in(cid:2)nite. The countability aspect is not very controversial. In
the (cid:2)rst-order case, every satis(cid:2)able set of sentences is satis-
(cid:2)able in a countable domain, and we do not expect users of
the situation calculus to use second-order logic to defeat this.
Note that this does not rule out having theories that talk about
4For space reasons, we omit the formula of second-order logic

that (cid:2)xes the cardinality of the domain of objects and actions.

5We let Ini(t) be an abbreviation for the situation calculus for-
mula 8a8s(t 6= do(a; s)). In this version of the axiom, we ignore
the correspondence between K and Poss.

real numbers or other continuous phenomena; it simply rules
out using second-order logic to force the interpretations of
these theories to be uncountable. We can, however, imagine
contexts where (cid:2)niteness might be desirable. In such cases,
we can introduce a new predicate O and instead of assert-
ing that there are (cid:2)nitely many objects, assert that there are
(cid:2)nitely many objects in O.

As for axiom (3), it is hard imagining anyone taking the
negation of this one seriously. The usual (cid:2)rst-order axiomati-
zation of equality is often enough, but the intent is invariably
for the equality symbol to be understood as the identity rela-
tion, which this second-order axiom ensures.

Finally axiom (4) is a second order de(cid:2)nition of the K
predicate in terms of the value it has at S0. This is just an-
other way of capturing the successor state axiom for K in-
troduced by Scherl and Levesque [2003], and the added ma-
chinery to make Knows be a weak-S5 operator [Hughes and
Cresswell, 1968]. Other knowledge operators are possible in
the situation calculus, but weak-S5 and its extensions (such
as strong-S5) are the most often used.
3.3 The embedding theorem
What we show is that provided certain properties hold be-
tween a Tarski structure on one side and an epistemic state,
and a collection of worlds on the other, sentences will be true
in ES iff their translations are true in the Tarski structure.

Let M be a Tarski structure for the situation calculus over
the domain D = Dsit [ Dact [ Dobj , with Dini (cid:18) Dsit as
the set of initial situations, and with (cid:19)0 = SM
0 2 Dini. Let
e be an epistemic state, and assume that we are given three
mappings ! 2 [Dini ! W ], (cid:18) 2 [N ! Dact [ Dobj ], and
(cid:25) 2 [Z (cid:2) Dini ! Dsit ]: These mappings need to satisfy
various consistency properties that we cannot enumerate here.
But we can at least quote the lemma that uses them:
Lemma 3.2 Let (cid:11) be a formula of ES with no standard
names and whose free variables are among x1; : : : ; xm.
Then, given the consistency properties, for any variable map
(cid:22), the ES variable map u(cid:22) (deﬁned in terms of (cid:22)), any vari-
able s, any z 2 Z, any (cid:19) 2 Dini ; and w = !((cid:19)),

e; w; z; u(cid:22) j= (cid:11)x1

n1 : : :xm
nm

iff

M; (cid:22)fx1=(cid:18)(n1); : : : ; xm=(cid:18)(nm); s=(cid:25)(z; (cid:19))g j= (cid:11)[s]:

This is proved by a (long) induction on the structure of (cid:11). The
main result is then the following:
Theorem 3.3 Let (cid:11) be any sentence of ES without standard
names. Then (cid:11) is valid iff (cid:6) [ (cid:7) j=FOL (cid:11)(cid:3):
Proof: (Sketch) First assume that (cid:11) is not valid. Then there
is an e, w0 such that e; w0 6j= (cid:11). We de(cid:2)ne a Tarski structure
M whose domain is D = Dobj [ Dact [ Dsit, where Dobj
(resp. Dact) is the set of standard names of objects (resp. ac-
tions), and Dsit = Z (cid:2) W . Then we de(cid:2)ne =M, SM
0 , doM,
vM, KM; as well as the extension of every rigid and (cid:3)uent
predicate and function symbol using e and w0 in a way that
ensures that M satis(cid:2)es (cid:6) [ (cid:7). Next, de(cid:2)ne the mappings (cid:18),
(cid:25); and ! by letting (cid:18)(n) = n, and for any initial (cid:19) = (h i; w),
letting (cid:25)(z; (cid:19)) = (z; w), and !((cid:19)) = w. This ensures that the

sonar

....................
....................
.....................

(cid:12)(cid:15)
(cid:3)(cid:2)

forward

(cid:27)

-

backward

f f

5

Close

10

-

Figure 1: A simple robot

(cid:27)

properties needed for Lemma 3.2 are satis(cid:2)ed, and therefore
M 6j= (cid:11)(cid:3). Consequently, (cid:6) [ (cid:7) 6j=FOL (cid:11)(cid:3):
Conversely, assume that (cid:6) [ (cid:7) 6j=FOL (cid:11)(cid:3). Then there is a
Tarski structure M that satis(cid:2)es (cid:6)[(cid:7) but such that M 6j= (cid:11)(cid:3).
The domain D must be Dsit [ Dact [ Dobj , with Dini (cid:18) Dsit
as the set of initial situations, and with (cid:19)0 = SM
0 2 Dini.
Since M j= (cid:7), both Dobj and Dact are countably in(cid:2)nite,
Dobj = f(cid:14)1; (cid:14)2; : : :g, and Dact = f(cid:21)1; (cid:21)2; : : :g: We de(cid:2)ne (cid:18)
to map the i-th standard name for objects to (cid:14)i and analogous-
ly for actions. We then de(cid:2)ne (cid:25) using doM, and ! using the
extensions of the function and predicate symbols given by M.
Finally, we let e = f!((cid:19)) j ((cid:19); (cid:19)0) 2 KMg; and w0 = !((cid:19)0).
These ensure that the properties needed for Lemma 3.2 are
satis(cid:2)ed, and so e; w0 6j= (cid:11). Consequently, (cid:11) is not valid.

4 The expressiveness of the language
Now that we have established that ES is actually a disguised
fragment of the situation calculus, we next consider the ex-
pressiveness of this fragment, starting with a simple example
problem, adapted from [Levesque and Lakemeyer 2001].

Imagine a robot that lives in a 1-dimensional world, and
that can move towards or away from a (cid:2)xed wall. The robot
also has a sonar sensor that tells it when it gets close to the
wall, say, less than 10 units away. See Figure 1. So we might
imagine three actions, forward and backward which move the
robot one unit towards and away from the wall, and a sonar
sensing action which tells the robot if it is close to the wall.
Each of these is a rigid constant, but for simplicity, we will
simply assume that they are standard names. We have a sin-
gle (cid:3)uent, distance; which gives the actual distance from the
robot to the wall. We can use Close as an abbreviation for the
formula (cid:147)distance < 10:(cid:148) 6 We begin our formalization by
writing preconditions for the three actions:

8a (cid:3) Poss(a) (cid:17)

a = forward ^ distance > 0 _
a = backward ^ TRUE _
a = sonar ^ TRUE:

Next, we de(cid:2)ne the sensing results for the actions:

8a (cid:3) SF(a) (cid:17)

a = forward ^ TRUE _
a = backward ^ TRUE _

6Here and below, we use simple arithmetic involving <; +; and
(cid:0); which can easily be de(cid:2)ned in second-order terms with the stan-
dard names acting as natural numbers. We omit the details.

a = sonar ^ Close:

Finally, we write a successor state axiom for our only (cid:3)uent:

8a; x (cid:3) [a](distance = x) (cid:17)

a = forward ^ distance = x + 1 _
a = backward ^ distance = x (cid:0) 1 _
a 6= forward ^ a 6= backward ^ distance = x:

Now we are ready to consider some speci(cid:2)cs having to do
with what is true initially by de(cid:2)ning an action theory (cid:6): Let
(cid:30) denote the conjunction of the sentences above. We assume
that (cid:30) is true and the robot knows it. We also assume the
robot is located initially 6 units away from the wall, but that
the robot has no idea where it is. So, we let (cid:6) be
f(cid:30); Know((cid:30)); distance = 6; 8x:Know(distance 6= x)g;
and we get this:
Theorem 4.1 The following are logical entailments of (cid:6):
1. Close ^ :Know(Close) ^ [forward] :Know(Close)

the robot is close to the wall, but does not know it, and
continues not to know it after moving forward;

2. [sonar] (Know(Close) ^ [forward]Know(Close))

after reading the sonar, the robot knows it is close, and
continues to know it after moving forward;

3. [sonar] [backward] :Know(Close)

after reading the sonar and then moving backward, the
robot no longer knows that it is close to the wall;

4. [backward] [sonar] Know(Close)

after moving backward and then reading the sonar, the
robot knows that it is close to the wall;

5. [sonar] [forward] [backward] Know(Close)

after reading the sonar, moving forward, and then back-
ward, the robot knows that it is still close to the wall;

6. [sonar] Know([forward] Close)

after reading the sonar, the robot knows that it will re-
main close after moving forward;

7. :Know([sonar] Know(Close))

the robot does not know initially that it will know that it
is close after reading the sonar;

8. Know([sonar] (Know(Close) _ Know(:Close)))

the robot does know initially that after reading the sonar,
it will then know whether or not it is close to the wall;

9. Know([sonar] [backward] :Know(Close))

the robot knows initially that it will not know that it is
close after reading the sonar and moving backwards.

The proofs of these are similar. Here we will only
Proof:
do item 3. Let z = hsonar (cid:1) backwardi; and suppose that
e; w j= (cid:6); we must show that e; w; z j= :Know(Close). Be-
cause e; w j= :Know(distance 6= 9); there exists w0 2 e such
that w0 ’h i w and w0[distance; h i] = 9: Since 9 < 10, we
also have that w0 ’z w. However, w0[distance; z] = 10: So
there exists w0 2 e such that w0 ’z w and w0; z j= :Close:
Therefore, e; w; z j= :Know(Close).

Although we will not attempt to formulate a theorem here, it
should be clear from this example that any basic action theory
[Reiter 2001a] including those involving the Scherl-Levesque
knowledge operator can be expressed in ES.

4.1 The Do operator
We now turn our attention to the Do operator which is the ba-
sis of the Golog language [Levesque et al. 1997], and show
that a variant of Do can be represented in ES. We cannot en-
code Do((cid:14); s; s0) directly since we do not have situations as
terms. Instead we will use D˜o((cid:14); (cid:11)) which intuitively means
that (cid:11) holds after doing Golog program (cid:14). There are two pos-
sible readings: one says that (cid:11) holds in all (cid:2)nal states, and the
other says that (cid:11) holds in some (cid:2)nal state. They can be inter-
de(cid:2)ned, so we consider only the latter. We treat D˜o((cid:14); (cid:11)) as
an abbreviation for a formula of ES, de(cid:2)ned recursively on
the (cid:14) as follows:

def

= (Poss(a) ^ [a](cid:11));

def

= ((cid:30) ^ (cid:11));

1. for any action a, D˜o(a; (cid:11))
2. D˜o((cid:30)?; (cid:11))
3. D˜o((cid:14) ; (cid:14)0; (cid:11))
4. D˜o((cid:14) j (cid:14)0; (cid:11))
5. D˜o((cid:25)x: (cid:14); (cid:11))
6. D˜o((cid:14)(cid:3); (cid:11))

def
=

def

def

= D˜o((cid:14); D˜o((cid:14)0; (cid:11)));
= (D˜o((cid:14); (cid:11)) _ D˜o((cid:14)0; (cid:11)));
= 9x: D˜o((cid:14); (cid:11));

def

8P: f(cid:3)((cid:11) (cid:27) P ) ^ (cid:3)(D˜o((cid:14); P ) (cid:27) P )g (cid:27) P .

As usual, we can de(cid:2)ne while-loops and if-then-else as ab-
breviations. The main theorem that we state here is that this
account of D˜o is correct relative to the original account of Do
and the mapping from ES de(cid:2)ned above:
Theorem 4.2 Let (cid:14) be any program, (cid:11) be any sentence of ES,
and (cid:27) be any situation term of the situation calculus.
Then j=FOL D˜o((cid:14); (cid:11))[(cid:27)] (cid:17) 9s: Do((cid:14); (cid:27); s) ^ (cid:11)[s]:
This is proved by induction over (cid:14), the only troublesome case
being for the nondeterministic iteration, (cid:14)(cid:3).

5 Mapping from the situation calculus
When mapping the situation calculus into ES, the main issue
is the treatment of quanti(cid:2)ed situations. While simple formu-
las can be translated using the inverse of (cid:3) from Section 3, a
sentence like 8s9s0:s v s0 ^ (s 6= s0) ^ F (s) (cid:17) F (s0), which
says that from every situation another situation is reachable
that agrees on the truth value of F; has no counterpart in ES.
To deal with situation-calculus sentences like these, our
proposal is to encode action sequences in second-order ES.
Let nil be a (rigid) constant and seq a (rigid) binary function
symbol of ES. We de(cid:2)ne ActionSeq(x) as an abbreviation for

8Q: Q(nil) ^ 8y; a:(Q(a) (cid:27) Q(seq(a; y))) (cid:27) Q(x):

In the situation calculus, a (cid:3)uent like F (do((cid:11); do((cid:12); S0)))
actually means that F holds after doing (cid:12) then (cid:11). So the
actions are in reverse order in a situation term. It is therefore
useful to be able to reverse a sequence as follows:
Deﬁnition 5.1 Rev(x; y)
the ellipsis stands for the universal closure of

def
= 8R(: : : (cid:27) R(x; nil; y)), where

R(nil; x; x) ^ [R(x; seq(a; y); z) (cid:27) R(seq(a; x); y; z)]:

Next we de(cid:2)ne what it means for a formula (cid:11) to be true after
a sequence of actions.

Deﬁnition 5.2 After(s; (cid:11))
ellipsis stands for the universal closure of

def
= 8P:(: : : (cid:27) P (s)) where the

10. (8s:(cid:27) v s (cid:27) (cid:11))(cid:15) is

8s(cid:15): ActionSeq(s(cid:15)) ^ (cid:27)(cid:15) (cid:20) s(cid:15) (cid:27) (cid:11)(cid:15));

(cid:3)f((cid:11) (cid:27) P (nil)) ^ ([a]P (x) ^ Rev(seq(a; x); y) (cid:27) P (y))g:
The (cid:3)uent :Broken(do(repair; do(drop; S0))) will then be
translated as After(seq(repair; seq(drop; nil)); :Broken). In
order to deal with quanti(cid:2)cation over situations, we de(cid:2)ne (cid:20)
as a relation over action sequences, similar to the situation
calculus relation v.
Deﬁnition 5.3 (x (cid:20) x0)
ellipsis stands for the universal closure of

def
= 8Q:(: : : (cid:27) Q(x; x0)) where the

Q(nil; x) ^ (Q(x; y) (cid:27) Q(seq(a; x); seq(a; y))):

The formula 8s9s0:s v s0 ^ (s 6= s0) ^ F (s) (cid:17) F (s0) of the
situation calculus will then be translated as

8x: ActionSeq(x) (cid:27) 9x0: ActionSeq(x0) ^

(x (cid:20) x0) ^ (x 6= x0) ^ [After(x; F ) (cid:17) After(x0; F )]:

The (cid:2)nal problem we must deal with concerns unrestricted
quanti(cid:2)cation over initial situations. To simplify things, we
restrict ourselves to SC r, the rooted situation calculus, where
all situation quanti(cid:2)cation is of the form 8s: (cid:27) v s (cid:27) (cid:11), for
some situation term (cid:27). Note that this is no restriction at all for
the non-epistemic situation calculus, since 8s:(cid:11) is equivalent
to 8s:S0 v s (cid:27) (cid:11). We handle the Knows operator separately.
To ease the translation, we assume that situation-calculus
formulas are in the following normal form: all arguments of
predicates and functions are variables; equality expressions
have the form (x = t), where x is a variable and t is a term
mentioning at most 1 function symbol. It is easy to show that
every formula of SC r is equivalent to one in this normal form.
The mapping from the situation calculus into ES begins
with a mapping (cid:15) from situation terms into sequences of
actions in ES. We assume that there is a countably in(cid:2)-
nite set Vs of extra object variables in ES for this purpose.
For any situation variable s; we assume that s(cid:15) 2 Vs and
that (cid:15) is 1-to-1 and onto wrt Vs when restricted to situation
variables. We also have that S (cid:15)
0 = now(cid:15) = nil, and that
do(a; s)(cid:15) = seq(a; s(cid:15)). We extend (cid:15) to formulas as follows:
Deﬁnition 5.4 Let (cid:11) be any formula of SC r in normal form.
Then its translation into ES, (cid:11)(cid:15); is deﬁned inductively by:

1. G(x1; : : : ; xk)(cid:15), where G is a rigid predicate or rigid

second-order variable, is G(x1; : : : ; xk);

2. F (x1; : : : ; xk; s)(cid:15), where F is a ﬂuent predicate or ﬂu-
ent second-order variable, is After(s(cid:15); F (x1; : : : ; xk));
3. (x = g(x1; : : : ; xk))(cid:15), where g is a rigid function, is

(x = g(x1; : : : ; xk));

4. (x = f (x1; : : : ; xk; s))(cid:15), where f is a ﬂuent function, is

After(s(cid:15); x = f (x1; : : : ; xk));

5. (s = (cid:27))(cid:15) is (s(cid:15) = (cid:27)(cid:15));
6. ((cid:27)1 v (cid:27)2)(cid:15) is ((cid:27)(cid:15)
1 (cid:20) (cid:27)(cid:15)
7. (:(cid:11))(cid:15) is :(cid:11)(cid:15);
8. ((cid:11) ^ (cid:12))(cid:15) is (cid:11)(cid:15) ^ (cid:12)(cid:15);
9. (8x:(cid:11)) is 8x:(cid:11)(cid:15) for an object or action variable x;

2 );

11. (8V:(cid:11))(cid:15) is 8V:(cid:11)(cid:15) for a second-order variable V ;

12. Knows((cid:11); s)(cid:15) is After(s(cid:15); Know((cid:11)(cid:15))).
To show correctness of the translation, we need two more
axioms (cid:9), which are the universal closure of the following:

seq(a; x) 6= nil;
seq(a; x) = seq(a0; x0) (cid:27) a = a0 ^ x = x0:

Theorem 5.5 Let (cid:11) be a sentence of SC r in normal form.
Then (cid:6) [ (cid:7) j=FOL (cid:11) iff (cid:9) j= (cid:11)(cid:15):

6 Related Work
The situation calculus, which has been the sole focus of this
paper, is of course not the only language for reasoning about
action. Over the years, there have been many other propos-
als such as the event calculus [Kowalski and Sergot 1986],
Sandewall’s features and (cid:3)uents [Sandewall 1994], the lan-
guage A [Gelfond and Lifschitz 1993], or the (cid:3)uent calcu-
lus [H¤olldobler and Schneeberger 1990], to name but a few.
What distinguishes the situation calculus perhaps most from
its alternatives is that it admits an elegant monotonic solution
to the frame problem [Reiter 1991], which is shared by its
close relative, the (cid:3)uent calculus [Thielscher 1999]. How-
ever, the (cid:3)uent calculus also has situation terms as part of
the language and hence suffers from the same shortcomings
which ES tries to address.

ES itself has much in common with dynamic logic [Pratt
1976; Harel 1984], which has also been applied to reason-
ing about action [Castilho, Gasquet, and Herzig 1999]. A
new feature of ES, compared to dynamic logic, are quanti(cid:2)ed
modalities as in 8a:[a](cid:11), which are key in expressing succes-
sor state axioms, among other things.

Dynamic logic has been combined with epistemic
logic [Herzig et al. 2000; Demolombe 2003].
In the lan-
guage of [Herzig et al. 2000], it is possible to express things
like [backward] [sonar] Know(Close) using an almost iden-
tical syntax and where Know also has a possible-world se-
mantics. Despite such similarities, there are signi(cid:2)cant dif-
ferences, however. In particular, their language is proposi-
tional. Consequently, there is no quanti(cid:2)cation over actions.
Demolombe (2003) proposes an axiomatic translation of parts
of the epistemic situation calculus into modal logic. While his
modal language is (cid:2)rst-order, he does not consider quanti(cid:2)ed
modalities.

Although they do not consider epistemic notions, the work
by [Blackburn et al. 2001] is relevant as it reconstructs a ver-
sion of the situation calculus in Hybrid Logic [Blackburn et
al. 2001], a variant of modal logic which was inspired by the
work on tense logic by Prior [Prior 1967]. In a sense, though,
this work goes only part of the way as an explicit reference
to situations within the logic is retained. To us this presents
a disadvantage when moving to an epistemic extension. The
problem is that the epistemic situation calculus requires us
to consider uncountably many situations, which precludes a
substitutional interpretation of quanti(cid:2)cation.

7 Conclusion
In this paper, we have substantiated the claim made infor-
mally in a previous paper that ES is a fragment of the situ-
ation calculus that admits an intuitive possible-world seman-
tics. We argued that this fragment is expressive enough to rep-
resent basic action theories by presenting a simple example
involving the action, knowledge, and sensing of a robot. We
also showed how a version of the Do operator of the Golog
language could be accommodated within the language. Fi-
nally, we proved that by using second-order encodings of se-
quences, virtually all of the situation calculus can be repre-
sented in ES. So what we get out of ES is a tool with prac-
tically the same expressive power as the standard situation
calculus, but which is much more amenable to analysis due
to its simple semantic basis.

In work currently under way [Cla(cid:223)en 2005], ES is used
to simplify and extend results by Reiter on knowledge-based
programs [Reiter 2001b]. There are also a number of di-
rections for future research, but perhaps the most immediate
would be to implement a new version of Golog based on ES
and put it to work.

Acknowledgments
We thank the anonymous reviewers for their helpful com-
ments.

References
[Blackburn et al. 2001] P. Blackburn, J. Kamps, and M.
Marx, Situation calculus as hybrid logic: First steps. In
P. Brazdil and A. Jorge (Eds.) Progress in Artiﬁcial In-
telligence, Lecture Notes in Arti(cid:2)cial Intelligence 2258,
Springer Verlag, 253-260, 2001.

[Castilho, Gasquet, and Herzig 1999] M. A. Castilho, O.
Gasquet, and A. Herzig, Formalizing Action and
Change in Modal Logic I: the frame problem. Journal
of Logic and Computation, 9(5), 701(cid:150)735, 1999.

[Demolombe 2003] R. Demolombe, Belief change:

[Cla(cid:223)en 2005] J. Cla(cid:223)en, Knowledge-Based Programming in
the Logic ES, MSc. Thesis, RWTH Aachen, in progress.
from
Situation Calculus to Modal Logic. IJCAI Workshop
on Nonmonotonic Reasoning, Action, and Change
(NRAC’03), Acapulco, Mexico, 2003.

[Enderton 1972] H. Enderton, A Mathematical Introduction

to Logic, Academic Press, New York, 1972.

[Gelfond and Lifschitz 1993] Michael Gelfond and Vladimir
Lifschitz. Representing action and change by logic pro-
grams. Journal of Logic Programming, 17:301(cid:150)321,
1993.

[Harel 1984] D. Harel, Dynamic Logic, in D. Gabbay and F.
Guenther (Eds.), Handbook of Philosophical Logic, Vol.
2, D. Reidel Publishing Company, 497(cid:150)604, 1984.

[Herzig et al. 2000] A. Herzig, J. Lang, D. Longin, and T.
Polacsek, A logic for planning under partial observabil-
ity. In Proc. AAAI-2000, AAAI Press.

[H¤olldobler and Schneeberger 1990] S. H¤olldobler and J.
Schneeberger. A new deductive approach to planning.
New Generation Computing, 8:225(cid:150)244, 1990.

[Kowalski and Sergot 1986] R. Kowalski and M. Sergot. A
logic based calculus of events. New Generation Com-
puting, 4:67(cid:150)95, 1986.

[Hughes and Cresswell, 1968] G. Hughes, and M. Cress-
well, An Introduction to Modal Logic, Methuen and
Co., London, 1968.

[Lakemeyer and Levesque, 2004] G.

and
H. J. Levesque, Situations, si! Situation Terms, no!. In
Ninth Conf. on Principles of Knowledge Representation
and Reasoning, AAAI Press, 2004.

Lakemeyer

[Levesque et al, 1998] H. J. Levesque, F. Pirri, and R. Re-
iter, Foundations for the situation calculus, Electronic
Transactions of AI (ETAI), 2(3-4):159-178, 1998.

[Levesque and Lakemeyer 2001] H. J. Levesque and G.
Lakemeyer, The Logic of Knowledge Bases, MIT Press,
2001.

[Levesque et al. 1997] H.

Reiter,
Y. Lesp·erance, F. Lin, and R. B. Scherl., Golog:
A logic programming language for dynamic domains.
Journal of Logic Programming, 31, 59(cid:150)84, 1997.

Levesque,

R.

J.

[McCarthy and Hayes 1969] J. McCarthy and P. J. Hayes,
Some philosophical problems from the standpoint of ar-
ti(cid:2)cial intelligence. In B. Meltzer, D. Mitchie and M.
Swann (Eds.) Machine Intelligence 4, Edinburgh Uni-
versity Press, 463(cid:150)502, 1969.

[Pratt 1976] V. R. Pratt, Semantical considerations on Floyd-
Hoare logic. In Proc. 17th Ann. IEEE Symp. on Founda-
tions of Computer Science, IEEE Press, 109(cid:150)121, 1976.
[Prior 1967] A. Prior, Past, Present and Future. Oxford Uni-

versity Press, 1967.

[Reiter 1991] Ray Reiter, The frame problem in the situa-
tion calculus: A simple solution (sometimes) and a com-
pleteness result for goal regression. In V. Lifschitz, ed-
itor, Artiﬁcial Intelligence and Mathematical Theory of
Computation, 359(cid:150)380. Academic Press, 1991.

[Reiter 2001a] R. Reiter, Knowledge in Action: Logical
Foundations for Describing and Implementing Dynami-
cal Systems. MIT Press, 2001.

[Reiter 2001b] Ray Reiter, On knowledge-based program-
ming with sensing in the situation calculus. ACM Trans-
actions on Computational Logic, 2(4):433-457, 2001.

[Sandewall 1994] Erik Sandewall. Features and Fluents. The
Representation of Knowledge about Dynamical Sys-
tems. Oxford University Press, 1994.

[Scherl and Levesque, 2003] R. B. Scherl

J.
Levesque, Knowledge, action, and the frame problem.
Artiﬁcial Intelligence 144(1-2), 1-39, 2003.

and H.

[Thielscher 1999] Michael Thielscher. From situation calcu-
lus to (cid:3)uent calculus: State update axioms as a solution
to the inferential frame problem. Artiﬁcial Intelligence,
111(1(cid:150)2):277(cid:150)299, 1999.

