MIKROKOSMS  AND  ROBOTS2,3 

by 

Leonard  Uhr  and  Manfred  Kochen 
U.of  Michigan 

U.  of  Wisconsin 

U.  S.  A. 

Abstract 

It 

This  paper  presents  a  computer  program  that 
simulates  situations  (called  "MIKROKOSMS")  in 
which  severl  entities  (called  "organisms")  wan­
der  around  in  an  environment  that  includes  one 
another  plus  other,  apparently  simpler,  entities 
(called  "objects").  The  program  has  a  rather  sim­
ple  set  of  "laws"  of  objects,  which  can  be  thought 
of  as  the  laws  of  physics  of  the  MIKROKOSM. 
also  has  other  specifications  for  organisms  -  their 
input  and  output  functions  (called  "perception" 
and  "response"),  their  reward  functions  (called 
"motivation"  or  "needs"),  and  their  mechanisms 
for  building  up  internal  memories  (called "learning" 
and  "hypothesis  formation")  that  will'help  them  to 
recognize  objects  in  the  future,  and  respond  ap­
propriately  to  them  (for  example, 
in  order  to  max­
imize  expected  rewards).  This  program  lays  bare 
the  processes  that  are  needed  to  handle  inter­
actions  among  simulated  organisms  and  objects, 
including  the  learning  of  hypotheses  that  will 
guide  future  action.  The  present  program  has  only 
the  simplest  of  pattern  recognition,  hypothesis 
formation  and  need-satisfaction  capabilities.  Its 
purpose  is  to  make  clear  and  concrete  how  such 
things  can  be  interrelated  in  a  complete  system. 
Descriptors:  Robots,  mikrokosms,  computers,  inte­
grative  systems,  pattern  recognition,  learning, 
hypothesis-formation. 

Background 

Several  relatively  simple  and  special-purpose 
precursors  to  MIKROKOSMS  have  been  reported  in 
the  literature.  Toda16  discussed  the  decision­
making  problem  of  organisms  that  move  at  some 
cost  in  energy  in  order  to  get  energy-giving  "mush­
rooms."  Doran1,2  also  examines  very  simple  simu­
lated  organisms  moving  through  a  space.  Travis' 
simulation  and  discussion  of  problem-solving  in 
the  form  of  a  chess  knight  moving  in  order  to  cover 
a  board  can  be  thought  of  from  this  point  of  view17. 
Indeed,  all  game-playing  and  theorem-proving 
programs  can  be  thought  of  as  simulating  the 
pieces  of  the  game  or  the  expressions  of  the  logis­
tic  system  as  they  move  about  the  environment  of 
the  gameboard  or  the  proof  tree. 
(For  examples, 
think  of  Samuel's  checker  player14,  Greenblatt's 
chess  player4,  Zobrist's  GO  program20,  Gelernter's 
geometry  theorem  prover3,  Newell  and  Simon's 
logic  theorist9  .  These  programs  become  more  per­
tinent  when  they  attempt  to  be  general  over  several 
games,  for  example,  Newell  and  Ernst's  General 
Problem  Solver8,  Pitrats12  and  Newman  and 
Uhr's10 

to-some-extent-general  game  players.) 

But  none  of  the  above  seem  to  be  exploring 
the  issues  for  which  the  MIKROKOSM  programs 
were  developed  (Kochen  and  Uhr5).  They  do  not 
try  to  tear  apart  what  we  mean  by  environments, 
objects,  organisms,  hypotheses,  learning,  and 
so  on.  They  do  not  try  to  vary,  and  to  generalize 
about,  these  things.  Rather,  they  look  at  rela­
tively  peculiar  and  rigid  spaces  (a  checker  board, 
a  logistic  system),  and  their  "organisms"  (which 
contain  little  in  the  way  of  perceptual  systems, 
memory,  or  learning  abilities)  are  rather  a_d  hoc 
to  their  space  (e.g.,  chess  pieces,  logical  ex­
pressions). 

During  the  past  few  years  four  large  "robot" 

projects  have  been  developed  (Pingle  et  al11  ; 
Minsky  &  Papert6 ;  Raphael13;  Sutro  &  Kilmer15)  and 
there  turn  out  to  be  certain  similarities  between 
robots  and  MIKROKOSMS.  Robots  are  real  phys­
ical  objects  that  wander  around  in  our  real  phys­
ical  world.  Movies  can  be  made  of  them;  when 
they  bump  into  walls  or  people  they  can  leave 
scars.  The  objects  in  a  MIKROKOSM  are  computer 
simulations  that  consist  of  internal  representations 
of  numbers  and  letters,  of  bits,  or  of  magnetic  or 
electrical  impulses  -  whichever  you  prefer.  They 
can  indeed  be  photographed  if  a  program  monitors 
them  onto  a  scope;  and  still  another  equally  trivial 
program  could  monitor  them  by  having  plastic  and 
metal  physical  objects  moving  around  through  a 
room,  just  as  the  scope  monitor  has  grades  of 
light  moving  around  over  a  phosphorescent  screen. 

The  differences  of  "reality,  "  of  physical 

"hardness"  and  ability  to  bump  and  scar, are  differ­
ences  that  we  had  best  leave  to  the  ontologists. 
But  there  are  important  differences  that  we  can 
understand.  MIKROKOSMS  force  us  to  understand, 
or  at  least  to  code,  our  environments  and  their 
interfaces  with  our  organisms  (which  simulate  ro­
bots);  whereas  the  robot  researchers  simply  stick 
their  real  robots  into  the  real  world,  and  thus 
1  For  people  partial  to  acronyms,  MIKROKOSM 
might  stand  for: 
in  Responding  Organisms  Konstructed  (from  CHAOS 
by  Concept-formation,  Heuristics  and  Adaptation 
to  Organization  Sensed)  from  Only  Sensation, 
Memory,  and_Sweat. 

"Models  of  Inductive  Knowledge 

2 Robots  on  their  way  to  the  moon  might  be 
thought  of  as  Real  Orbiting  Bits  of  Ostensible 
Things. 

3 This  research  was  partially  supported  by  NIH 
Grant,  12977. 

-541-

(potentially)  get  a ll  the  advantages  of  r e a l - w o r ld 
complexity  into  their  environments.  The  cost  they 
pay  is  the  cost  and  the  trouble  of  b u i l d i ng  robots 
(which  is  something  that  has  turned  out  to  take 
several  years,  several  people  and  several  h u n­
dreds  of  thousands  of  d o l l a r s ).  This  cost  w i ll  go 
down  and  disappear.  They  may  also  pay  the  more 
important  costs  of  reduced  complexity  of  the  o r g a­
nisms  they  can  handle,  and  r i g id  behavior  on  the 
part  of  these  organisms.  Or  at  least  this  seems  to 
be  the  case  to  date.  Finally, 
actually  taken  advantage  of  the  complexity  of  the 
real  world  into  which  they  can  put  their  robots.  We 
w i ll  return  to  these  issues  in  the  d i s c u s s i on  at  the 
end  of  this  paper. 

they  have  not  yet 

MIKROKOSMS  Described 

We  w i ll  now  give  a  brief  description  of 

in  the  following  way: 

MIKROKOSMS 
I)  An  actual 
running  computer  program  (called  " M I K R O - l ")  w i ll 
be  d i s c u s s e d.  This  program  is  presented  in  the 
Appendix,  along  w i th  an  English-language  "Precis" 
that  gives  a  detailed  statement-by-statement  d e s­
c r i p t i on  of  its  processes  and  its  flow  of  c o n t r o l. 
2)  Comments  w i ll  be  made  about  the  general  f u n c­
tion  embodied  in  each  section  of  the  program,  w i th 
s p e c i al  emphasis  on  how  it  might  be  s i m p l i f i ed  to 
a  bare-bones  minimum.  3)  We  w i ll  discuss  and 
suggest  ways  in  w h i ch  the  function  might  be  made 
more  p o w e r f u l. 

The  MIKROKOSM  programs,  at  least  as  we 

conceive  of  them  at  present,  break  down  into  the 
f o l l o w i ng  sections: 
I. 
I I.  Generate  the  i n i t i al  state  of  the  MIKROKOSM. 

I n i t i a l i ze  parameters. 

A.  Generate  objects,  and  put  them  into  the 

space. 

B.  Generate  organisms,  and  put  them  into  the 

space. 

I I I.  Compute  environment-organism  interaction 

(for  each  organism). 
A.  Print  out  the  present  state  of  the 

MIKROKOSM. 

B.  Present  its  updated  view  to  the  organism. 
C.  Let  the  organism  process  this  view: 

1.  Recognize  objects  . 
2.  Conjecture  pertinent  hypotheses. 
3.  Choose  the  most  highly  valued  hypothesis. 

IV.  Update  the  MIKROKOSM  to  advance  to  the  next 

time  i n t e r v a l. 
A.  Compute  and  effect  p h y s i c al  law  changes. 
B.  Compute  and  effect  changes  r e s u l t i ng  from 

organisms'  a c t s. 

C.  Have  the  organism  learn  as  a  function  of 

feedback  from  eating 

D.  Go  to  step  I I I,  advancing  time  by  1  u n i t. 

I n i t i a l i z a t i on  of  Parameters 

The  program  must  f i r st  be  given  a  picture  of 
the  kind  of  mikrokosm  space  it  should  generate. 
This  includes  the  dimensions  of  the  space, 
the 
number  of  organisms  and  of  objects  in  the  space, 

and  the  characteristics  of  the  organisms  and  the 
o b j e c t s.  This  might  be  done  in  a  very  general  way, 
by  parametrizing  a ll  of  these  characteristics 
and 
having  the  program  choose  random  values  for  the 
parameters.  Or  it  might  be  done  w i th  precise  d e s­
criptions  of  a ll  the  pertinent  d e t a i l s. 

M I K R O -l  is  a  simple  mixture  of  e a s i ly  param­

etrized  and  b u i l t - in  c h a r a c t e r i s t i c s.  The  basic 
parameters  (PARAMS)  for  a  space  are  taken  to  be 
its  row  and  column  size  (all  spaces  are  2 - d i m e n-
sional), 
the  number  of  organisms  and  the  number 
of  objects  in  the  total  space,  and  the  distance  that 
each  organism  can  see.  The  program  is  given  a  set 
of  standard  values  for  these  parameters  (7  rows, 
20  columns,  3  organisms  each  seeing  5  columns  in 
either  d i r e c t i o n,  and  4  o b j e c t s ).  But  the  program 
w i ll  attempt  to  read  a  data  card  at  run  time,  on 
which  new  parameter  values  can  be  given  to  i t. 

The  objects  that  w i ll  be  placed  into  the  space 

w i ll  be  exact  copies  of  the  general  object  types 
(GENOBJS).  These  are  descriptions  of  the  set  of 
points, 
the  shape)  of  the  objects,  and  of 
the  p h y s i c al  qualities  (such  things  as  color,  break-
a b i l i t y,  motion,  weight,  and  caloric  v a l u e ). 

(that  i s, 

Whereas  information  about  the  space  is  param­
etrized,  and  information  about  objects  is  stored  in 
information  about  organisms  is  embodied  in 
tables, 
code. 
[This  probably  reflects  the  relative  s i m p l i­
c i ty  of  the  space,  and  the  relative  complexity  of 
organisms.  E< t  it  probably  also  reflects  the  p r i m­
i t i ve  stage  of  this  program:  a  better  program  would 
have  better  reasons  for  using  parameters, 
tables, 
or  c o d e .]  Essentially,  an  organism  is  some  calls 
to  subroutines  that  a) 
recognize, 
and  e)  generate  and  learn  new  hypotheses. 

test  hypotheses,  d)  choose  acts, 

take  a  look, 

b)  pattern 

c) 

Generation  of  the  I n i t i al  State  of  the  MIKROKOSM 

The  program  uses 

ihe  parameters  that  define 

the  space  to  compute  the  average  distance  between 
objects  and  between  organisms,  and  then  generates 
and  places  the  specified  number  of  e a c h.  MIKRO-l 
makes  several  s i m p l i f i c a t i o ns  to  shorten  the  code 
and  speed  up  processing  time.  Some  of  these  lead 
to  peculiar  characteristics,  but  a ll  could  be  coded 
properly  -  in  most  cases  w i th  very  l i t t le  trouble. 

O b j e c t s.  Objects  are  generated  first,  by 

making  one  s p e c i f ic  object  from  each  general  o b­
ject, 
in  turn,  until  the  specified  total  number  of 
objects  has  been  made.  To  avoid  any  need  to 
check  whether  several  objects  are  put  into  the 
same  place  (though  in  fact  in  M I K R O -l  space  this 
w i ll  happen  later,  causing  peculiarities  but  no  fata] 
problems),  a ll  objects  are  put  into  the  top  row  of 
the  space,  at  distances  computed  so  that  the  s p e c­
i f i ed  total  number  of  objects  w i ll  be  equally  d i s t r i­
b u t e d. 
I n i t i a l l y,  a ll  s p e c i f ic  objects  of  each  g e n­
eral  type  w i ll  be  i d e n t i c a l,  except  for  p o s i t i on  in 
the  space.  But  as  time  passes  objects  may  move, 
bounce,  break,  and  in  other  ways  change  in  v a l u e. 

-542-

Organisms_,  MIKRO-I  now  generates  the 
specified  number  of  organisms  and  distributes 
them  uniformly  along  the  bottom  row  of  the  space. 
An  organism  is  simply  a  name  that  contains  a  set 
of  lists  with  that  organism's  qualities  (energy 
level,  location,  direction  and  force  of  motion),  its 
hypotheses  (after  it  has  learned  some), 
its  present 
view  of  the  space,  and  some  memory  as  to  its  own 
acts  and  changes  it  has  noted  in  its  environment. 
Organisms  resemble  objects  in  that  they  both 

have  physical  characteristics;  but  they  differ  in 
that  only  organisms  store  and  learn  hypotheses, 
view  the  environment,  and  have  some  memory.  At 
present  these  differences  reflect  our  own  primitive 
thinking  on  the  subject;  it  will  be  of  great  interest 
to  see  what  differences  remain  when  we  have  tried 
to  force  as  much  similarity  as  possible. 

There  are  several  major  peculiarities  to  the 
space  of  objects  and  organisms  generated  up  to 
this  point.  There  is  insufficient  space  to  describe 
discuss,  and  justify  them  all  in  detail,  but  briefly: 
Although  objects  have  shapes  in  2-dimensions, 
they  are  stored  as  though  at  points.  This  avoids 
the  necessity  of  detecting  and  computing  overlap 
between  objects,  which  would  either  force  us  into 
3-dimensional  space  (which  would  be  expensive  of 
memory  and  processing  time)  or  a  peculiar  physics 
of  objects  occupying  the  same  point  at  the  same 
time.  The  proper  way  to  handle  the  space  would 
be  for  all  objects  to  reside,  properly  positioned, 
in  a  background  of  emptiness  or  noise  (chaos). 
But  this  would  introduce  a  number  of  processing 
steps  that  would  make  this  aspect  of  the  program 
far  more  sophisticated  than  needed  for  the  low 
level  of  sophistication  of  the  rest.  So  we  store 
objects  and  organisms  on  lists,  and  designate 
their  positions  explicitly  by  the  coordinate  num­
bers,  rather  than  implicitly  by  their  actual  posi­
tions  in  the  framework  of  the  space. 
Computation  of  Environment-Organism  Interactions 

Printout.  The  program  outputs  the  present 

state  of  the  mikrokosm  before  it  begins  the  set  of 
object-organisms  interactions  that  will  lead  to 
change,  and  before  each  subsequent  time  period. 
This  printout  draws  a  picture  of  the  current  space, 
with  its  organisms  and  objects,  and  also  exhibits 
the  present  state  and  innards  of  all  objects  and 
organisms. 

Organism  Views  its  Environment.  That  part  of 
the  total  space  that  lies  within  its  field  of  view  is 
presented  to  each  organism,  in  turn.  Only  the  ex­
ternally-visible  shape  of  objects  (including  the 
viewing  organism)  can  be  seen,  and  the  position  of 
each  object  is  computed  and  given  to  the  organism 
relative  to  its  own  position.  Changes  in  these 
relative  positions  are  also  detected  and  given  to 
the  organism. 

Pattern  Recognition  and  Hypothesis-Testing. 

The  organism  now  begins  to  apply  its  set  of  hy­

potheses  to  its  seen  view.  [Specific  hypotheses 
might  be  coded  in  advance  into  each  organism's 
hypotheses  table,  but  the  alternative  procedure 
that  we  prefer  is  to  rely  upon  the  organism's 
learning  abilities  to  form  these  hypotheses  through 
experiences  gained  in  interaction  with  the  environ­
ment.]  Tor  each  object  in  its  view,  the  organism 
checks  to  see  if  there  is  an  hypothesis  in  its  mem­
ory  with  that  object  as  one  of  its  premises. 
here  that  the  program  does  a  very  primitive  kind  of 
"pattern  recognition,  "  in  which  the  description  of 
the  object  must  match  a  template  representation 
stored  in  the  organism's  memory. 

It  is 

The  interesting  thing  about  this  process  is  the 
structure  of  an  hypothesis,  even  in  its  overly-sim-
plc  present  form.  An  hypothesis  is  a  statement 
about  what  the  organism  should  do,  and  subsequent­
ly  expect,  when  a  certain  thing(s)  is  recognized  in 
the  environment  and  the  organism  is  in  a  certain 
state(s).  At  present  the  thing  recognized  is  one  of 
our  simple  and  undeviating  objects,  recognition  is 
effected  by  a  perfect  template,  the  acts  are  simple 
built-in  sequences  of  code,  and  the  expectations 
are  of  a  certain  amount  of  positive  or  negative 
change  ("pleasure"  or  "pain").  But  we  feel 
justified  in  suggesting  that  it  is  fine  to  keep  pat­
tern  recognition  as  simple  as  possible,  when  we 
have  so  many  other  problems  in  the  total  system, 
and  we  know  a  great  deal  about  how  to  make  more 
sophisticated  pattern  recognizers.  An  especially 
appropriate  type  of  pattern  recognizer  will  be  the 
sort  of  flexible  heirarchical  compound  learning 
program  discussed  in  Uhr19  .  We  should  also  note 
that  the  recognition  of  more  complex  compounds  of 
varying  internal  states  within  the  organism  can  be 
handled  in  exactly  the  same  way  as  external  recog­
nition, 
for  these  are  merely  two  (sets  of)  premises 
of  an  hypothesis.  The  issue  of  "planning"  is  cap­
tured  in  the  setting  up  and  learning  ot  sequences  of 
acts  for  the  organism  to  do,  which  form  the  conse­
quences  of  an  hypothesis,  and  also  sequences  of 
hypotheses  that  the  program  might  act  upon  over 
time. 
It  is  in  the  individual  hypothesis  and  the 
methods  for  choosing  among  hypotheses, 
that  much 
of what  we  call  "pattern  recognition,  "  "planning,  " 
and  "problem-solving"  lie.  MIKRO-I  handles  these 
problems  in  the  grossest  and  most  primitive  ways, 
but  it  also  makes  painfully  and  hopefully  clear  how 
our  mechanisms  for  hypothesis-application  and 
hypothesis-formation  can  be  improved. 

An  hypothesis  is  conjectured  to  apply  because 
something  in  the  environment  was  found  to  be  one 
of  its  premises,  and  hence  implied  it,  and  then  the 
organism  found  that  its  own  present  state  satisfied 
the  internal  state  premised  by  the  hypothesis,  and 
finally  computed  a  positive  expected  value  of  this 
hypothesis  (which  is  a  function  of  expected  return 
from  the  object  involved,  the  object's  distance:  a 
rough  measure  of  difficulty  of  applying  the  hypoth­
esis,  and  the  weight  of  assurance  with  which  this 
hypothesis  is  held).  After  the  program  has  found  all 
such  pertinent  hypotheses,  it  chooses  the  one  with 
the  highest  positive  weight.  [A  better  program  would 

-543-

allow  an  organism  to  do  more  than  one  thing  at  a 
time, 
to  decide  what  to  do  before  it  had  spent  all 
the  time  needed  to  examine  everything,  and  to 
make  decisions  as  a  function  of  sets  of  mutually 
complementary  hypotheses.  A  simpler  program 
might  ignore  internal  states,  and  merely  choose  a 
single  act  as  a  function  of  a  single  recognized  ob­
ject.  Such  a  program  would  be  doing  straightfor­
ward  pattern  recognition.  The  program  might 
merely  have  one  act,  rather  than  sequences  of 
acts,  stored  as  the  consequence  of  each  hypoth­
It  would  then  be  incapable  of  building  up 
esis. 
coherent  strategies  or  plans. 
It  is  at  this  point, 
when  a  program  is  given  the  ability  to  build  up 
sequences  and  compounds  of  characterizers  of 
environments  and  of  internal  states,  and  of  acts 
and  expectations, 
that  it  begins  to  build  up  the 
capability  of  doing  interesting  pattern  recognition, 
concept  formation,  serial  prediction,  problem-
solving,  and  planning. ] 
Up-dating  the  MIKROKOSM  to  Advance  to  the  Next 

Time  Interval 

After  all  organisms  have  been  given  the 

chance  to  interact  with  their  perceived  environ­
ments,  the  UPDATE  routines  change  the 
MIKROKOSM,  as  indicated  by  two  lists:  a)  the 
physical  qualities  of  all  the  organisms  and  objects, 
and  b)  the  UPDATE  list  of  the  organisms'  chosen 
acts. 

Physical  Changes.  The  only  physical  quality 

[A  better  program  would  allow  objects  to 

that  is  examined  by  MIKRO-i  is  the  object's  mo­
tion.  The  object  is  moved  as  indicated  and,  if  it 
has  hit  a  border  of  the  space, 
is  kept  at  that  bor­
der . 
accelerate  in  their  motion,  and  to  change  directioa 
for  example  after  hitting  one  another.  The  program 
should  also  compute  other  changes  in  objects, 
for 
example  decay  and  cracking  over  time, and  changes 
that  are  a  function  of  interactions  between  objects, 
for  example  breaking  or  fading.] 

Organisms'  Acts.  The  acts  that  the  organisms 
chose  to  put  into  UPDATE  are  now  carried  out.  An 
act  is  a  sequence  of  one  or  more  things  to  do,  and 
each  such  thing  names  a  subroutine  that  does  it. 
At  present,  the  program  has  subroutines  that  allow 
the  organism  to:  1)  GET  (move  l  step  toward  the 
specified  object),  2)  DESTROY  (wipe  out  the 
specified  object  if  it  is  at  the  same  location  as 
the  organism),  3)  FLAIL  (move  l  step  in  a  ran­
domly  chosen  direction),  and  4)  EAT  (wipe  out 
the  specified  object,  and  also  add  the  object's 
specified  caloric  content  to  its  own  internal  energy 
level).  This  is  a  rather  arbitrary  set  of  primitive 
acts,  chosen  primarily  to  get  MIKROs  started  do­
ing  something.  But  note  that  some  are  binary 
(DESTROY,  EAT)  and  some  unary  (FLAIL,  GET),  and 
that  s t r i ng  of  acts  can  be  compounded  together. 

Learning.  EAT  is  of  special  interest  because 

only  here  is  there  real  feedback  to  the  organism, 

It  is  therefore  here, 

when  its  energy  level  is  changed  as  a  function  of 
the  object's  caloric  value  (which  can  be  negative, 
denoting  a  noxious  object). 
and  here  only,  that  the  organisms  in  MIKRO-1 
"learn." 
[A  more  sophisticated  program  would 
have  learning  occur  from  a  wider  variety  of  feed­
back  information  -  for  example, 
from  noting  that 
objects  are  getting  closer,  or  that  a  certain  se­
quence  of  acts  (as  stored  in  the  organism's  running 
memory  of  past-done  things)  resulted  in  desirable 
or  undesirable  consequences. 
In  MIKRO-i  there  is 
only  one  overall  "energy  level,  "  which  is  changed 
when  an  object  is  eaten  and  its  "caloric  content" 
adds  to  or  subtracts  from  that  level.  There  might 
be  several  components  of  proper  functioning  -  eg. 
protein,  fat,  water,  oxygen,  touching  -  and  there 
might  now  be  a  need  to  develop  characterizers 
about  the  self's  patterning  of  these  components, 
a nd  changes  in  this  patterning. ] 

When  the  organism's  energy  level  is  changed 

as  a  function  of eating  an  object,  the  program 
hunts  through  the  past  done  acts  of  that  organism 
to  find  an  hypothesis  that  led  to  acts  with  the 
eaten  object  as  their  object.  Two  types  of  hypoth­
esis  are  stored  on  the  organism's  past-done  list: 
the  single  hypothesis  chosen  at  each  time  interval, 
and  the  rest  of  the  hypotheses  conjectured. 
If  no 
chosen  hypothesis  turns  out  to  be  about  the  object 
eaten,  the  organism  goes  through  its  conjectured 
hypotheses  and, 
if  one  is  found  about  that  object, 
raises  the  value  of  that  hypothesis,  so  that,  since 
it  is  pertinent, 
next  time. 
[This  is  a  rather  arbitrary  thing  to  do, 
and  should  not  be  taken  very  seriously;  it  merely 
demonstrates  how  easy  it  is  to  program  in  variant 
types  of  learning.] 

it  will  more  likely  be  chosen  the 

[A  better  pro­

the  new  weight  is  examined  to  see 

The  first  pertinent  hypothesis  that  is  found  is 
then  up-weighted  or  down-weighted,  depending  up­
on  whether  the  object  eaten  was  positive  or  nega­
tive  (noxious)  in  caloric  content. 
gram  might  change  the  weight  as  a  function  of  the 
actual  caloric  value,  as  well  as  its  sign.] 
down-weighted, 
if  it  has  fallen  below  some  acceptable  minimum. 
If  it  has, 
[MIKRO-1 
arbitrarily  sets  the  initial  weight  of  an  hypothesis 
at  5,  and  discards  the  hypothesis  when  its  weight 
goes  below  I.  A  more  sophisticated  program  might 
keep  a  better  record  of  the  good  and  bad  conse­
quences  of  an  hypothesis,  and  run  more  sensitive 
statistical  tests  to  see  whether  the  hypothesis  has 
proved  itself  good  or  bad  over  a  sufficiently  large 
sample.] 

the  hypothesis  is  discarded. 

If 

MIKRO-l  generates  a  new  hypothesis  a)  when 
an  hypothesis  is  discarded  and  b)  after  each  time 
period. 
[It  would  be  better  to  keep  some  count  of 
the  amount  of  space  available  for  the  organism's 
hypotheses  -  its  memory  size  -  and  then  eliminate 
the  least  valued  hypotheses  when  there  was  not 
enough  room  for  everything.  Alternately,  the 

- 5 4 4-

organism's  l e v el  of  functioning 
rate  on  this  level  might  be  stored,  w i th  h y p o t h­
eses  being  discarded  and  generated  as  deemed 
best  to  improve  further.  A  number  of  extremely 
interesting  aspects  of  learning  pop  up  at  this  pointj 

and  improvement 

if  negative, 

the  consequent  acts  of 

The  variety  of  new  hypotheses  MIKRO-l  can 
If  the  caloric  content  of  the 

generate  is  l i m i t e d. 
eaten  object  was  positive, 
the  hypothesis  w i ll  be  "get,  eat:" 
they  w i ll  be  "get,  d e s t r o y ."  The  object's  d e s c r i p­
tion  is  stored  as  one  premise,  so  that  the  simplest 
kind  of  whole-template  pattern  recognition  is 
learned  and  used.  The  i n i t i al  expectation  and 
weight  of  a ll  hypotheses  are  set  at  the  same  l e v e l-
90  and  5.  The  program  checks  whether  a  n e w l y-
generated  hypothesis  has  already  been  discarded 
in  the  past;  if  it  has, 
it  doesn't  bother  to  generate 
it  a g a i n. 
[This  is  a  subtle  issue;  if  the  mikrokosm 
were  noisy  or  changed  over  time,  organisms 
should  be  able  to  try  hypotheses  again.  On  the 
other  hand, 
hypotheses, 
if  the  organism  tried  again  hypotheses'  it  had  a l­
ready  found  w o r t h l e s s .] 

if  there  is  a  large  set  of  possible 
learning  might  be  slowed  dangerously 

Printout 

The  program  l i s t i ng  ends  w i th  the  code  that 
prints  out  the  state  of  the  mikrokosm  after  each 
time  period.  This  printout  is  cumbersome,  and 
need  not  be  described  in  d e t a i l.  Essentially, 
actual  Z-dimensional  representation  of  the 
mikrokosm  is  printed  as  a  matrix,  a ll  organisms 
and  objects  that  s t i ll  exist  are  l i s t e d,  and  the  c o n­
tents  (the  internal  states)  of  these  organisms  and 
objects  are  g i v e n. 

the 

Discussion 

MIKRO-l 

is  already  too  complex  to  lay  bare 

the  minimal  structure  of  a  mikrokosm,  yet  it  is  far 
too  simple  to  be  very  convincing  or  i n t e r e s t i n g. 
Our  intent  is  that  this  is  the  first  in  a  continuing 
series  of  more  complex  and  more  sophisticated 
programs.  These  w i ll  look  into  each  of  the  aspects 
of  a  mikrokosm  separately  (pattern  recognition, 
hypothesis  formation,  heirarchical  compounding, 
inductive  learning,  discovery,  and  so 
planning, 
on). 
to 
try  to  get  at  the  essence  of,  mikrokosms  by: 
a)  getting  at  their  bare  bones,  and  b)  general­
i z i n g,  eliminating  as  much  as  possible  of  the 
b u i l t - i n. 

It  should  also  be  instructive  to  simplify, 

M o t i v a t i on 

There  are  a  number  of  reasons  why 

MIKROKOSMs  seem  interesting  things  to  worry 
about  and  to  s i m u l a t e. 

A)  They  force  those  of  us  interested  in  m o d e l­

ing  i n t e l l i g e nt  processes  (whether  " a r t i f i c i a l" 
and/or  " n a t u r a l ")  to  take  into  account  a ll  aspects 
of  our  problem,  and  to  contend  w i th  the  central 

issue  of  integrating  into  a  v i s i b le  whole  the  various 
functions  that  we  t y p i c a l ly  study  separately.  On 
the  one  hand  many  of  us  (including  the  authors) 
argue  that  our  problem  is  far  too  big,  so  that  we 
should  simplify  as  much  as  possible;  and  that, 
further,  not  until  we  have  far  larger  computers  w i ll 
our  models  exhibit  diverse, 
flexible,  and  i n t e r e s t­
ing  behavior,  which  we  feel  may  to  a  great  extent 
be  a  function  of  size  of  memory.  So  we  separately 
study  "pattern  recognition"  or  "concept  formation" 
or  "verbal  learning"  or "problem  s o l v i n g"  ( e . g ., 
"game  playing,"  "theorem  proving,"  " s e r i al  predic­
tion")  or  "decision  functions"  or  "responding" 
(moving  a  "hand"  or an "arm"  or  a  "robot").  This  is, 
we  hope,  right  and  proper.  But  we  should  also  b e­
gin  to  combine  these  various  functions.  They  are 
merely  pieces  of  a  total  program,  and  we  had  better 
start  worrying  about  whether  we  can  ever  get  those 
pieces  working  e f f i c i e n t ly  together. 

B)  By  putting  the  different  functions  together 

at  the  precise  level  of  computer  code,  we  gain  the 
opportunity  to  generalize  across  them.  We  should 
force  ourselves  to  do  so.  One  gets  the  impression 
from  papers  and  talks  about  some  of  the  "robot" 
projects  that  they  intend  to  take  a  pattern  r e c o g n i­
tion  program,  and  a  question-answering  program, 
and  a  concept  formation  program,  and  a  theorem 
proving  program,  and  maybe  a  few  other  programs, 
and  put  them  together  into  a  Frankenstein  monster. 
On  the  contrary,  we  should  use  this  opportunity  to 
tear  apart  and  try  to  understand  our  code  and  the 
functions  we  are  trying  to  compute,  so  that  general-
purpose  routines  are  achieved.  For  example,  almost 
certainly  most 
and  "concept  formation"  should  be  performed  by  a 
single  subroutine.  Those  aspects  of  pattern  r e c o g­
nition  that  involve  deductive  inference  should  have 
subroutines  in  common  with  problem-solving.  And 
so  o n.  We  must  confront  ourselves  w i th  general 
criteria  for  t h e o r y - b u i l d i n g:  keep  the  set  of  c o n­
structs  as  simple,  elegant,  non-redundant,  power­
ful,  and insight-producing  as  p o s s i b l e. 

if  not  a ll  of  "pattern  recognition" 

C)  The  MIKROKOSM  situation  raises  some 

extremely  interesting  new  questions  of  generality. 
Tor  example,  when  we  work  w i th  t y p i c al  pattern 
recognition  or  a r t i f i c i al  intelligence  programs  the 
patterns  or  other  external  objects  w i th  which  they 
interact  are  merely  presented  to  them.  But  now  we 
must  describe  objects  in  the  same  kind  of  computer 
code  w i th  which  we  describe  our  perceiving,  prob­
l e m - s o l v i ng  organisms.  We  can  now  try  to  describe 
both  objects  and  organisms  w i th  the  same  subrou­
tines  and  the  same  tables,  and  we  can  begin  to  ask 
how  they  are  similar,  and  how  they  differ.  This  f o­
cuses  us  on  the  fascinating  issue  of  what  turns  an 
object  into  an  organism. 
about  how  a  s e l f - o r g a n i z i ng  system  of  objects 
might  begin  to 
us  to  think  about  what  must  minimally  be  given  to  a 
MIKROKOSM  for  it  to  contain,  or  evolve,  objects 

It  prepares  us  to  wonder 

evolve  some  organisms  . 

It  forces 

-545-

among  which  w i ll  be  organisms. 

D)  We  can  hold  one  or  more  parts  of  the  total 
MIKROKOSM  constant  or  t r i v i a l ly  simple,  vary  the 
rest,  and  examine  the  resulting  behavior. 

E)  We  can  ask  a  number  of  questions  about 

learning  that  cannot  be  so  c l e a r ly  asked  in  any 
other  s i t u a t i o n.  We  can  ask  what  is  a  minimal  o r­
ganism  that  w i ll  learn;  what  kinds  of  environmental 
experiences  must  this  organism  undergo;  what 
kinds  of  information  must  this  organism  store. 
Since  we  have  close  control  over  both  environment 
and  organism  (at  least  u n t il  they  start  to  interact 
and  to  learn),  we  can  constantly  think  about  one 
w i th  respect  to  the  other,  and  we  can  continually 
try  to  simplify  b o t h. 

F)  We  can  ask  two  c l o s e ly  related  questions 
that  have  simply  not  been  asked  before  at  the  p r e­
cise  l e v el  of  computer  modelling: 
l)  How  do  two  or 
more  organisms  learn  to  talk,  including  the  develop­
ment  of  vocabulary,  grammar,  and  semantic  refer­
ence,  and  the  development  of  the  mutually  under­
stood  convention  that  these  things  should  be  devel­
oped,  and  should  have  common  meaning  to  a ll  o r­
ganisms  belonging  to  that  l i n g u i s t ic  community? 
2)  How  do  two  or  more  organisms  come  to  compete, 
and  to  cooperate;  and  what  is  the  relation  of  such 
s o c i al  behavior  to  a)  their  basic  needs  and  ways 
in  w h i ch  they  can  be  s a t i s f i ed  on  the  one  hand, 
and  b)  their  development  of  language  on  the  other 
hand? 

G)  We  can  try  to  s i m p l i fy  to  the  point  where 
we  may  pinpoint  what  is  absolutely  e s s e n t i a l.  For 
example,  it  is  not  clear  whether  such  a 
MIKROKOSM  must  have  a  motivating  force  in  the 
form  of  the  organisms'  internal  needs.  We  keep 
being  forced  back  to  such  a  beginning,  or  some 
close  equivalent,  such  as  a  diffuse  c u r i o s i ty  or  a 
neural  i t c h,  despite  the  fact  that  this  somehow, 
in 
a  very  vague  way, 
feels  a_d  hoc  and  i n t u i t i v e ly  u n­
s a t i s f y i n g. 

MIKROKOSMS  and  Robots 

The  Stanford  U n i v e r s i ty  robot  project  (Pingle 

et  a l,  ")  has  developed  a  robot  that  (at  least  so 
far)  can  do  the  f o l l o w i n g:  if  several  large 
wooden  blocks  are  scattered  on  a  table,  a  robot 
hand  w i th  several  fingers  w i ll  zero  in  to  hover 
above  each  block,  close  its  fingers  around  that 
block,  pick  it  up,  and  put  it  on  top  of  a  tower  of 
l i k e - s i z ed  blocks  it  is  b u i l d i n g. 
It  thus  percep­
t u a l ly  sorts  out  the  blocks  by  size,  positions  i t s e lf 
to  pick  up  a  block,  and  then  places  the  block  very 
carefully,  so  that  it  sits  square  enough  on  top  of 
its  tower  so  that  the  tower  does  not  too  often  come 
tumbling  d o w n.  This  involves  some  extremely  c o m­
plex  matters  of  precise  positioning  of  fingers 
around  blocks,  and  of  blocks  on  top  of  other  blocks. 
These  problems  may  w e ll  be  horrendous,  if  not  i m­
possible;  but  unfortunately  this  may  be  the  case  be­
cause  they  are  being  handled  w i th  several  b u i l t - in 

strikes  against  the  robot.  For  it  gets  no  feedback 
about,  and  has  no  a b i l i ty  to  adapt  to,  s l i g ht  v a r i a­
tions  in  position;  it  is  in  the  same  unfortunate 
position  as  a  guidance  system  that  must  compute 
its  trajectory  to  hit  the  moon  without  any  oppor­
tunity  for  subsequent  s e l f - c o r r e c t i on  from  feedback 
as  to  its  d e v i a t i o n s. 

The  Stanford  Research  Institute  robot  (Rosen, 

N i l l s o n,  Raphael;  see  Raphael1 3)  can  wander 
through  a  room  that  has  irregularly  shaped  objects 
placed  in  it,  and  learn  through  experiences  of 
bumping  into  objects  how  to  avoid  them,  and  f i n a l­
ly  wander  through  the  room  without  bumping  into 
these  o b j e c t s.  But  its  methods  appear  to  be  rather 
r i g id  and  ad  hoc  -  e s s e n t i a l l y, 
paper  representation  of  the  room,  and  it  f i l ls  in 
squares  as  "containing  object,  so  avoid"  whenever 
either  its  TV  camera  "eye"  or  its  bumpers  find  a 
block  covering  the  corresponding  section  of  the 
room. 

it  stores  a  g r a p h-

Both  of  these  robots  do  things  that 

It  is  up  to  the  i n d i v i d u al  r e­

MIKROKOSM  organisms  do  riot  do,  and  they  force 
the  researcher  to  contend  w i th  problems  that 
MIKROKOSMs  a v o i d. 
searcher's  interests  and  tastes  which  he  decides  to 
be  the  more  important  problems,  or  the  problems 
most  central  to  modelling  of  i n t e l l i g e n c e.  Robot 
projects  must  contend  w i th  the  noises  introduced  by 
TV  camera  inputs  and  by  mechanical  contraptions 
that  can't  move  around  without  joggling  their  TV 
eyes,  stop  suddenly  without  randomly  overstepping 
their  intended  stopping-point,  or  place  one 
finger 
on  an  object  without  moving  that  object  s l i g h t ly  so 
that  the  computed  position  for  the  next  finger  is  no 
longer  correct.  New  and  interesting  pattern  r e c o g­
nition  problems  are  confronted  when  the  images  of 
possibly  interposed  3-dimensional  objects  on  a 
table  or  in  a  room,  w i th  their  shadows  and  grada­
tions  of  intensity,  must  be  recognized.  These  are 
problems  the  real  world  environment  forces  upon 
one,  and  it  is  good  to  be  confronted  by  the  real 
w o r l d. 

A  MIKROKOSM  simulation  could  be  expanded 
to  handle  3-dimensional  p a r t i a l l y - v i e w e d,  shaded 
patterns,  and  these  are  large  problems  of  pattern 
recognition  on  which  research  should  be  done.  But 
most  pattern  recognition  researchers  would,  we 
think,  agree  that  such  research  should  be  done  w i th 
computer  programs  and  special-purpose  pattern  r e­
cognition  computers,  not  w i th  robots. 
actual  pattern  recognition  programs 
into  these  robots  are  at  a  very  low  l e v el  of  s o p h i s­
t i c a t i on  compared  w i th  existing  pattern  recognition 
research  (see,  e . g .,  U h r1 9,  N a g y7). 

In  fact  the 
incorporated 

It  w o u ld  be  more  d i f f i c u lt  to  simulate  p r o b­

lems  of  bouncing  objects  and  f a l l i ng  towers;  but  it 
is  hard  to  judge  their  c e n t r a l i t y. 

The  above  is  intended  to  suggest  that  robot 

researchers  may  be  t a c k l i ng  d i f f i c u lt  problems  that 
are  not  r e a l ly  their  central  problems  -  the  mechan-

- 5 4 6-

ics  of  putting  a  robot  together;  the  issues  of  i l l u­
mination,  contrast,  color,  and  noisiness  of  pat­
terns  input;  and  the  mechanical  problems  of  exact 
motion  and  placement  -  andare  simplifying  the 
artificial  intelligence  aspects  of  their  robots  to  the 
point  where  they  are  actually  less  sophisticated 
than  existing  computer  simulations,  including  func­
tions, 
our  simple  MIKROKOSM  organisms.  But  it  is  not  at 
all  intended  to  criticize  the  intent  of  robot  re­
search,  which  we  take  to  be  to  confront  artificial 
intelligences  with  the  enormous  and,  intriguingly, 
inexhaustible  and  infinite  complexity  of  the  real 
world. 

b e en 

h a ve 

t h at 

i n to 

p ut 

On  the  contrary,  it  seems  to  us  crucial  to  at 
some  point  put  our  simulated  organisms  into  the 
real  world.  The  complexity  of  the  real  world  may  be 
necessary  for  adequate  learning;  there  may  even 
be  something  to  the  infinite  variety  of  the  real 
world  that  is  fundamentally  unprogrammabie,  and 
we  will  never  know  and  benefit  from  this  until  our 
learning  programs  are  hooked  into  the  real  world. 
(We  assume  that  good  artificial  intelligences  will 
be  learning  programs  -  they  must  be  able  to  adapt, 
and  they  will  be  far  too  complex  for  anyone  to 
succeed  in  formulating,  or  programming.) 

But  there  is  a  lot  to  discover  about  our  organ­
isms  before  they  are  ready  to  be  put  into  the  real 
world.  People  who  don't  have  the  mechanical  bent 
skills,  or  money  to  build  robots  can  still  play  an 
important  role  in  this  aspect  of  robot  research.  The 
interfaces  between  our  organisms  and  the  real 
world  almost  certainly  should  be  richer  than  those 
developed  so  far  in  the  robot  projects .  For  example, 
the  lack  of  ability  to  continually  monitor  feedbacks 
and  modify  behavior  accordingly  puts  existing 
robots  at  a  tremendous  disadvantage.  And  the 
""real  world"" has  to  be  an  interesting  part  of  the 
"real  world."  To  what  extent  is  a  robot  confronting 
the  real  world  when  the  room  it  is  in  contains  two 
sizes  of  blocks,  sufficiently  illuminated  so  that 
they  can  be  psrfectly  resolved  through  the  input 
device  used?  This  is  merely  a  world  of  blocks  and 
positions,  even  simpler  than  the  simulated  worlds 
of  MIKROKOSMs . 

Summary 

This  paper  describes  and  discusses  a  simple 

program,  "MIKRO-L,"  that  simulates  the  inter­
action  between  a  set  of  "objects,  "  some  of  which 
are  "organisms,  "  wandering  around  within  a  little 
"mikrokosm"  space'.  This  is  the  first  of  what  we 
hope  will  be  a  series  of  programs  to  explore  com­
plex  intellectual  processes  by  combining  the 
various  functions  (pattern  recognition,  concept  for­
mation,  problem  solving,  decision  making,  remem­
bering,  learning,  and  hypothesis  formation)  that 
have  typically  been  studied  separately. 

The  basic  structure  of  a  mikrokosm  appears  to 
be  the  following:  it  must  include  a  set  of objects, 

that  interact  within 

some  of  which  are  organisms, 
some  space.  There  must,  therefore,  be  ways  of 
describing  or  generating  objects  and  organisms, 
and  placing  them  in  interrelations.  Both  objects 
and  organisms  must  have  qualities  that  are  inter­
preted  according  to  "physical  laws"  of  the 
mikrokosm;  among  these  will  be  n-ary  qualities 
that  are  functions  of  interactions  (e.g.,  "breaking," 
"eating  " ).  Organisms  must  be  able  to  generate 
acts  as  a  function  of  interactions.  In  particular, 
sensory  interaction  (seeing  at  a  distance)  and 
hypothesizing  and  learning  (generating  and  storing 
sets  of  premises  as  to  the  states  of  the  external 
environment  and  of  the  internal  characteristics  of 
the  organism)  seem  necessary  for  any  interesting 
variety  of  organism  behavior.  The  mikrokosm  must 
be  able  to  collate  all  the  changes  of  organisms  and 
objects,  and  up-date  itself  to  the  next  time  period. 

MIKRO-L  contains  a  special  kind  of  object, 

a  "shout, "  that  is  located  everywhere.  This  we 
take  to  be  the  basis  of  future  language  learning. 
But  MIKRO-l  makes  no  use  of  shouts.  Nor  does  it 
have  a  very  sophisticated  set  of  basic  acts  (eat, 
get,  flail,  destroy),  reasons  for  learning  (the 
positive  or  negative  caloric  content  of  an  eaten 
object),  or  pattern  recognition  ability  (whole-tem­
plate  matching).  It  has  rigid  methods  for  forming 
hypotheses,  and  it  has  no  ability  to  put  anything  -
hypotheses,  pattern  characterizes,  or  acts  -  into 
interesting  compounds  or  heirarchies .  But 
mikrokosms  make  painfully  apparent  the  need  for 
such  improvements,  and  we  think  that  they  are  an 
especially  good  test-bed  within  which  to  construct 
and  examine  more  sophisticated  processors. 

APPENDIX 

^ABSTRACT  FOR  MIKRO-l . 
A  Get PARAMS:  ROWS,  COLS,  NORGS,  VIEWORG, 

NOBJS,  OBJDESCRIPTIONS. 

GENERATE  SPECIFIED  NUMBER OF  OBJECTS, 

SPREAD ACROSS ROW  L . 

GENERATE  SPECIFIED  NUMBER OF  ORGANISMS, 

SPREAD ACROSS  ROW  N. 

B  PRINT OUT  THE  MIKRO,  CHANGES,  AND  THE 

ORGANISM'S  INTERNAL  STATES. 

C  PRESENT  THE  NEXT ORGANISM  WITH  THE  VIEW 

OF WHAT IT  CAN  SENSE,  BUILDING  UP A 
CHANGES  LIST  FROM  LAST  TIME. 

WHEN  NO  MORE  OGRANISMS,  GO  TO  D. 

THIS  ORGANISM  FINDS  ALL  HYPOTHESES 

IMPLIED  BY WHAT'S  IN  VIEW,  COMPUTES 
A  VALUE  FOR EACH  HYPOTHESIS,  CHOOSES 
THE  SINGLE  MOST  HIGHLY  VALUED 
HYPOTHESIS,  AND  PLACES  IT  IN  UPDATE 
AND  IN  ITS  OWN  PASTDO  LIST. 

GO  TO  C. 

D  l/PDATE  THE  MIKRO  FOR THE  NEXT  TIME  PERIOD: 

MOVE  EACH  OBJECT  (INCLUDING  THE  ORGAN­
ISMS) AS  SPECIFIED  IN  THEIR  DXY  (CHANGE* 
OF-LOCATION)  VALUE. 

-547-

FOR  EACH  ORGANISM,  DO  THE  STRING  OF  ACTS 

SPECIFIED:  (INCLUDE  MOVING  -  FLAILING, 
GETTING  -  ,  EATING,  DESTROYING.) 

REWEIGHT  THE  ACTED-UPON  HYPOTHESIS 

UP  OR  D O W N. 

IF  WEIGHTED  DOWN  TEST  WHETHER  IT 
SHOULD  BE  THROWN  OUT. 

IF  YES,  PUT  IT  ON  DISCARDS  LIST, 

AND  TRY  TO  GENERATE  A  NEW 
HYPOTHESIS  FOR  THIS  ORGANISM. 

WHEN  ALL  ORGANISMS  ARE  DONE, 

Statement 
Number 

17 

18 

No  -  Let  12  equal  I.  (puts  a ll 

objects  in  row  1). 

From  GENOBJS,  get  the  first  TyPe  of 
object  and  its  DEScription,  and  put 
it  after  the  REST,  at  the  end  of 
GENOBJS  (so  w i ll  generate  one 
example  of  each  type  of  object  in 
turn). 

GO  TO  B. 

END  GO  TO  A. 
*PRECIS  M I K R O - l.  SIMPLEST  2 - D I M. 

ENVIRON.  OBJS  PUT  IN  ROW  L  . 

**INITIALIZE  THE  PROGRAM'S 

PARAMETERS. 

Add  1  to  the  N u m b e r - o f - O b j e c t s - g e n e r a t ed  19 

Statement 
Number 

(NO). 

Let  the  column  where  the  next  object  w i ll 

20 

be  PUT  equal  the  present  PUT  (which 
is 
DISTance-between-Objects) 

i n i t i a l l y)  plus  DISTO  (the 

0 

GO 

Let  GENerateOBJects  (GENOBJS)  contain  a 

0 

*NOTE  THAT  HERE  AND  ELSEWHERE  THE  RANDOM 

NUMBERS  CAN  BE  USED  TO  VARY  POSITIONS. 

l i st  of  the  prototype  objects  and  their 
d e s c r i p t i o n s. 

Let  each  prototype  object  contain  a  l i st 

of  its  p h y s i c al  q u a l i t i e s. 

DEFINE  the  function  BORD  (which  keeps 

objects  w i t h in  borders). 

DEFINE  the  function  PUTOUT  (which 
outputs  information  about  the  state 
of  the  mikrokosm  after  each  time 
period). 

Let  PARAMeterS  contain  a  standard  set 

of  parameters. 

READ  in  a  different  set  of  parameters 

for  this  run  (if  given) 

Get  from  PARAMS  the  i n d i v i d u al 

parameters:  RWS  (RoWS  of  space); 
CLS  (CoLumnS  of  space);  NORG 
(Number  of  ORGanisms);  OSEE 
(Organism's-SEEn-view);  NOBJ 
(Number  of  OBJects). 

Let  RandomBACKground  (RBACK)  contain 

a  random  l i st  of  symbols. 

Let  RANDom  contain  a  random  l i st  of 

I,  0,  - I. 

Let  SHOUT  contain  the  physical 

qualities  of  shouts. 

Let  OBJectTYPES  contain  the  names 

of  the  prototype  objects  . 

Let  PRIMDO  contain  the  primitive  acts 
an  organism  can  do  before  l e a r n i n g. 

**BEGIN  TO  GENERATE  OBJECTS. 

BEGIN 

Let  the  average  DISTance-between-
Objects  (DISTO)  equal  the  number 
of  CoLumnS  (CLS)  divided  by  the 
Number-of-OBJects. 

B6 

Is  the  Number-of-Objects-generated 

(NO)  GreaterThan  the  Number-of-
OBJects-to-be-generated  (NOBJ)? 
Yes  -  Go  to  B l. 

1-5 

5 

6 

7 

8 

9 

10 

I I 

12 

13 

14 

15 

16 

Add  to  OBJS  (the  l i st  of  a ll  OBJectS- 

21 

generated)  this  object's  name 
OB2,  .  .  .OB(NO))  followed  by  its  TyPe, 
DEScription,  and  row  (12)  and  column 
(PUT)  l o c a t i o n s. 

(OBI, 

Let  this  object's  name  (OB(NO))  contain 

its  LOCation, 
(I2*PUT)  and  a  description 
of  its  physical  qualities  (stored  in  TyPe). 
Go  to  B6, 

to  generate  the  next  o b j e c t. 

**PLACE  ORGANISMS. 
Bl 

Let  DISTance-between-Organisms  (DISTO) 

equal  the  number-of-CoLumnS  divided 
by  the  Number-of-ORGanisms  . 

Let  the  column  where  the  first  organism 

w i ll  be  PUT  equal  i  DISTO. 

If  PUT  equals  0,  set  it  equal  to  I  (so  1st 

organism  w i ll  be  i n s i d e ). 

B8 

Add  I  to  NO. 
Add  to  ORGS  (the  l i st  of  a ll  ORGanismS- 
generated)  this  organism's  name  (ORG 
(NO)),  where  NO  are  the  integers  that 
follow  the  integers  used  for  objects), 
the  number  of  this  organism  (NORG), 
this  organism's  name  again,  and  row 
(RWS, 
the  last  row)  and  column  (PUT) 
l o c a t i o n s.  (==  indicates  organism;  =* 
indicates  o b j e c t .) 

Let  this  organism's  name  (ORG(NO)) 

contain  its  attributes  (ENergy, 
l o c a t i on  (RWS*PUT),  and  an  i n i t i al 
description  of  its  physical  qualities 
and  its  past  memory  ( i n i t i a l ly  blank)). 

i n i t i al 

22 

23 

24 

25 

26 

27 

28 

Subtract  I  from  the  Number-of-ORGanisms  29 

(NORG)-to-be-generated. 

Is  NORG  LessThan  I  ?  Yes  -  Go  to  B9. 

No  - A dd  the  DISTance-between- 
for 

Organisms  (DISTO)  to  PUT, 
placing  the  next  organism.  Go  to  B8. 
**PRESENT  ITS  VIEW  TO  EACH  ORGANISM. 

30 
31 

-548-

Statement 
Number 
32 

Fail  to  B18) 

Statement 
Number 

Add  the  l i st  of  ORGanismS  to  the  end 

of  the  l i st  of  OBJectS. 

(after  each  Time-NEXT)  PUTOUT  the 

present  state  of  the  mikrokosm. 

Advance  TIME  by  I  . 
Is  TIME  GreaterThan  5 ?  Yes  -  END  this 

B9 

TNEXT 

r u n. 

TNI 

B7 

No  -  Make  a  Copy-ORGanismS  (CORGS) 

of  ORGanismS  (ORGS)  l i s t. 

Get  the  next  Name-of-ORGanism  from 
CORGS.  (If  no  more,  Go  to  UPDATER) 
From  NORG,  get  this  organism's  STATE, 

HYPotheses,  PASTDOne  acts,  VIEW, 
and  OLDCHANGES. 

From  STATE,  get  this  organism's 

LOCation=  (ROW,  COL). 

Let  the  LEFT  border  of  this  organism's 

view  be  its  COLumn  minus  OSEE 
(dis tance  - i n - o ne  - d i r e c t i o n - of 
Organism's  -SEEn-view). 

Let  the  RIGHT  border  be  its  COLumn  plus  41 

OSEE. 

BIO 

Make  a  Copy-OBJectS  (COBJS)  of  OBJects 

(OBJS)  l i s t, 

BLANK  out  (erase)  LVIEW  and  CHANGES. 

43 

♦LIST  FOR  THIS  ORGANISM  THE  OBJECTS  IN 

ITS  VIEW, 

INCLUDING  ITSELF. 

Bl  1 

From  COBJS,  get  the  next  Name-of-

Object  (NO), 
DEScription.  (If  no  more,  Fail  to  B12). 

its  TyPe  (TP),  and 

For  this  Named-Object  (NO),  get  its 

LOCation  (ROw  *  COlumn). 

Is  this  object  of  TyPe  'SHOUT'  ?  Yes  - 

Go  to  B17. 

Is  this  object's  COlumn  GreaterThan 
the  LEFTmost  column  viewed?  No  -
Go  to  Bl  1  (it's  not  in  this  organism's 
f i e ld  of  v i e w ). 
Yes  -  Is  CO  LessThan  the  RIGHTmost 

column  v i e w e d?  No  -  Go  to  Bl  1. 

♦GET  AND  USE  DISTANCES  FROM  ORGANISM 

TO  OBJECTS. 

Let  RO  (Row-of-Object)  equal  ROW 

(ROW-of-organism)  minus  RO  (to  get 
row  distance  from  organism  to  o b j e c t ). 

Let  CO  (Column-of-Object)  equal  COL 

(COLumn-of-organism)  minus  CO. 

BLANK  out  ROA,  COA. 

B17 

33 

34 
35 

36 

37 

38 

39 
40 

44 

45 

46 

47 

48 

49 

50 

51 
52 

From  this  organism's  VIEW,  get  the  TyPe 

(TP),  DEScription,  Name-of-Object  (NO), 
and  its  location  (ROA  *  COA).  (If  no  more, 

-549-

B20 

BL8 

Bl 2 

42 

Bl 6 

53 

54 

55 

56 

57 

58 

59 

60 

Add  this  TyPe,  DEScription,  Name-of- 
OBJect  and  its  location  (RO  *  CO)  to 
LVIEW  (the  Left-VIEW). 

Do  the  old  locations  (ROA,  COA)  of  this 

object  EQUALS  the  new,  computed 
locations  (RO,  CO) ?  Yes  -  Go  to  Bl  1 
(no  changes). 

Is  this  object  of  TyPe  "SHOUT* 

(which 

is  located  everywhere)  ?  Yes  -  Go  to  Bl  I  . 

To  CHANGES,  add  this  object  (its  TyPe, 

DEScription,  Name-Object,  and  its 
changes  in  location  (RO-ROA,  CO-COA)). 
Go  to  B11 . 

To  the  beginning  of  LVIEW,  add  this  new 

object  (its  TyPe,  DEScription,  Name-of-
Object,  and  location  ( R O* CO).  G o to 
B20. 

♦ ♦THIS  ORGANISM  NOW  APPLIES  ITS  LEARNED 

HYPOTHESES  TO  THE  VIEW  PRESENTED  IT. 

Let  VIEW  contain  what  LVIEW  contains. 
Let  MAYDO  equal  PRIMDO  (those  acts 

P R I M i t i v e l y - D O n e ). 

From  LVIEW,  get  the  next  object's  TyPe, 

DEScription,  Name-of-Object,  and 
location  (RO  ♦ C O ).  (If  no  more,  Fail  to 
B13.) 

If  this  TyPe  and  its  DEScription  are  found 

6 I 

on  the  l i st  oi  this  organism's  HYPotheses, 
get  the  a c t s - t o - D O,  state-of-SELF, 
EXPECTations,  and  WeighT.  (If  not  found, 
Fail  to  B16.) 

Does  this  organism's  STATE  contain  the 

62 

SELF-state  specified  for  this  hypothesis? 
(No  -  Go  to  Bl  6.) 

Let  VALUE  equal  the  EXPECTed-need- 

6 3 

change  times  the  WeighT  of  this 
hypothesis,  divided  by  the  ROw  plus 
COlumn  distance  plus  10. 

Get  the  absolute  VALUE  (delete  any  minus 

64 

sign  (-)). 

Add  this  hypothesis  to  the  l i st  of  things 

65 

the  organism  MAYDO:  VALUE,  a c t s - t o - DQ 
Name-of-Object, 
location  (RO  * CO),  what 
to  EXPECT, 
DEScription,  and  the  SELF  state  found.  Go 
to  B16. 

the  object's  TyPe  and 

♦♦CHOOSES  TO  DO  AS  MOST  HIGHLY  VALUED 

HYPOTHESIS  ON  MAYDO  SUGGESTS. 

Bl 3 

66 

BLANK  out  VALA,  XXA,  L M. 
From  MAYDO,  get  the  first  VALueA  and  the  67 

rest  of  the  information  (XXA)  about  this 
h y p o t h e s i s.  (If  none  Fail  to  B15.) 

69 

70 

71 

73 
74 

75 

76 

B14 

Statement 
Number 
68 

From  MAYDO,  get  the  next  value  (VALB) 

and  the  rest  of  the  information  (XXB) 
about  that  h y p o t h e s i s.  (If  no  more 
hypotheses,  Fail  to  B15.) 

Is  VALB  GreaterThan  VALA ?  (If  yes, 

Go  to  B19.) 
No  -  Add  to  LM  (Lesser-Maydo)  VALB 

and  XXB  (the  less  valued  hypothesis). 
Go  to  B U. 

Add  to  LM  VALA  and  XXA  (the  less  valued 

hypothesis). 

Let  VALA  equal  VALB  (which  has  a  higher  72 

v a l u e ). 

Let  XXA  equal  XXB.  Go  to  B M. 

B19 

B15 

Add  to  UPDATE  this  organism's  name 
l o c a t i on  (ROW*  COL)  and 

(NORG), 
the  information  about  its  most  highly 
valued  implied  hypothesis  (XXA) 

From  PASTDOne,  erase  the  act-done 

farthest  in  the  past  (XX,  which  is 
f i r st  on  this  inverted  l i s t ),  and  add 
the  chosen  hypothesis  (VALA,  XXA, 
followed  by  a ll  L e s s - v a l u e d - M a y d os 
( L M ). 

Re-store  under  this  organism's  name 

(NORG)  its  updated  STATE,  HYPotheses, 
PASTDOnes,  VIEW,  and  CHANGES.  Go 
to  B7, 
to  start  processing  for  the  next 
organism. 

**UPDATE  THE  MIKROKOSM  FOR  THE  NEXT  TIME 
PERIOD. 
UPDATER 

77 

Let  Copy-OBJectS  contain  what  OBJectS 

contains;  erase  OBJectS. 

**UPDATE  OBJECTS  ACCORDING  TO  PHYSICAL 
LAWS. 
U3 

78 

From  COBJS,  get  the  next  object's  N a m e-

Object,  TyPe,  DEScription, 
the  f i r st 
symbol  after  the  ' ='  ( c a ll  it  OX),  and 
the  rest  (YY).  (If  no  more  objects,  Fail 
to  U1  .) 

In  this  Named-Object,  get  its  motion 

(DXY)  in  X  (DX)  and  Y  (DY)  d i r e c t i o n s. 

In  NO,  get,  and  erase, 

its  LOCation 

( R O * C O ). 

BORDer  this  object  (computing  from  its 
location  (RO  and  CO)  and  motion  (DX 
and  DY)  whether  it  w i ll  remain  w i t h in 
the  space,  so  that  it  w i ll  be  made  to 
s t i ck  to  the  border)  -  a  function  that 
starts  w i th  the  statement  labeled 
BORDI. 

79 

80 

81 

In  NO,  put  the  newly-computed  LOCation  82 

(NEWRow-Column). 

Statement 
Number 
83 

Add  to  OBJectS  this  object:  N a m e - o f- 
Object,  TyPe,  DEScription,  what's 
in  OX,  and  its  new  location  (NEWRC). 

Add  to  REPL  this  object's  location 

(RO*CO)  and  TyPe.  Go  to  U 3. 

**FUNCTION  THAT  COMPUTES  NEW  LOCATION 

AND  KEEPS  OBJECT  WITHIN  BORDERS. 

BORDI 

Let  NRO  =  RW  +  DR  (new-ROw  =  RoW  + 

Delta-Row). 

Let  NCO  =  CL  +  DC  (New-CoLumn  = 

CoLumn  +  D e l t a - C o l u m n ). 

If  NRO  is  LessThan  l, 
If  NRO  is  GreaterThan  RWS  (the  last 

let  NRO  equal  I  . 

RoWS), 

let  NRO  equal  RWS. 

If  NCO  is  LessThan  L, 
If  NCO  is  GreaterThan  CLS  (the  last 

let  NCO  equal  I  . 

CoLumnS), 

let  NCO  equal  CLS. 

Subtract  L  from  CoLumn 
In  the  designated  RoW  of  the  Picture 
replace  the  SSymbol 

of  the  space, 
where  this  object  used  to  be  (CL 
symbols  from  the  left)  by  a  period  (.) 
(which  indicates  empty  space). 

Let  NEWRow-Column  equal  NRO  * N C O. 

RETURN  from  this  f u n c t i o n. 

**UPDATE  AS  A  FUNCTION  OF  ORGANISMS' 

CHOSEN  ACTS. 

Ul 

From  UPDATE,  get  the  next  c h o s e n - a c t-

to-do  (Name-of-ORGanism,  ROW, 
COLumn,  a c t s - t o - D O,  Name-of-Object, 
and  the  rest  (XX)).  (If  no  more,  Fail  to 
TNEXT.) 

Get  the  LOCation  (RO  * CO)  of  this 

Named-Object. 

Erase  WASH2  from  N O. 

U2 

Put  LOBJS  back  at  the  left  of  OBJectS. 
Erase  (WASH)  LOBJS. 

U2A 

From  DO,  get  the  next  s p e c i f ic  DO-X. 

If  succeed,  go  to  the  statement  whose 
label  is  stored  in  DOX;  if  Fail,  go  to 
U l. 

84 

85 

86 

87 
88 

89 
90 

91 
92 

93 

94 

95 

96 
97 

98 
99 

**THE  ROUTINES  THAT  EFFECT  THE  SPECIFIC 

ACTS  FOLLOW. 

GET 

BL^NK  out  DX  and  DY. 
PRINT  out  ' / / / G E T S / / /'  (to  inform  that 

a c t i n g ). 

Does  the  organism's  ROW  EQual  the 

100 

101 

102 

object's  ROw?  Yes  -  Go  to  G l. 
No  -  If  the  organism's  ROW  is  Greater- 
let  DX  (change 

Than  the  object's  ROw, 
in  the  X  direction)  equal  -1  and  Go  to  G2. 
Or  let  DX  equal  + 1,  and  Go  to  G2. 

104 

103 

-550-

Statement 
Number 

105 

Gl 

G2 

Does  the  organism's  COL  EQual  the 
object's  COlumn?  Yes  -  Go  to  G2. 
No  - 

If  the  organism's  COL  is 

GreaterThan  the  object's  CO 1, 
DY  (change  in  the  Y  direction)  equal 
-1  and  Go  to  G2. 

let 

Or  let  DY  equal  +1  . 

From  OBJectS,  get  this  NORG's  ROW 

and  COL. 

BORDer  this  organism  (calling  the 

function  BORD,  which  w i ll  move  it 
and  keep  it  w i t h in  the  borders). 

On  OBJS, 

find  NORG,  and  add  its  new 

location  (NEWRC). 

Add  this  location  (NEWRC)  and  Name-

of-ORGanism  to  REPL. 

Change  the  LOCation  stored  under 

this  Name-of-ORGanism  to  NEWRC. 
Go  to  U2, 
to  get  and  do  the  next  act. 

DESTROY 

Get  the  NEXT  object  from  OBJectS.  (If 

no  more,  Fail  to  U2.) 

Add  this  object  to  Left-OBJectS. 
From  NEXT, 

if  the  location  is  NEWRC, 

immediately  following  ' =*',  get 
Name-Object,  TyPe,  and  DEScription. 
(If  f a i l,  go  to  DESTROY.) 
Succeed  -  Add  this  Name-of-Object, 

'DESTROYEDBY' 

as 
ORGanism, 

to  GONEOBJS.  Go  to  U 6. 

the  Name-of-

FLAIL 

From  RANDom,  get  the  first  two  (pseudo­

random)  numbers  (called  DX  and  DY), 
and  put  them  at  the  end  of  RANDom. 
Go  to  G2,  where  these  w i ll  be  used  to 
randomly  move  and  f l a il  the  organism. 

EAT 

Get  the  NEXT  object  from  OBJectS.  (If 

no  more,  Fail  to  U2.) 

Add  this  object  to  Left-OBJectS. 
From  NEXT, 

if  the  location  is  NEWRC, 
immediately  f o l l o w i ng  the  ' = *',  get 
Name-of-Object,  TyPe,  and 
DEScription.  (If  f a i l,  Go  to  EAT) 
Succeed  -  PRINT  out  ' / / / E A T / / / '. 

For  this  Name-of-Object,  get  its 

CALoric  VALue. 

From  this  Name-of-ORGanism,  get  its 

ENergy  l e v e l,  and  add  the  object's 
CALoric  value  to  this  ENergy  l e v e l. 
Add  this  N a m e - o f - O b j e ct  as  'ATEBY' 

this  Name-of-ORGanism  to  GONEOBJS. 

**RE-WEIGHTS  LEARN  HYPOTHESES  AS  A 

FUNCTION  OF  FEEDBACK  FROM  EATING. 

**FINDS  AN  HYPOTHESES  ABOUT  THIS  EATEN 

OBJECT. 

106 

107 
108 

109 

I  10 

1 I 1 

112 

L 13 

I  14 
I  15 

1 16 

I  17 

I  18 

1 19 
120 

121 

122 
123 

124 

L5 

L4 

L6 

L3 

BL^NK  out  PAST,  OPAST,  and  DEX 
From  this  Named-ORGanism,  get  its 

STATE,  HYPotheses,  PASTDOne, 
VIEW,  and  OCHANGES  (get,  but  don't 
erase  them.) 

Statement 
Number 
125 
126 

127 

From  PASTDOne,  get  the  next  c h o s e n-
act's  VALue,  DZ,  N a m e - o f - O b j e c t -I 
(NOI), 
and  the  REST  of  the  conjectured  hypotheses 
for  that  time  period. 
L6.) 

location  ( R O I * C O I ),  Expectations, 

(If  no  more,  Fail  to 

From  EXpect,  get  EXPECT,  TyPel,  DES- 

128 

criptionl,  and  SELF. 

Add  1  to  PAST. 
Add  the  REST  to  Other-PAST 
Does  the  Named-Object  EQUALS  the 

Named-ObjectI?  No  -  Fail  to  L3. 

**RE-WEIGHTS  AN  HYPOTHESIS  ABOUT  THE 

OBJECT  EATEN. 

L7 

Yes  -  On  the  organism's  HYPotheses, 
if  TyPel  and  DEScriptionI  are  found, 
get  and  remove  DoY,  SELF,  EXPECT, 
and  WeighT. 

Add  Delta-Expectation  (DEX)  to  EXPECT. 
WASH  (erase)  DEX. 
Is  the  CALoric  content  negative  (-)? 

Yes  -  Go  to  L4. 
No  -  Add  1  to  WeighT. 

Put  back  on  HYPothesis  the  components 
of  the  hypothesis  that  was  taken  off  by 
statement  L7  and  reweighted.  Go  to  U 6. 

Lower  WeighT  by  1  (this  was  a  noxious 
object  that  the  organism  should  learn 
not  to  eat). 

Is  the  WeighT  now  LessThan  I  ?  No  -  Go 

to  L5  (to  put  this  down-weighted 
hypothesis  back  onto  HYPotheses). 

**DISCARD  AN  HYPOTHESIS  WHOSE  WEIGHT  HAS 

GONE  BELOW  1. 

Add  to  the  l i st  of  DISCARDS  the  TyPel, 

140 

DEScriptionI,  DoY,  SELF,  and  EXPECT 
of  this  discarded  hypothesis.  Go  to  L8. 

*IF  NONE  OF  THE  HYPOTHESES  ACTED  UPON  WAS 

PERTINENT,  CHECK  ALL  OTHERS  ON  OPAST. 

From  Other-PAST,  get  the  next  hypothesis 
location 

(VALue,  DoY,  N a m e - o f - O b j e c t I, 
( R O w I * C O H ),  and  Expectation).  (If  no 
more,  Fail  to  L8) 

From  EXpect,  get  EXPECT,  TyPel, 

DEScription,  and  SELF. 

Does  Namea-Object  EQual  Named* 

O b j e c t I?  No  -  Fail  to  L6. 
Yes  -  Let  Delta-Expectation  (DEX) 

- 5 5 1-

129 
1 30 
131 

I 32 

I  33 
134 
135 

136 
137 

138 

139 

141 

142 

143 

144 

Statement 
Number 

Vol.  56,  no.  5. 

8.  Newell,  A.  and  Ernst,  G .,  The  search  for 

145 

146 

147 

148 

149 

150 

151 

152 
153 

generality.  Proc. 
York,  1965,  pp.  17-23. 

IFIP  Congress  65.  New 

9.  N e w e l l,  A .,  &  Shaw,  J . C .,  &  Simon,  H.A., 
Empirical  explorations  of  the  logic  theory 
machine.  Proc.  W e s t.  Joint  Comp.  Conf., 
1957,  218-239. 

10.  Newman,  C.  and  Uhr,  L.,  BOGART:  A  d i s c o v­
ery  and  induction  program  for  games.  Proc. 
20th  Annual  Meeting  of  the  A C M,  1965. 

1 1.  Pingle,  K.K.,  Singer,  J. A.  &  Wichmann,  W.M  ., 

Computer  control  of  a  mechanical  arm 
through  v i s u al  input.  Proc. 
68,  Edinburgh,  1968,  pp.  H 1 4 0 - H 1 4 7. 
12.  Pitrat,  J .,  Realization  of  a  general  game-

IFIP  Congress 

playing  program.  Proc. 
Edinburgh,  1968,  pp.  H 1 2 0 - H 1 2 4. 

IFIP  Congress  68, 

13.  Raphael,  B.,  Programming  a  robot.  Proc.  IFIP 

Congress  68,  Edinburgh,  1968.  pp.  H 1 3 5-
H140. 

14.  Samuel,  A . L .,  Some  studies  in  machine 
learning  using  the  game  of  checkers  . 
IBM  J.  Res,  and  Develop.,  1959,1,  2 10-
229. 

15.  Sutro,  L . L.  &  Kilmer, 

Assembly  of  computers 

to  command  and  control  a  robot.  Proc. 
Spring  Joint  Comp.  Conf.,  1969. 

16.  Toda,  M .,  The  design  ot  a  fungus-eater:  a 
model  of  human  behavior  in  an  u n s o p h i s­
ticated  environment,  Behav.  S c i .,  1962, 
l_t  164-183. 

17.  Travis,  L . E .,  Experiments  w i th  a  theorem-

u t i l i z i ng  program.  Proc.  Spring  Joint 
Computer  Conf.,  1964. 

18.  Uhr,  L.  (Ed.)  Pattern  Recognition,  New  York: 

W i l e y,  1967. 

19.  Uhr,  L.,  Pattern  Recognition,  Problem  Solx/ing 

and  Learning. 

I 969  (in  preparation). 

20.  Zobrist,  A .,  A  model  of  v i s u al  organization 
for  the  game  of  GO.  Proc.  Spring  Joint 
Comp.  Conf.,  1969. 

equal  3  (so  that  this  hypothesis  w i ll 
have  a  higher  expectation,  and  w i ll 
more  l i k e ly  be  chosen  and  acted 
upon, 

in  the  future).  Go  to  L7. 
**A  NEW  HYPOTHESIS  IS  GENERATED 
L8 

Is  the  CALoric  content  of  the  eaten  object 

negative  ( - )?  Yes  -  Go  to  L9. 
No  -  Let  N e w - Do  (ND)  equal  "GET, 

E A T . ".  Go  to  L I O. 

L9 

Let  the  N e w - Do  (ND)  equal  "GET. 

DESTROY.". 

LIO 

See  if  DISCARDS  already  has  this  new 
hypothesis'  TyPe,  DEScription,  and 
N e w - D o.  (If  yes,  Go  to  U6.) 

Add  this  newly-generated  hypothesis  to 
the  organism's  HYPotheses:  its  TyPe, 
DEScription,  N e w - D o,  and  i n i t i al 
e x p e c t a t i o n - l e v el  (90),  and  weight  (5). 

U6 

Erase  information  about  this  eaten  or 

destroyed  Named-Object. 

Put  the  Left-OBJectS  back  onto  the 

start  of  the  OBJectS  l i s t. 

WASH  (erase)  Left-OBJectS. 
Erase  this  (eaten  or  destroyed)  Named- 

Object  from  the  OBJectS  l i s t.  Go  to  U2A. 

**FUNCTION  FOLLOWS  TO  PRINT  OUT 

INFORMATION  ABOUT  MIKRO  AT  EACH  TIME 
PERIOD. 

Bibliography 

1.  Doran,  J . E .,  Experiments  w i th  a  pleasure 

seeking  automaton. 
Intelligence  3, 
Edinburgh:  University  Press;  1968a,  p p. 
195-216. 

(ed.  M i c h i e,  D.) 

In:  Machine 

2.  Doran,  J . E .,  A  simulated  robot/environment 

system:  progress  and  problems,  1968b. 

3.  Gelernter,  H .,  Realization  of  a  geometry 
Inter­

theorem  proving  machine.  Proc. 
national  Conference  on  Information 
Processing,  Paris:  UNESCO,  1959. 

4.  Greenblatt,  R . D .,  Eastlake,  D . E .,  &  Crocker, 

5. 

S . D .,  The  Greenblatt  chess  program. 
Proc.  Fall  Toint  Computer  Conf.,  1967. 

Kochen,  M.  and  Uhr,  L.,  A  model  for  the 
In: 
process  of  learning  to  comprehend. 
Information  Science  ( M.  Kochen,  Ed.) 
New  York:  Scarecrow  Press,  1965. 

6.  M i n s k y,  M.  and  Papert,  S.,  D i s c u s s i on  of 

MIT  robot  project.  Presented  at  I n t. 
Pattern  Recognition  Conf.,  Puerto  Rico, 
1967. 

7.  Nagy,  G .,  State  of  the  Art  in  Pattern  Recog­

n i t i o n,  Proceedings  of  the  IEEE,  1968, 

-552-

