568 

Session No.  14 Theorem Proving 

A PARADIGM FOR REASONING BY ANALOGY 

Robert  E.  Kling 

Stanford  Research  Institute 

Menlo  Park,  California 

U.S.A. 

ABSTRACT 

A  paradigm  enabling  heuristic  problem  solving 
programs  to  exploit  an  analogy  between  a  current 
unsolved  problem  and  a  similar  but  previously 
solved  problem  to  simplify  its  search  for  a  solu­
tion  is  outlined. 
It  is  developed  in  detail  for 
a  first-order  resolution  logic  theorem  prover. 
Descriptions  of  the  paradigm,  implemented  LISP 
programs,  and  preliminary  experimental  results 
are  presented.  This  is  believed  to  be  the  f i r st 
system  that  develops  analogical  information  and 
exploits  it  so  that  a  problem-solving  program  can 
speed  i ts  search. 

INTRODUCTION 

An  intelligent  man  thinks  deeply  and  learns 

from  his  past  experiences.  Contemporary  theorem-
proving  and  problem-solving  systems  are  continu­
ally  designed  to  think  ever  more  deeply  and  to 
ignore  their  past  completely.  A  problem  solver 
designed  in  any  of  the  contemporary  paradigms 
(such  as  resolution  (1),  GPS  (2),  and  REF-ARF  (3)) 
solves  the  same  problem  the  same  way  each  time 
it  is  presented.  A  f o r t i o r i,  they  are  unable  to 
exploit  similarities  between  new  and  old  problems 
to  hasten  the  search  for  a  solution  to  the  new 
one.  ZORBA,  outlined  in  this  paper,  is  a  para-
digm  for  handling  some  kinds  of  analogies. 
This 
is  the  f i r st  instance  of  a  system  that  derives  the 
analogical  relationship  between  two  problems  and 
outputs  the  kind  of  information  that  can  be  use­
f u l ly  employed  by  a  problem-solving  system  to 
expedite  its  search.  As  such,  ZORBA  is  valuable 
in  three  ways: 

(1) 

It  shows  how  nontrivial  analogical  reason­
ing  (AR)  can  be  performed  with  the  tech­
nical  devices  familiar  to  heuristic  pro­
grammers,  e.g.,  tree  search,  matching, 
and  pruning. 

In  Ref.  (4),  I  show  that  there  are  several  kinds 
of  analogies  from  an  information-processing 
point  of  view.  We  should  hardly  expect  one 
paradigm  to  include  them  a l l.  Restrictions  on 
the  varieties  of  analogy  handled  by  ZORBA  are 
described  in  the  section  entitled  "Necessary 
Conditions  for  an  Analogy." 

(2)  It  provides  a  concrete  information-

processing  framework  within  which  and 
against  which  one  can  pose  and  answer 
questions  germain  to  AR. 

(3)  Since  it  is  implemented  (in  LISP), 

it  is 
available  as  a  research  tool  as  well  as 
a  gedanken  tool. 

The  last  two  contributions  are  by  far  the  most 
important,  although  our  attention  w i ll  focus  upon 
the  f i r s t. 
In  the  50's  and  60's,  many  researchers 
f e lt  that  analogical  reasoning  would  be  an  impor­
tant  addition  to  intelligent  problem-solving  pro­
grams.  However,  no  substantial  proposals  were 
offered,  and  the  idea  of  AR  remained  rather  nebu­
lous , merely  a  hope.  ZORBA  may  raise  more  ques­
tions  of  the  "what  i f ?"  variety  than  it  answers. 
However,  now,  unlike  1968,  we  have  an  elementary 
framework  for  making  these  questions  and  their 
answers  operational. 

ZORBA PARADIGM 

Although  prior  to  ZORBA  there  were  no  concrete 

paradigms  for  AR,  there  was  an  unarticulated  un­
developed  paradigm  within  the  a r t i f i c i al  i n t e l­
ligence  Zeitgeist.  Suppose  a  problem  solver  had 
solved  some  problem  P  and  has  its  solution  S. 
If 
a  program  is  to  solve  a  new,  analogous  P  ,  it 
should  do  the  following: 

(1)  Examine  S  and  construct  some  plan  (schema) 

S 

that  could  be  used  to  generate  S. 

(2)  Derive  some  analogy  a  p 
(s')  =  s'  . 
(3)  Construct  G 
A 
(4)  Execute  S 
to  get  S  ,  the  solution  to  P  . 
A 
A 

p. 

If  P  was  solved  by  executing  a  plan,  then  S 
would  be  available  and  step  (1)  could  be  omitted. 
Although  nobody  has  explicated  this  idea  in  pub-
lications,  from  various  conversations  with  workers 
in  the  f i e l d, 
I  believe  that  the  preceding  descrip­
tion  is  close  to  the  paradigm  that  many  would  have 
pursued.  As  such,  it  constitutes  the  (late-60's) 
conventional  wisdom  of  a r t i f i c i al  intelligence. 
Certainly  this  (planning)  paradigm  is  attractively 
elegant!  However,  in  1969,  when  this  research 
was  begun,  it  was  an  inappropriate  approach  for 
two  reasons: 

(1)  There  are  no  planning-oriented  problem 
solvers  that  are  f u l ly  Implemented  and 
operate  in  a  domain  with  interesting 
This  state  of 
nontrivial  analogies. 

PLANNER  at  MIT  and  QA4  at  SRI  are  two  current 
planning-oriented  problem  solvers  that  are  under 
development.  The  f i r st  is  partially  implemented 
and  the  second  exists  only  on  paper. 
It  is  not 
yet  clear  what  problem-solving  power  PLANNER  w i ll 
have,  and  how  effective  it  w i ll  be  in  domains 
with  interesting  analogies. 

Session No.  14 Theorem Proving 

569 

R.  E.  KLING 

affairs  probably  w i ll  change  in  the  next 
few  years,  but  it  now  renders  d i f f i c u lt 
any  research  that  depends  on  the  existence 
of  such  a  system. 

is 

If  SA  f a i l s, 

too  strong,  or 

(2)  Given  the  plans  generated  by  such  a  sys­
tem,  it  is  hard  to  know  a  priori  at  what 
level  of  generality  the  derived  analogy 
w i ll  map  into  an  executable  analogous 
plan.* 
wrong?  Should  6  be  modified  and  a  variant 
S.  computed,  or  should  the  system  keep 
G,  and  just  back  up  its  planner  and  gene­
rate  an  alternative  subplan  using  its  own 
planning  logic?  At  best  this  is  a  rather 
complex  research  issue  which  would  i n­
volve  a  good  planning-oriented  problem 
solver  as  an  easily  accessible  research 
tool.  At  worst,  the  preceding  paradigm 
may  be  too  simple  and  the  development  of 
a  suitable  α  may  be  interactive  with  how 
much  successful  problem-solving  has  pro­
ceeded  so  far. 
(A  complete  α  should  not 
be  attempted  before  some  problem  solving 
begins  and  is  extended  as  needed  in  the 
course  of  solving  P  .) 

A 

Happily,  there  is  an  alternative  approach  that 
circumvents  the  preceding  d i f f i c u l t i e s.  Consider 

system  that  has  solved  some  problem  P  and  is 

posed  with  a  new  (analogous)  P 
to  solve.  Clearly, 
t must  operate  on  some  large  data  base  sufficient 
(See  Figure  1.) 
o  solve  both  P  and  P  . 
dition  to  the  subbase  for  solving  P  and  P 

In  ad-
there 

FIGURE 1  VENN DIAGRAM OF THEOREMS IN DATA BASE 

it  is  ob­

In  fact,  while  a  problem  solver  might 

they  work  with  nonoptimal  data  bases, 
vious  that  many  of  the  irrelevant  inferences  that 
are  generated  are  derived  from  the  data-base  as­
sertions  (theorems,  axioms,  facts)  in  D  -  D1  (or 
In  fact,  as  the  number  of  theorems  i r­
D2  -  D1). 
relevant  to  the  solution  P  becomes  large,  the 
number  of  irrelevant  inferences  derived  from  this 
set  begins  to  dominate  the  number  of  irrelevant 
inferences  generated  within  D  and  its  descendants 
alone. 
solve  P  given  an  adequate  and  small  D  ,  it  may  be 
swamped  and  run  out  of  space  before  a  solution 
given  a  D2  that  is  much  larger  than  needed. 
Clearly,  one  effective  use  of  analogical  informa­
tion  would  be  to  select  a  decent  subset  D  of  D 
such  that  size  [D  ] 
size  [D].  For 
example,  a  typical  theorem  in  algebra  provable  by 
QA3  —a  resolution  logic  theorem  proof—may  re­
quire  only  10  axioms  (D  )  while  the  f u ll  alge­
braic  data  base  has  250  axioms. 
If  a  system 
could  select  a  D2  such  that  size[D2]  -  15  axioms, 
a  massive  saving  in  search  could  be  had. 
In  fact, 
the  theorem  that  would  be  unprovable  on  a  D  with 
size[D]  =  250  would  now  be  provable. 

size  [D  ] 

2 

A  second  kind  of  information  that  would  be 

useful  to  help  solve  P  would  be  a  set  of  lemmas 
whose  a n a l o g s . .. 
(or  subgoals)  L  , 
G(L  )  could  be  solved  by  the  system  before  at­
tempting  P  . 
A 

... 

At  this  point  I  w i ll  not  discuss  how  to  recog­
instead, 
nize  a  lemma  and  generate  its  analog; 
I  merely  want  to  note  that  lemmas  may  be  effec­
tively  used  without  using  a  planning  language 

Even  given  an  optimal  data  base,  a  problem 
solver  w i ll  generate  some  irrelevant  inferences. 
In  general,  automatic  problem  solvers  and  theorem 
provers  run  out  of  space  rather  than  time  when 
they  f a il  to  solve  a  problem.  Ernst(2)  empha­
sizes  this  point  with  regard  to  GPS,  and  I  have 
had  similar  experiences  with  QA3(5),  a  resolu­
tion  logic  theorem  prover. 

Recognizing  lemmas  depends  upon  the  problem-
solving  system.  For  example,  in  resolution 
logic,  some  good  criteria  for  lemmahood  are: 

(1)  A  ground  unit  used  more  than  twice  (or 

k  times)  in  a  proof. 

(2)  A  unit  that  is  a  merge. 
(3)  A  clause  that  is  the  "least  descendant" 

of  more  than  2  (or  k)  units. 

Generating  a  lemma  depends  upon  the  system's 
a b i l i ty  to  associate  variables  with  variables 
and  that  may  be  tricky  when  skolem  functions  are 
introduced. 

570 

Session No.  14 Theorem Proving 

R.  E.  KLING 

.

.

.
.A 
, e . g ., 

typical  planner 

to  the  data  base  (like  a  theorem)  and 

that  forces  backup  in  case  of  failure.  Suppose  we 
somehow  get 
. ..   etc., 
would  order  the 
attempt  to  solve  them  in  sequence,  and  stop  if  any 
lemma  fails  to  be  solved. 
In  contrast,  we  merely 
If  we  get  a  solution, 
need  to  attempt  each 
add 
continue  with  the  next  lemma. 
tinue  anyway.  At  worst,  we  wasted  some  computation 
time.  Each  useful 
decreases  the  number  of 
steps  in  the  solution  of  PA  and  may  decrease  the 
depth  of  the  solution  tree.  Thus,  lemmas  are 
helpful  in  getting  a  faster  solution.  Note,  how­
ever,  that  a  s u c c e s s f u l n e ed  not  be  used  in 
the  solution  of  PA. 
Thus,  we  are  not  bound  by  the  fail-backup  orienta­
tion  of  sequential  planning  logics. 

is  merely  available. 

If  we  f a i l,  con­

It 

In  summary,  if  we  use  analogical  information 

in  which  a  problem 

to  modify  the  environment 
solver  operates,  we  can  effectively  abbreviate  the 
work  a  problem  solver  must  perform.  Of  course,  a 
well-chosen  environment  w i ll  always  lead  to  a  more 
efficient  search.  Usually,  we  have  no  idea  how  to 
tailor  a  subenvironment  automatically  to  a  par­
ticular  problem.  Here  we  do  it  by  exploiting  its 
analogy  with  a  known  solved  problem.  Now,  the 
representations  used,  the  analogy-generating  pro­
grams,  and  the  types  of  additional  information 
output  w i ll  depend  upon  the  problem-solving  system 
(and  even  the  domain  of  application).  Any  further 
discussion  needs  to  specify  these  two  items. 

APPLICATIONS  TO RESOLUTION  LOGIC 

The  preceding  discussion  referred  to  an 

problem  solver  and  is  just  a  proposal.  Computer 
programs  have  been  implemented  to  apply  this  para­
digm  to  a  resolution  logic  theorem  prover,  QA3.(5) 
For  the  class  of  analogies  these  programs  handle, 
this  is  an  accomplishment.  When  we  begin  to  focus 

(Li) 

is  not  at­

In  fact,  under  some  conditions,  the  axioms  used 
to  solve  (Li)  may  be  deleted  from  D2  so  that 
size  [ D2]  IS  decreased,  and 
tempted  again  inadvertently  during  the  solution 
of  P  . A 
Here  environment  is  synonymous  with  data  base. 
But  it  can  also  include  permissible  function 
orderings  (in  predicate  calculus)  and  other  kinds 
of  restrictive  information.  Each  rule  restricting 
the  "environment"  could  be  translated  into  an 
equivalent  new  decision  rule  restricting  the  ap­
plication  of  the  inference  procedures  of  the 
problem  solver.  However, 
I  find  it  easier  to 
think  of  ZORBA  in  terms  of  modified  environments 
rather  than  (the  equivalent)  modified  decision 

upon  a  particular  paradigm,  two  issues  are  more 
easily  resolved: 

(1)  What  kinds  of  information  are  most  useful 

to  provide  to  the  problem  solver? 

(2)  Which  representations  shall  we  use  to 
describe  the  analogies  and  handle  the 
necessary  data? 

In  contrast,  GPS 

Resolution  logic  is  an  inference  rule  whose 
statements  are  called  clauses.*(1),(5)  Thus,  a 
resolution-oriented  analogizer  w i ll  deal  with 
clauses  and  their  descriptions. 
uses  sets  of  objects  to  describe  its  states,  and 
we  would  expect  that  an  analogy  system  devoted  to 
GPS  would  deal  with  (complex)  objects  and  their 
attributes.  Table  1  contrasts  the  kinds  of  i n­
formation  helpful  to  QA3  and  GPS.  An  analogy 
f a c i l i ty  developed  for  GPS  would  be  oriented  to 
its  peculiar  information  structures  instead  of 
clauses  and  axioms  indigenous  to  resolution. 

Table  1 

KINDS OF  INFORMATION HELPFUL TO QA3 and  GPS 

QA3  (Resolution) 
Relevant  axioms 
Expected  predicates 

Lemmas 
Admissible  function 
nestings 

GPS 

Relevant  operators 
Abbreviated  difference 
table 
Subgoals 
Restrictions  on  operator 
applications 

I  want  to  digress  briefly  and  describe  the 
kinds  of  theorems  that  the  implemented  system, 
ZORBA-I,  tackles.  Briefly,  they  are  theorem  pairs 
in  domains  that  can  be  axiomatized  without  con­
stants  (e.g.,  mathematics)  and  that  have  one-one 
maps  between  their  predicates.  The  theorems  are 
f a i r ly  hard  for  QA3  to  solve.  For  example, 
ZORBA-I  w i ll  be  given  proof  of  the  theorem 

Tl.  The  intersection  of  two  abelian  groups 

is  an  abelian  group 
and  is  asked  to  generate  an  analogy  with 
T2.  The  intersection  of  two  commutative  rings 

is  a  cummutative  ring. 

A  clause  is  an  element  in  the  conjunctive  normal 
form  of  a  skolemized  wff  in  the  predicate  cal­
culus.  For  example:  —  person  [x] 
V  father  [g(x);  x]  is  the  clause  associated  with: 
Vx  person  [x]  →  3y  father  [y;x]  (every  person 
has  a  father). 

Session No.  14 Theorem Proving 

571 

R.  E.  KLING 

Given 

T3.  A  factor  group  G/H  is  simple  i ff  H  is  a 

maximal  normal  subgroup  of  G. 

Generate  an  adequate  analogy  with 

T4.  A  quotient  ring  A/C  is  simple 

maximal  ideal  in  A. 

iff  C  is  a 

None  of  these  theorems  are  t r i v i al  tor  contemporary 
(See  Table  2,  in  a  later  section, 
theorem  provers. 
lor  a  listing  oi  additional  theorem  pairs.)  T1 
has  a  35-step  prool  and  T3  has  a  50-step  proof  in 
a  decent  axiomatization.  A  good  theorem  prover 
(QA3)  generates  about  200  mlerences  in  searching 
for  either  prool  when  its  data  base  is  miaimized 
to  the  13  axioms  required  lor  the  proof  of  T1  or 
to  the  12  axioms  required  for  the  proof  of  T3. 
If  the  data  base  is  increased  to  20-30  reasonable 
axioms,  the  theorem  prover  may  generate  600 
clauses  and  run  out  of  space  before  a  proof  is 
found.  Note  also  that 
the  predicates  in  the  prob­
lem  statement  of  these  theorems  contain  only  a  lew 
ol  the  predicates  used  in  any  prool.  Thus,  T 
can  be  stated  using  only  fINTERSECTION;  ABELIAN], 
but  a  proof  requires  {GROUP;  IN;  TIMES,  SUBSET; 
SUBGROUP;  COMMUTATIVE]  in  addition.  Thus,  while 
the  f i r st  set 
is  known  to  map  into  {INTERSECTION, 
COMMUTATIVERING} ,  the  second  set  can  map  into 
anything. 

Figure  2  shows  a  set  P  including  a ll  the 

predicates  in  the  data  base. 

FIGURE  2  VENN  DIAGRAMS OF  RELATIONS 
IN  STATEMENTS  T,  TA'  AND  D' 

We  know  P1  and  P2,  the  sets  of  predicates  in  the 
statements  of  the  new  and  old  theorems,  TA  and  T. 
In  addition,  we  know  the  predicates  P1  in  some 
proof  of  T  (since  we  have  a  proof  at  hand).  We 
need  to  find  the  set  P2  that  contains  the  rela­
tions  we  expect  in  some  proof  of  TA,  and  we  want 
a  map  G:  G(P  )  =  P  . 

Clearly,  a  wise  method  would  be  to  find  some 

Then  incrementally  extend  G 

G  ,  a  restriction  ol  G  to  P1  such  that  α'  (P,)  -
P2 
to  α1'  α2, 
each  on  larger  domains  u n t il  some  G  (P  )  -  P2 
ZORBA-I  does  this  in  such  a  way  that  each  incre­
mental  extension  picks  up  new  clauses  that  could 
be  used  in  a  proof  of  T. . 
In  tact,  if  we  get  no 
new  clauses  from  an  extended  α'j,  that  may  be  rea-
son  to  believe  that  α1'  is  faulty.  The  next  sec-
tions  w i ll  describe  the  generation  algorithm  in  a 
l i t t le  more  detail. 

ZORBA'S REPRESENTATION OE AN ANALOGY 

In  the  preceding  sections  I  have  implied  that 

this 

intuitively  analogous  theorem  pairs, 

an  analogy  is  some  kind  of  mapping.  The  ZORBA 
paradigm—e.g.,  using  an  analogy  to  restrict  the 
environment  in  which  a  theorem  prover  works—does 
not  restrict  this  mapping  very  much.  For  differ­
ent 
mapping  would  need  to  be  able  to  associate  predi­
cates  (and  axioms)  in  a  one-one,  one-many,  or 
many-many  fashion,  possibly  dependent  upon  con­
text.  For  other  theorem  pairs,  one-one  mappings 
and  context-free  mappings  are  adequate.  ZORBA-I 
is  a  particular  sot  of  algorithms  that  restricts 
its  acceptable  analogies  to  those  which  map 
predicates  one-one  with  no  context  dependence. 
It  allows  one-many  associations  between  axioms; 
e.g.,  one  axiom  ol  the  proved  theorem  is  asso­
ciated  with  one  or  more  axioms  that  w i ll  be  used 
to  prove  the  new,  analogous  theorem.  More  ex­
p l i c i t l y,  a  ZORBA-1  analogy  G  is  a  relation 
αP X  Αc  x  αv  ,  where: 

(1)  αp 

(2) 

is  a  one-one  map  between  the  predi­
cates  used  in  the  proof  oi  the  proved 
theorem  T  and  the  predicates  used  in  the 
proof  of  the  unproved  theorem TA . 
αc 
Each  clause  used  in  the  prool  oi  T  is 
associated  with  one  or  more  clauses  from 
the  data  base  D  that  ZORBA-I  expects  to 
use  in  proving  T.. 

is  a  one-many  mapping  between  clauses 

is  a  many-many  mapping  between  the 
variables  that  appear  in  the  statement 
of  T  and  those  that  appear  in  the  state­
ment  of  T  . 
A 

(3)  G 

Different  sections  of  ZORBA-I  use  these 
various  maps,  e.g., α  v  and/or  Gp  and/or  αc. 
Usually  I  w i ll  drop  the  superscript  and  simply 
refer  to  "the  analogy  G."  Thus  "the  analog  of  an 
axiom  ax  under  analogy  G"  should  be  understood 
to  mean  αcfax  1,  and  w i ll  often  be  mentioned 
simply  as  "the  analog  oi  ax  . 

In  the  previous  section  I  refer  to  a  sequence 

of  analogies α1 , .. ...  αk.  ZORBA-I  usually  does 
not  develop  αc  in  one  step.  Rather, 

it 

572 

Session No.  14 Theorem Proving 

R.  E.  KLING 

incrementally  extends  some  limited  analogy  into 
one  that  maps  a  few  more  variables,  predicates, 
or  clauses.  This  process  is  described  in  f u ll 
detail  in  the  next  few  sections.  Here, 
I  just 
want  to  define  several  terms  that  refer  to  this 
process.  When  I  refer  to  "the  analogy  between 
T  and  TA"  1  refer  to  a  mapping  that  includes 
every  variable  in  the  statement  of  T,  and  every 
predicate  and  clause  used  in  the  proof  of  T. 
This  "complete"  mapping  is  obtained  as  the  final 
step  of  a  sequence  of  mappings  that  contain  the 
associations  of  some  predicates  and  some  clauses. 
I  refer  to  these  incomplete  mappings  as  "partial 
analogies," 
In  addition,  we  are  concerned  with 
an  important  relationship  between  two  (partial) 
analogies.  A  (partial  or  complete)  analogy αk. is 
an  extension  of  a  partial  analogy  αj  if  some  of 
is  a  submap  restriction  of 
αj,  e.g.,  αj
the  corresponding  submap  u.^  to  a  smaller  domain. 
Intuitively,  when  we  add  a  new  predicate  or 
clause  association  to  αj  so  as  to  create  αk,  we 
say  that  αj,  has  been  extended  to  G.  .  We  are  now 
ready  to  survey  ZORBA-I. 

p  ,  αc  G 

f 

AN OVERVIEW  OF  THE ANALOGY-GENERATING ALGORITHM 

I  want  to  describe  the  ZORBA-I  algorithm  in 

f i r st  briefly  in  this  section  and 

two  stages, 
then  in  greater  detail  in  the  following  two  sec­
tions. 
I  w i ll  precede  these  descriptions  by  some 
background  on  the  representations  and  information 
available  to  the  system. 

ZORBA-I  is  presented  with  the  following: 
(1)  A  new  theorem  to  prove,  TA. 
(2)  An  analogous  theorem  T  (chosen  by  the 

(3) 

user)  that  has  already  been  proved. 
Proof[Tl  that  is  an  ordered  set  of 
clauses  cK  s.t.  Vk  c^  is  either 
(a) 
(b) 
(c) 

A  clause  in  ~i T 
An  axiom 
Derived  by  resolution  from  two 
clauses 
c  and  c 

j  <  k  and  1  <  k. 

These  three  items  of  information  are  problem 

In  addition, 

the  user  specifies  a 
dependent. 
"semantic  template"  for  each  predicate  in  his 
language.  This  template  associates  a  semantic 
category  with  each  predicate  and  predicate-place 
and  is  used  to  help  constrain  the  predicate 
mappings  to  be  meaningful.  For  example, 
STRUCTURE[SET;  OPERATOR) 
is  associated  with  the 
predicate  "group."  Thus,  ZORBA-I  knows  that  "A" 
is  a  set  and  "*"  is  an  operator  when  it  sees 
group[A;*].  Currently, 
the  predicate  types  (for 
algebra)  are  STRUCTURE,  RELATION,  MAP,  and  REL-
STRUCTURE;  the  variable  types  are  SET,  OPERATOR, 
FUNCTION,  and  OBJECT. 

In  addition,  ZORBA-I  can  make  up  a  description 

descr[c]  of  any  clause  c  according  to  the  f o l­
lowing  rules  regarding  the  predicates  of  c. 

(1)  V  s.t.  p  and  -  p  appear  in  c,  impcond[p] 

(2)  V  s.t.  p  appears  in  c,  pos[p]  C  descr[c]. 
(3)  V  s.t.  —  p  appears  in  c,  neg[p] 

c  descr[c]. 

c  descr[c]. 

Thus,  the  axiom,  every  abelian  group  is  a  group, 
, 

e.g.,  V(x*)  abelian  [x; *1  =»  group  [x; *] 

is  expressed  by  the  clause 

c  :—i abelian  fx; *]  V  group  Tx; *1 

, 

which  is  described  by 

neg  [abelian],  pos  [group! 

Each  element  of  a  description,  e.g.,  pos[group], 
is  a  "feature"  of  the  description.  Each  feature 
corresponds  to  one  predicate,  so  the  number  of 
features  in  a  clause  equals  the  number  of  predi­
cates  in  the  clause.  The  theorem,  the  homomorphic 
image  of  a  group  is  a  group,  e.g., 

V (x y *  1 *  2ω ) 
horn  [ω>;x;y]  A  group  lx; *  1 
=> group  Ty; *.J 

is  expressed  by  the  clause 

c  :-i  horn  [cp;x;y|  V  -i group  lx; *  1  V  group  [y; *  ] 

and  is  described  by 

negI horn],  impcond[group] 

Two  different  clauses  may  have  the  same  description 
Let : 

c  :  -i.ntersecuonfxjy;*]  V  subset fx;y] 
intersection[x;y;z]  V  subset[x;z] 

c 
Then : 

descrlc  ]  =  descr[c  ]  =  neg[intersect ion], 
poslsubset| 
Clause  descriptions  are  used  to  characterize 

the  axioms  whose  analogs  we  seek.  ZORBA-1  selects 
as  analogs  clauses  that  have  descriptions  that  are 
close  to  the  analogs  of  the  descriptions  of  axioms 
in  the  known  axiom  set.  Although  in  a  special 
context  ZORBA-1  actually  uses  an  ordering  relation 
on  a  set  of  descriptions  to  find  a  "best  clause," 
it  usually  exploits  a  simpler  approach.  We  w i ll 
say  that  a  clause  c  satisfies  a  description  d  i ff 
d  c  descrlc].  Thus,  several  clauses  may  satisfy 
the  same  description. 

The  "analog  of  a  description"  is  defined  later. 

Session No.  14 Theorem Proving 

573 

R. E. KLING 

intersectionfx; y; 7 J V - grouply; *J 

Let : 
c 
V —i grouplz; *] V group[x; *] 
c : -n subgroup[x; y; *] V ~i subsetfx;yl 
6 
Then,  the  following  statements  are  true: 

(1) 
(2) 
(3) 
(4) 
(5) 
(6) 

,c

{c2
5  }  satisfy  impcondfgroupl 
{c1,c2,c5  }  satisiy  poslgroup] 
satisiies  neg[abelian],  pos[group] 
{c3,c4,C6 } satisiy  poslsubset] 
C6 satisfies  neglsubgroupj,  poslsubset 
No clause  of  these  six  satisfies 
pos [intersect ion] 

Clearly,  if  a  description  contains  only  a  few 

features,  then  several  clauses  may  satisfy  it. 

The  semantic  templates are  used  during  both 

the  INITIAL-MAP  (when  the  predicates and  variables 
in  the  theorem statements  are mapped)  as well  as 
in  the EXTENDER,  which adds  additional  predicates 
needed  lor  the  prooi  oi  T.  and  finds  a  set  of 

axioms  to  use  in  proving  TA.  The  clause  descrip­
tions are used only by EXTENDER. 

I  intend  the  brief  description  that  follows 
to  provide  an  overview  of  ZORBA-I  in  preview  to 
the  next  two  sections  of  text,  which  describe  it 
in  considerable  detail. 
In  addition,  this  preview 
section may be a  helpful  roadmap"  for reference 
when  the  reader  immerses  himself  in  the  details 
that  follow  later  on. 

ZORBA-I  operates  in  two  stages. 

INITIAL-MAP 

p and  Α  which  terminate  in  a  complete 

INITIAL-MAP  starts  without  a  priori  informa­

is  applied  to  the  statements  of  T and TA to  create 
an Α1
P which  is  used  by  EXTENDER  to  start  its  sc-
quence  of α1
u. 
tion  about  the  analogy  it  is  asked  to  help  create. 
Both  αp  and  α  are  empty  when  it  begins. 
It  uses 
the  system of  the wffs  that  express  T and T.  as 
well  as  the  restrictions  imposed  by  the  semantic 
categories  to generate OP and α1
v that  include all 
the  predicates  and  variables  that  appear  in  the 
two wffs.  For  example,  the  statements  of T1 -  T2 
can  contain  three  of  the  nine  predicates  used  in 
proollTj]  and  the  statements  of  T  -  T.  can  con­
tain  five  of  the  12  predicates  used  in  proof[T„]. 
In  brief,  it  provides  a  starting  point  from  which 
EXTENDER can develop a complete 0. 

The  INITIAL-MAP uses  a  rule of  inference 

called ATOMMATCH[atomjjatorn  ;0],  which extends 
analogy by adding  the predicates and mapped 
variables  of atom^  and aton^  to analogy OL.  Thus, 
ATOMMATCH now  limits ZORBA-I  to analogies where 
atoms  in  the  statements  of  T and T.  map one-one. 
INITIAL-MAP  is  a  sophisticated  search program 

Atoms,  not  predicates. 

that  sweeps  ATOMMATCH  over  likely  pairs  oi  atoms, 
one  of  which  is  from  the  statement  ol  T,  the  other 
1rom  the  statement  ol  T..  Alternative  analogies 
are  kept  in  parallel  (no  backup),  and  INITIAL-MAP 
terminates  when  it  has  found  some  analogy  that  in­
cludes  all  the  predicates  in  the  theorem  state­
ments.  This  one  is  output  as Ci!?. 

EXTENDER accepts a  partial analogy generated 

by  INITIAL-MAP and  uses  it  as  the  first  term  in a 
sequence  of  successive  analogies  0  The axioms 
used in pr oof \ T ] a re f ew in c ompa r 1 s on to the sr/e 
oi  the  large  data  base and  comprise  the  "domain" 
for a  complete 0  .  For each axiom used  in  proofIT1, 
we want  to find a  clause  from  the data  base  that 
is  analogous  to  it.  The  axioms  used  in  proolIT] 
are called AXSET and are used by EXTENDER in a 
special  way.  Each  partial  analogy ααp is  used  to 
partition  AXSET  into  three  disjoint  subsets  called 
ALLIOJ,  S0ME[0j,  and NONE[0 ]. 

If  all  the  predicates  in an axiom ax,  C AXSET 

k 

are  in  OP,  then  ax.  is  in  ALL[α  ];  if  some  of  its 

J 

k 

n 

predicates  are  in α1,p then  axk  is  in  S0ME[0  ]; 
and  if  none  of  its  predicates  are  in αJ,p then  axk 
is  in N0NE[α1 ].  For  brevity,  these  sets  will  be 
called ALL,  SOME, and NONE, and their dependence 
on α1 will  be  implicit.  This  partition  is  trivial 
to compute,  and  initially,  none  or a iew axk are 
in ALL, and most ax,  belong to SOME and NONE.  We 
that  contain  an  increasingly  larger  set  of 
predicates  and  their analogs. 
If  an  axiom  is  con­
want  to  develop  a  sequence  ol  analogies  α1,  j = 1, 
tained  in ALL,  then by definition we know the ana­
It  cannot  assist 
logs  of  each  of  its  predicates. 
us  in  learning about  new predicate associations. 
In contrast,  we  know nothing about  the analogs  of 
any  of  the  predicates  used  in  axioms  contained  in 
NONE.  Analog clauses  for  these axioms are  hard 
to deduce  since we have no relevant  information  to 
start  a  search.  Unlike  these  two extreme  cases, 
the  axioms  in  SOME  are  especially  helpful  and  will 
become  the  focus  of  our attention.  For  each  such 
axiom we know  the analogs ol  some of  its predi­
cates  from 0  .  These  provide  sufficient  inlorma-
tion  to  begin  a  search  for  the  clauses  that  are 
analogous  to them.  When we  finally associate an 
axiom with  its analog,  we can match their respec­
tive  descriptions  and  associate  the  predicates  of 
each that do not appear on  α1
P.  We can extend αJ 
to  α  and thus the analogs of axioms on SOME 
provide a bridge between the known and the un­
known,  between  the current 0  and a descendent 
G  , j.  When EXTENDER has satisfactorily terminated, 
ALL = AXSET, SOME = NONE = 0.  So the game becomes 
finding some way  to systematically move axioms 
from NONE to SOME to ALL in such a way that  for 
each axk moved,  some  analog  O,[axkl  -  axk  is  found 
that  can  be  used  in  the  proof  of  T  .  Moreover, 

A 

574 

Session No.  14 Theorem Proving 

each  new  association  of  clauses  should  help  us 
by  providing  information  about 
extend 
predicates  not  contained  in  ' 

A  DETAILED DESCRIPTION OF  INITIAL-MAP 

At  heart,  ZORBA-I  is  a  heuristic  program  de­

signed  to  generate  analogies  between  theorem  pairs 
stated  in  a  subset  of  predicate  calculus. 
It  has 
been  designed  and  implemented  in  a  f a i r ly  modular 
manner  to  f a c i l i t a te  understanding  and  ease  of 
generalization.  Thus,  much  of  the  system  can  be 
described  in  algorithmic  terms. 
In  this  section 
I  hope  to  blend  some  appreciation  of  the  heuristic 
foundations  of  the  program  while  describing  its 
operation  with  algorithmic  c l a r i t y.  ZORBA-I  uses 
an  interesting  set  of  searching  and  matching  rou­
tines,  which  have  been  empirically  designed, 
generalized,  and  tested  on  a  set  of  problem  pairs 
(T,  -  T„  and  T„  -  T4  are  f a ir  representatives  of 
this  set).  The  control  structures  of  INITIAL-MAP 
and  EXTENDER  have  been  designed  to  pass  f a i r ly 
similar  structures  to  the  various  match  routines 
(described  below).  Thus, 
the  following  descrip­
tions  w i ll  cover  cases  where  the  structures  to  be 
mapped  are  f a i r ly  similar.  For  example,  most  of 
the  routines  that  match  sets  of  items  assume  that 
the  sets  are  of  equal  cardinality  and  that  they 
w i ll  map  one-one.  Such  assumptions  are  valid  tor 
a  large  class  of  interesting  analogies  (such  as 
the  group-ring  analogy  in  abstract  algebra)  and 
simplify  the  description  ot  the  various  proce­
dures.  Analogies  that  require  weaker  assumptions 
and  more  complex  procedures  arc  described  else­
where.  (6) 

In  the  previous  section  I  motivated  the  design 
of  INITIAL-MAP  and  EXTENDER,  which  generate  a  re­
stricted  analogy  and  expand  it 
relations  and  axioms  necessary  for  the  now  proof. 
ZORBA-I  can  be  easily  expressed  in  terms  ot  these 
two  functions  as  follows: 

to  cover  a ll 

the 

zorba  |newwff;oldwff;AXSET  J:  -
(1)  Set  analogies  to  the  l i st  of  analogies 

generated  by  i n i t i al  map[nowwlt;oldwffI. 
(2)  Apply  extcnderTanalogy;  AXSET]  to  each 

analogy  or  analogies. 

* 

(3)  Return  the  resultant  set  of  analogies. 
The  preceding  description  allows  that  there  may 
be  more  than  one  analogy  generated  by  either 
INITIAL-MAP  or  EXTENDER. 
In  practice,  however, 
each  tends  to  generate  but  one  (good)  analogy. 
In  the  following  paragraphs  I  w i ll  describe 

AXSET  is  the  set  ot  axioms  that  appears  in 
proof[T]. 

INITIAL-MAP  in  some  detail.  EXTENDER  w i ll  be  dis­
cussed  in  the  next  section. 

INITIAL-MAP  is  designed  to  take  two  f i r s t-

INITIAL-

order  predicate  calculus  wffs  and  attempt  to  gene­
rate  a  mapping  between  the  predicates  and  variablee 
that  appear  in  them.  The  variable  mapping  infor­
mation  is  used  to  assist  INITIAL-MAP  in  mapping 
predicates  in  cases  of  seeming  ambiguity; 
MAP  outputs  a  set  of  associated  predicates  that 
appear  in  the  statements  of  T^  and  T.  This  re­
stricted  mapping  is  used  as  a  starting  analogy  by 
EXTENDER,  which  finds  a  complete  mapping  for  a ll 
the  predicates  used  in  proof[T].  As  a  byproduct 
EXTENDER  finds  analogs  for  each  of  the  axioms  on 
AXSET. 
reference  AXSET,  the  set  of  axioms  used  to  prove 
T,  and  is  symmetric  with  respect  to  caring  which 
wff  represents  the  proved  or  unproved  theorem. 
INITIAL-MAP  uses  atommatch[atorn]/, atom  ;  6]  as  a 
rule  of  inference  to  add  the  predicate/variable 
information  to  analogy  Ci.  As  its  name  hints, 
ATOMMATCH  matches  the  predicates  and  variables  of 
its  atomic  arguments  and  adds  the  resultant  mapping 
to  the  developing  analogy  (k). 

INITIAL-MAP  (unlike  EXTENDER)  does  not 

ATOMMATCH  is  used  as  an  elementary  operation 

by  every  matching  routine  in  the  INITIAL-MAP 
system  (Figure  3).  Thus,  we  w i ll  discuss  it  f i r st 

FIGURE  3  HIERARCHY OF  MATCHING  ROUTINES 

CALLED BY  INITIAL-MAP 

and  then  consider  how  INITIAL-MAP  is  organized  to 
apply  it  intelligently.  Consider  how  we  might 
write  an  ATOMMATCH.  Suppose,  atomj  and  aton^  are 
of  the  same  order  (same  number  oi  variables)  and 
each  variable  place  in  each  atom  has  the  same  se­
mantic  type.  For  example, 

let 

Session No.  14 Theorem Proving 

575 

R.  E.  KLING 

Clearly  we  want  to  associate  the  set  x  with  the 
set  y  and  the  operator  *1,  with  either  or  both  of 
*2  and  +  .  ATOMMATCH  can  know  which  variables 
represent  sets,  etc.,  by  checking  the  semantic 
templates  associated  with  group  and  ring.  Now, 
the  template  associated  with  group  is  structure 
[set;operator]  while  that  associated  with  ring  is 
structure[set; operator; operator].  We  w i ll  map 
variables  with  each  other  so  as  to  preserve 
predicate  place  ordering  and  semantic  type.  To 
handle  the  unequal  number  of  variables,  we  w i ll 
temporarily  expand  the  atom  group  [x;  *1]  to  i n­
clude  a  dummy  variable  of  type  operator, 
"dummyop,"  and  w i ll  rewrite  it  as  group[x,*1; 
dummyop].  The  symbol  "dummyop"  is  used  to  expand 
either  (or  both)  atoms  to  be  of  the  same  order 
and  a  variable  (possibly  dummy)  of  the  same  se­
mantic  type  in  corresponding  places  in  each  atom. 
Then  we  can  map  the  variables  one-one  in  order  of 
appearance.  For  example  we  can  associate 

Furthermore,  suppose  that  the  ordering  of  the  types 
is  the  same  in  each  template,  even  though  the 
number  of  variables  of  each  particular  type  need 
not  be  identical  for  corresponding  "type  blocks." 
Thus,  in  the  preceding  example,  in  both  "group" 
and 
ring"  the  type  set  precedes  the  type  operator. 
Each  template  has  one  set  variable,  but  a  differing 
number  of  operator  variablos.  Thus,  we  could  par­
t i t i on  the  ordered  set  of  variables  in  atom1  and 
atorn2  by  letting  some  x,  and  x  ,,  belong  to  the 
same  partition  if  type[x  =  type[x  . , ]•  Now  there 
are  an  equal  number  of  partitions  in  both  atom, 
and  atonU).  Returning  to  our  example,  we  partition 
group[x;  *j]  into  ("Cx], [*]_]]  and  the  ringfy;  *2; +>,] 
into  l [ y ], r*2;+2]]. 
the  order  of  elements  is  preserved.) 

(The  brackets  indicate  that 

(2)  Map  the  partitioned  subsets  into  each 

other,  preserving  their  order  within  the 
partitions,  and  map  elements  into  elements 
if  the  two  subsets  have  an  equal  number 
of  elements. 

This  completes  our  brief  description  of 

ATOMMATCH.  From  now  on,  we  w i ll  consider  ATOMMATCH 
as  an  elementary  operation  that  w i ll  expand  the  de­
veloping  analogy  to  include  a  (possibly)  new  predi­
cate  pair  and  (possibly)  new  pairs  of  variable 
associations.  We  need  to  know  how  to  select  pairs 
of  atoms  from  the  statements  of  T  and  T 
ATOMMATCHed. 

to  be 

We  have  two  wifs  representing  T and  T  as 

arguments  of  INITIAL-MAP,  and  we  want  to  find  some 
way  to  slide  ATOMMATCH  over  pairs  of  atoms  se­
lected  from  the  wffs.  First,  note  that  the  syntax 
of  the  wffs  may  be  a  helpful  guide  in  selecting 
potential  matches. 

Suppose  T:A =>  p(x) 
T  :B =*  q(y) 
A 

where  A  and  D  arc  any  wffs. 
We  would  presume  that  p **  q 
x **  y 
and  A m  B 

(predicates) 
(variables) 
(sub-wffs) 

? 

where  we  expect  that  wits  A  and  B  would  be  decom­
posed  down  to  atoms  for  ATOMMATCH. 
had  implication  signs  in  them,  we  could  decompose 
them  similarly.  There  are  many  possibilities  for 
the  forms  of  T  and  TA.  We  find  that  if  T  and  TA 
are  closely  analogous, 
then  their  syntactic  forms 
are  likely  to  be  very  similar.  ZORBA,  considers 

If  A  and  B 

576 

Session No.  14 Theorem Proving 

R. E. KLING 

T and T.  to have the formats that can be ropre 
sented by the generative grammar below 

A -> pTx  ...x ]  A p[x  ....xn] 

INITIAL-MAP  is  designed  to decompose  the  in 
put wffs T and TA into associated syntactic sub 
structures until a  subwff  is either an atom 

At  this  point  it  enters  a  hierarchy  of  selecting 
and matching routines  (Figure 3)  to decide which 
pairs of atoms shall be ATOMMATCHed.  Naturally, 
if  the  subwffs  are  just  atoms  it  calls  ATOMMATCH 
directly.  Otherwise,  it  enters  a  program hier­
archy headed by a routine named SETMATCH, which 
selects appropriate atom pairs from the sets of 
conjuncted atoms  in the subwffs. 

In  the following discussion,  the number of 
atoms conjuncted in each set are assumed equal 
(k = SL).  SETMATCH can be described in terms of 
its subfunctions as follows: 

Setmatch  [set  ;  set2;  ana]:  = 

(1)  Partition  the atoms  in  set1  and set2 

into subsets  that  have  identical  semantic 
templates  (a  "semantic  partition"). 
Thus  if  set1  is  grouptx; *] Δ abelian 
[y; *] Δ intersection! z; x; y]  the se­
mantic partition will be 
{{intersectionfz;x;y]j{grouplx; *], 
abelian[y; *]}  since group and abelian 
are  both of  type struct[set;op]. 

(2)  Select  the  partitions  of  set1  and  set2 

that have but one element and call  these 
sin1  and sing2 ,  respectively. 

(3)  The remaining partitions have more than 
one element;  call  them mult1 and mult,,, 
respectively. 

(4)  Match the atoms  in sing,  with those  in 

sing2 by executing singlematch[smg ; 
sing2;ana]. 

(5)  Match the remaining atoms by executing 

multimatch[mult  ;  mult  ;  ana|. 

SETMATCH, SINGLEMATCH, and MULTIMATCH are all 

heunst ically designed  one-pass matching strate­
gies that make strong assumptions about  the na­
ture ot  the theorem statements T and T^ for an 
analogous  theorem pair. 

When an analogy α. is referenced within the de­
scription of an algorithm,  it  will be  represented 
as a variable ana wherever that  is more convenient. 

SETMATCH assumes that the atoms in set-, and 
set2 will map one-one and that  the semantic parti­
tions will map one-one.  Suppose, we have a se­
mantic  partition  thus: 
partition  =  {{atom  atom  }  {atom  atom ]}  {atom } 
partition  -  {{atom  atom j  {atom  atom J J  {atom  j 
P 
10 
SETMATCH assumes that {atomc} and {atorairJ will 
correspond,  rather than iatom.J and,  say [atomfi 
atom7}. 
It  calls  SINGLEMATCH  to map  the  single-
atom partitions onto the single-atom partitions. 
In addition,  it  calls MULTIMATCH  to map,  in 

L  5 
9 

11 
2 

2 

3 

6 

7 

8 

4 

pairs,  the partitions containing several atoms 
each. 

MULTIMATCH assumes that the analogy will pre­

serve  semantic  type  sufficiently well  so that 
atoms within a  particular partition will  corre­
spond only  to atoms  in one other partition. 

Thus, if {atom .atom ] <-> [atom ,atom } 

' 
then  atom  ** atom  or atom 
atom  ** atom  or atom 
7 

12 
16 
2 

6 
7 

6 

7 

It  forbids matches across  partitions,  such as 

atom  ** atom 
6 
atom  ** atom 
8 
atom ** a t om , etc. 

1 
2 

3 

7' 

SINGLEMATCH and MULTIMATCH also share a common 
default  condition. 
If  all  but  one  of  the  elements 
ot a set X are mapped with all but one of the ele­
ments of a set Y,  then those two elements are as­
sociated by dciault without  any  further decision 
making.  In SINGLEMATCH the sets X and Y arc sets 
ot  atoms  or partitions  of atoms. 

^ 

1 

SINGLEMATCH [set ; set..; anal may be easily de-
scribed  in terms  of  this  default  condition and a 
function  called  tempsift[s,;s  ;testfn;ana]. 
TEMPSIFT applies  testfnjx;y]  to  the  first  element 
of  S-,  and each successive element y of s2 until 
it  finds  ay  €  s9  such  that  testfn|x;y  ]  -  T. 
It  then  executes 

atommatch[x; y  ;ana] 

, 

increments  to the next  element  of  x  of  si,  and 

II 

seeks  another y  e  s2,  such  that  testfrux  ;y  |  -
T,  etc.  Thus,  for every x  e  s  ,  it  finds  the 
first y € s2 such that  testfn[x;y]  - T and exe­
cutes atommatch[x;y]  = T.  Typical testfns check 
whether x and y have the same semantic template 
or are analogs  of each other according to the de­
veloping analogy,  ana.  Singlematch[set,; sct2; 
ana]: = 

(1)  If  set}  and  set„  have but  one eloment 

("terminal default condition"),  go to 8. 

Session No.  14 Theorem Proving 

577 

R. E. KLING 

predicates have the same type, e.g., STRUCTURE, 
then we expect  these partitions to be associated. 
Let MULTIMATCH1 name the function that actually 
associates atoms within a  partition according  to 
analogy ana. 

MULTIMATCH(set  ;set,;ana|:= 
(1) 

If  the  terminal  default  condition  for 
partitions holds,  go to 7. 

(2)  Let  pred[x]  -  the  predicate  letter  of 

atom x.  For each partition  y,  sequence 
through  each atomx  e  y. 
If  pred[x]  is 
on analogy ana 1 md the partition z c 
set2 such  that  the analog of  prcd[x]  ap­
pears  in  z.  Execute MULTIMATCH1 
[y;z;ana]  for each  such  pair  y,z. 
If  the  terminal  default  condition  holds, 
go to 7.  If  set.  and set2 are empty,  go 
to 8. 

(3) 

(4)  For each partition y e set-.,  select  the 
first atom x.  Find a partition z € set0 
such  that  the  type of  predicates  in  z 
equals  type  [x]. 
If  there  is  only  one 
such z C set2, execute MULTIMATCHl[y;z; 
ana]. 
If  the  terminal  default  condition  holds, 
go to 7.  If  set,  and  set9 are empty,  go 
to 8. 
Ii  set,  or  set 
print  an error message and halt. 

is  still  not  exhausted, 

(7)  Apply MULTIMATCH1 to the remaining parti 

(5) 

(6) 

tions  in  set  and  set  . 

(8)  STOP. 
Each set of atoms  in a partition has the same 

semantic  template.  This  property  defines a  par­
tition.  Thus,  at  the  level  of  abstraction  pro­
vided by the templates,  all of  these atoms are 
alike and any differences need to be discriminated 
by other criteria.  Let  us consider an example to 
motivate the design of MULTIMATCH1.  The theorem 
pair T3 - T  can be written as: 

(2) Execute tempsif t[set,; set2; testfn..; ana] , 

(3) 

where  testfn^txjyj  is  true  iff  x and  y 
have the same semantic template. 
If  set1  and set2, are  empty,  go  to 9. 
If  the  terminal  default  condition  is 
true, go to 8. 

(4)  Execute tempsif t[set-p set2; tcstfn2; ana], 

where  testf^txjy]  is  true  iff  the  pre­
dicate  letter  in atom y  is  the analog 
of  the  predicate  letter  of  that  in 
atom x according to analogy ana. 
If  set1  and  set2  are  empty,  go  to 9. 
If  terminal  default  conditions  holds, 
go to 8. 
Execute  tempsift[set  ;set2;testfn3  ana], 
where  testfn3[x;yj  is  true  iff  the  type 
of  the predicate  appearing  in atom x  is 
the same as the semantic type of  the 
predicate appearing  in atom y. 
If  set1  and  set2  are  empty,  go  to 9. 
If  the  terminal  default  condition  holds, 
go to 8.  Otherwise print an error 
message and halt. 

(5) 

(6) 

(7) 

(8)  Apply ATOMMATCH to the remaining atoms 

of  set  and  set2. 

(9)  STOP. 

To illustrate the preceding algorithm with a 
simple example,  let 

set,  =  fintersection[x;y;z],  abeliangroup[x;*1J 
set2  =  {intersection[u;v;w], 

commutativeringlu; *; I] J 

Step 2 associates 

intersectionlx;y;zj <-> intersection[u;v;w] 

and  the  terminal  default  condition associates 
abeliangroup[x; *] *=* commutativeringlu; *; -] J 
MULTIMATCH is a  little more complex than 

If  both  sets 

SINGLEMATCH.  First we need to decide which par­
titions are  to be associated before associating 
atoms within partitions.  Suppose we have two 
sets  of  partitions  set,  and  set2> 
have but one partition each (a common case), 
then we expect these to be associated by default 
and  declare  them  accordingly.  Secondly,  if  in 
some partition of  set1  there  is  an atom with 
predicate p which is known to be analogous  to 
predicate q,  then  the  partition  in  set2  that  con­
tains q should be associated with that which con­
tains  p.  Remember  that  these partitions were 
constructed on  the basis of semantic templates. 
Thus, while several atoms containing a predicate 
p may be  in a particular partition,  there will 
be only one partition that contains atoms with 
predicate  p.  Lastly,  if  in  set1  and  set2  there 
is  but  one partition  that contains atoms whose 

578 

Session No.  14 Theorem Proving 

R. E. KLING 

when  it  decomposes  T 3' - T4' into  subwffs  dis­
tinguished  by  the  syntax  of  the  implication  sign. 
Later an application  of  SINGLEMATCH adds: 

propernormal ** proper ideal 

iactorstructure ** factorstructure 

MULTIMATCH  is  passed  one  partition  from each wff 
T  contributes 
3 

{groupLg;*  ],  simplegroup[x; * ] }, 

and T  contributes 

4 
[ring[r;  *2;+2],  simplering[y;  *2  ; +2]}. 
If  we  apply  the MULTIMATCH algorithm  just 

Step 3 

Step 2 

Step 1 

described  to each of  these  partitions,  we  find: 
We do not satisfy the terminal  de­
fault  condition. 
None  of  the  predicates  that  appear 
in  these  partitions  appear  on  the 
current analogy.  We gather no new 
information  here. 
We s t i ll do not  satisfy the  terminal 
default  condition. 
We want  to use  MULTIMATCHI  to asso­
ciate  the  atoms  in  these  partitions. 
Of  these  two  partitions,  the  former  pair  have  the 
template structure[set; operator]  and  the  latter 
pair  have  structureTset;operator;opera tor]. 
Fortunately,  our  analogy  has  variable  mapping  in­
formation  that  is quite  relevant  here.  We  know 
that: 

Step 4 

g ~ r 

We  can  assume  that  if  some  variable appears  in 
only  one atom  in  a  partition,  the  analogous  atom 
is  one  that  contains  its  analog  variable,  if  it 
too appears  in  only  one  atom.  For  example,  the 
variable  "g"  appears  only  in  group! gj*  ],  and  its 
analog  "r"  appears  only  in  nng[r; * ;+2 ].  So,  we 
deduce: 

group!g; * ]  ~ ring[r; *  ;-J  ] 

A similar argument based upon 

leads  us  to deduce: 

simplegroupfx; *  ]  simplenng[y; * ';+ 2] 

although we could have also deduced  this  last 
association  by  our  terminal  default  condition. 
Notice  that  "*  "  is  not  a  discriminating  variable 
since  it  appears  in  both  groupfg;*1,]  and  simple-
groupLx; *  ].  After  each  atom  pair  is  associated, 
we  apply ATOMMATCH  to  it  to  deduce  more  variable 
associations  and  update  our  analogy. 

The preceding description of MULTIMATCH1 can 

be  simplified and generalized by realizing  that 
we are  just  using a  specialized submap of  the de­
veloping  analogy  to  extend  it  further.  This 
special  submap  is  just  that  mapping  of  variables 
where  each  variable  appears  in  only one  atom of 
the  partition. 
submap was just: 

In  the  preceding  example,  the 

MultimatchlCpartition  ;partition, ;ana]:  -

(1)  Set 

to  a  list  of  variables  that  appear 

in  only  one  atom  of  partition  . 

(2)  Set  i 

to  similar  list  computed  on 

INITIAL-MAP has  been completely described. 
At  this  point  we  have  sufficient  machinery  to 
generate a mapping between  the predicates and 
variables  that  appear  in  the  statements  of  theorem 
pairs  such as T1 - T2 and T3 -  T  .  Next we want 
to  extend  this  mapping  to  include  all  the  predi­
cates  that  appeared  in  the  proof  of  the  proved 
theorem  T  and  are  likely  to  appear  in  the  proof 
of  the  new  theorem T.. 
to  pick  up  a  small  set  of  axioms  adequate  ior 
proving T  .  EXTENDER performs  both functions 

In  addition,  we  would  like 

A DETAILED DESCRIPTION OF EXTENDER 

In  the  last  section  1  described  INITIAL-MAP 
In  comparison,  EXTENDER 
in  substantial  detail. 
is  a  far more  complex and  subtle  system which  I 
will  explicate  here  less  completely.  1  intend  to 
accomplish  several  simple  aims  with  this  limited 
exposition: 

(1)  Expose  the  reader  to  the motivation  and 

rationale  underlying  the  EXTENDER design. 

(2)  Convey  some  appreciation  for  the  flavor 
of  some  well-specified  computational  al­
gorithms  for  creating  an  analogy. 

(3)  Provide an  intelligible,  self-contained, 

introductory  account  of EXTENDER  adequate 
for  the  general  reader,  and  motivate  the 
more  sophisticated  specialist  to  consult 
a  more  complete exposition.  (6) 

Session No.  14  Theorem  Proving 

579 

R.  E.  KLING 

I  w i ll  begin  by  explicating 
then  develop  MAPDESCR—the  clause  descrip­

The  rationale  of  EXTENDER  depends  upon  a  few 
simple  related  ideas. 
these, 
t i on  mapping  operation—and  conclude  with  a  d i s­
cussion  of 
In  the 

two  simple  versions  of  EXTENDER. 
last  section 

I  suggested  that  our  com­

in  general, 

in  p a r a l l e l, 

they  a ll  begin  with  the 

increasingly  more  complete 

plete  analogy  could  be  seen  as  the  last  map  αn 
in  a  series  αJ  of 
analogies.  Although  we  may  be  developing  several 
such  series 
same  α1—the  analogy  produced  by  INITIAL-MAP. 
Each  G  maps  some  subset  of  the  predicates  that 
appear  in  the  proof  of  theorem  T.  Each  d i s t i n ct 
lead  to  a  d i f f e r e nt  par­
subset  w i l l, 
t i t i on  of  AXSET  into  [ALL,  SCME,  NONE}.  When  we 
search  for  the  analog  oi  an  axiom  (clause),  we 
w i ll 
analog  of 
analogy.  Each  clause  has  a  unique  description, 
descrTc],  which  has  been  introduced  in  a  previous 
section.  We  w i ll  denote  the  analog  of  descrfc] 
by  some  analogy  G  as  G  [ d e s c r [ c ] ].  G  rdescrTc]] 
is  equal 
predicate  that  appears 
analogous  predicate.  Predicates  that  are  absent 
from  G  are  l e ft  untouched.  For  example,  suppose 
we  have  a  t r i v i al  Gj: 

J 
in  α1  is  replaced  by  i ts 

the 
the  current 

to  a  copy  of  descr[c] 

i ts  description  under 

look  f or  some  clause 

in  which  every 

that  s a t i s f i es 

J 

J 

G  : 
1 

abelian 

r  commutativering 

c  :  ~"i  abeliunlx;  *]  V  group [r,  *] 
negfabelianl,pos[group].  -  descrlc  ] 
: 
d 
7 
7 
G  [ cl  ]  -neg  commutat lvering] ,pos[group] . 
1  7 
Suppose  we  are  seeking  to  extend  G^  by  finding 

It 
that  s a t i s f i es 

is  quite  unlikely  that  we 
this  descrip­
(G^fd_]),  since  it  would  be  derived  from 

the  analog  of  C7. 
f i nd  a  clause 
w i ll 
t i o n, 
some  (rare)  theorem  that  relates  a  condition  on 
In  any 
commutative  rings  to  a  group  structure. 
event, 
It  we 
it  would  not  be  an  analog  of  c~. 
sought  a ll 
that  s a t i s f i ed  neg[commu-
tat i v e r i n g ],  we  would  be  sure  to  include  c»  and 
cq,  which  at 
desire, 

the  clause  we 

the  clauses 

include  c „, 

least 

-y  commutat ivering[x;  *;  f]  v  r i n g l x;  *;  1J 

c  : 
o 
c  :  ~i  commutat ivcringl x;  *;( ]  V  commutativeT*; x] 

to  search  for  clauses  that 

Thus ,  somct imet»  we  want 
sa t l s ly  descriptions  with  leatures,  e . g ., 
negIcommutat i v e r i n g ], 
that  appear  on  a  p a r t i c u l ar  analogy  Ci 
what  we  arc  doing  is  a  four-step  process: 

Now, 

t hat  conta in  only  prcdica tes 

(1)  Make  a  description  d  for  an  axiom 

clause  c,  d e s c r l c ]. 

(2)  Create  an  analog  description  C  fdescr[c]l 

for  the  current  analogy,  G  . 

(3)  Delete  from  G,[descr[c]]  any  feature  that 
contains  a  predicate  that  does  not  appear 
in  6  .  Denote  t h is  r e s t r i c t i on  of 
Qu[descr(c)]  to  Ci  by  6  [descr(c)] . 
Search  the  data  base  for  clauses  that 
s a t i s fy  CL  [descr(c)] . 

(4) 

In  our  example,  6,[descrfc  ]]  =  G,[d7]  = 

the  analog  of  the  description  of  c  to 

neg[commutetivenng] .  Ci  [descr(c)]  is  a  " r e s t r i c­
tion  of 
analogy  6P."  Since  this  phrase  is  quite  cumber-
some,  we  w i ll  simply  c a ll  it  a 
r e s t r i c t ed  descrip­
t i o n"  and  i m p l i c i t ly  understand  i ts  dependence  on 
j 

At  d i f f e r e nt  times  EXTENDER  may  seek  clauses 

that  s a t i s fy  a  complete  analogous  description 
G  [descr]  or  /just  a  r e s t r i c t ed  one  G  [descr] . 
summary,  EXTENDER  r e l i es  upon  four  key  notions: 

In 

(1)  An  ordered  sequence  of  p a r t i al  analogies 

a. i-

(2)  A  p a r t i t i on  of  the  axioms  used  in  proof 

into  three  d i s j o i nt  sets: 

(AXSET) 

[T] 
ALL,  SOME,  and  NONE 
(3)  A  search  for  clauses 

that  s a t i s fy 

the 

the  description  of 

the  clauses 

analogs  ot 
in  p r o o f [ T ]. 

(4)  A  r e s t r i c t i on  of  our  descriptions  r e l a­
t i ve  to  an  analogy  Gj  by  including  only 
that  ap­
those  ieatures  with  predicates 
pear 

in  G-j. 

INITIAL-MAP  used  an  operation  called 

Likewise,  EXTENDER  uses  an 

ATOMMATCH  in  a  rather  clever  way  to  extend  i ts 
current  analogy. 
operation  called  MAPDESCR  for  a  similar  purpose. 
Both  operations  use  abstract  descriptions 
to  associate  t h e ir  data:  ATOMMATCH  uses  the  se­
mantic  template  associated  with  a  predicate,  and 
MAPDESCR  uses 
it 
is  associating.  EXTENDER  and  INITIAL-MAP  d i f f er 
in  that  EXTENDER  generates  a  new  p a r t i al  analogy 
each  time 
mapping 
to  expand  one  growing  analogy. 

it  activates  MAPDESCR  (and  the  resultant 
is  new)  while  INITIAL-MAP  uses  ATOMMATCH 

the  description  oi 

the  clauses 

in  order 

Each  p a r t i al  analogy  G 
J 

antecedent  G  ^  by  adding 

is  derived  lrom  i ts 

(1)  An  association  of  one  clause  ax  €  SOME 

with  one  or  more  clauses  lrom  the  data 
base. 

(2)  An  association  oi 

the  predicates 

in 

those  clauses. 

is 

the 

A  simple  example  w i ll 
G. 
MAP  applied  to  the  pair  of 
predicate  map 

is 

i n i t i al  analogy  generated  by  INITIAL-
i ts 

theorems  Tj-T^, 

i l l u s t r a te  this  amply. 

11 

580 

Session No.  14 Theorem Proving 

abelian 

commutat lvering 

intersection <=> intersection. 

R.  E.  KLING 

(b) 

Suppose  we  know  that  c_  •* Cy.  We  would  like 
extend  G 

to  G  by  adding: 

to 

(1)  c? 
c8 
(2)  abelian 
group 

conunutat lvering 
ring. 

to  G 

To  motivate  the  structure  of  MAPDESCR,  let 
us  design  a  version  of  it  that  would  enable  us 
to  extend  0. 
charged  with  mapping  neg[abelianl,  posjgroupl 
(d_)  with  negtcommutatlveringl,  posfnngj,  when 
it  knows 

in  this  example.  MAPDESCH  is 

that: 
G  :  abelian  ••  commuta t lvering 

intersect  ion 

intersection. 

First,  we  can  eliminate  negfabelian]  from  d  and 
neg[commutativeringJ  from  d  on  the  basis  of  G 
which  associates  "abelian"  and  "commutatlvering." 

G|[neglabelian]]  -  negtcommutatlvering]1. 

Now  we  are  simply  left  with  associating  pos[group) 
and  pos[ring].  Since  these  are  the  only  two 
elements  l e t t,  have  the  same  semantic  type 
(STRUCTURE),  and  have  the  same  feature  (pos),  we 
can  map  them  by  default  and  add 

group 

ring 

to  G  . 2 

Now,  we  can  write  a  version  of  MAPDESCR 

which  accepts  as  arguments  two  clause  descriptions 
and  an  analogy  G  : 

mantically  compatible  predicates, 
associate  those  terms  and  delete 
them  from  the  remnant  descriptions. 
Here  "semantic  compatibility"  means 
"same  semantic  type." 

If  more  than  one  element  of  descr 
and  descr  have  the  same  feature. 
' 

2 

e.g.,  pos,  then  discriminate  within 
these  elements  on  the  basis  of  the 
semantic  types  of  their  predicates. 

l i st  of  paired 

(4) 

Return  the  resultant 
predicates. 

three,  or  four  features. 

Thus,  by  the  time  we  reach  step  3  of  the 

Most  often  in  my  algebra  data  base  a  clause  de­
scription  consists  of  two, 
EXTENDER  ensures  that  some  of  the  predicates  in 
any  pair  of  clauses  passed  on  to  MAPDESCR  are  on 
G 
MAPDESCR  algorithm  we  often  have  descriptions  of 
length  one,  which  map  t r i v i a l ly  by  default,  or 
descriptions  oi 
e.g.,  pos  and  neg.  Thus,  step  3b,  which  requires 
disambiguation  based  upon  predicate  types,  occurs 
rarely  in  this  domain  (abstract  algebra). 

length  two  with  different  features, 

When  MAPDESCR  returns  a  l i st  of  predicates 

pairs  that  result  from  mapping  the  description  of 
a  clause  c  (descr  ,  above)  with  the  description 
of  a  clause  c  (descr  ,  above)  according  to  analogy 
G,,  it  creates  a  new  analogy  G 
same  as  G  except  that 

the 

G 

is 

(1) 

(2) 

Its  predicate  map  is  the  union  of  the 
one  returned  by  MAPDESCR  and  the  one 
appearing  on  G  . 
Its  clause  mapping  is  the  union  of  the 
one  appearing  on  Gj  and c1 <=> c2. 

Thus,  when  EXTENDER  is  attempting  to  extend 

G 

G  ,  it  creates  a  new  analogy  G 
,  etc.  for 
each  clause  pair  it  maps  when  those  clauses  were 
selected  on  the  basis  of  information  in  G  .  Of 
course, 
there  is  a  procedure  to  see  whether  the 
predicate  associations  of  a  new  analogy  have  ap­
peared  in  some  previously  generated  analogy  and 
thus  prevent  the  creation  of  redundant  analogies. 
In  this  case  the  two  corresponding  clauses  are 
added  to  each  existing  analogy  for  which  the 
predicate  pairs  returned  by  MAPDESCR  are  a  subset 
of  its  clause  map. 

After  I  explicate  one  additional  idea  I  can 

describe  a  simple  version  of  EXTENDER.  When 
EXTENDER  is  extending  G.  it  is  searching  the 
large  data  base  for  some  clause  that  is  the  analog 
of  an  axiom  c,  C  SOME.  Now  we  could  search  for 
the  set  of  clauses  that  satisfy  Gj[descrCc^]], 
but  we  w i ll  run  into  the  d i f f i c u l ty  described 
earlier  in  this  section.  Thus,  we  search  for 
clauses  that  satisfy  G\, [descr[ck] ] . 
tains  the  correct  analog  for  each  predicate  that 
appears  on  i t,  then  the  set  of  clauses  C  that 
is  guaranteed  to  contain 
satisfy  Ga[descr[cjJ] 
the  desired  analog  of  c 
("image"  of  c  ).  We 

If  G,  con­

Session No.  14 Theorem Proving 

581 

R. E. KLINC 

will  reier  to C as  the  candidate  image  set. 
Suppose that C has but  one member, e' .  Then we 
know  that  c  is  the  analog  (image)  of  ck  and 
should  e x t e n d a s s o c i n t i ng 

" 

/ 

When  the  set  of  clauses  that  satisfies  a  re-
st ricted  description  contains  only  one,  we are 
guaranteed  that  it  is  the  image  clause  we  seek 
i1 OP does not contain any erroneous associations 
Now,  if C  is  empty,  we have  reason  to suspect 
t he correctness of &P and we ought to s top de­
veloping  this  branch  of  the  analogy  search 
space.  On  the other hand,  if  C has more than 
one member, and GP is correct, we know that our 
desired  image  is  in C.  If we have a  clause c 
with description descrlcl and some ana logy G 
that  contains  only  one  of  the  predicates  in  c, 
then Ci Tdescr[c] ] wi 11 have but one f ea ture and 
many  clauses  will  satisfy  it. 
analogy ti^ (CLP — &Y) includes another predicate 
from c  in addition  to  the one on G 
G.fdescrfc]]  will  have  two fea t ures and will  be 
satisfied by fewer clauses than G . [descr[c]1. 
Thus,  as  sequence ol  analogies evolve,  each 
clause wi11 have decreasingly fewer Candida t e 
images t ha t sa t isfy its rest ricted description. 
To  search  for  the  clauses  that  satisfy  the 

If  some  later 

then 

analog  of  a  restricted  (short)  description, 
EXTENDER,  invokes  an  operator  shortdescr[G  ]. 
SHORTDESCR  is dependent  on G  in  three ways: 

(1)  It  searches  1 or  the  ana logs  of  clauses 
t hat appear on SOME  (which  is ditierent 
for each G ). 
It  generates  descript)ons  that  inc lude 
only  the  predicat es  that  appear expli-
citly in G . 
1 

(2 ) 

r 

(3)  It  uses  the  predicate map G  . 

1 

SHORTDESCR  returns  a  (possibly  empty)  list  of 
axioms  (from SOME),  each  of  which  is  paired with 
a  set  of  clauses  from  the  data  base which  satisfy 
the  analog  of  its  restricted  description.  Each 
axiom  is guaranteed  to have  its analog under G 
If  we 
in  its  associated  "candidate  image  set.n 
find no candidates at  all,  for any ax.  € SOME, 
then we know that G  contains some wrong predi­
cate associations,  and we  ought  to mark  it  as 
1 infertile" and discont mue attempting  to extend 
it.  Of the  images we find,  we prefer those 
axiom-candidate associations with  but  one  candi­
date  linage. 
If  we apply MAPDESCR to each  such 
pair, we can be sure that we have a consistent 
extension  of G,.  Let  us  consider a  primitive 
version of EXTENDER,  EXTENDERl,  which exploits 
these few ideas. 
EXTENDI  [G ;AXLIST]:= 

The  success  of  EXTENDI  is  highly  dependent 

If  there  are 

upon  the  clauses  in  the  data  base. 
few  clauses  then  it  is  likely  that  some  ax.  € 
SOME will have but one  image under SHORTDESCR at 
each  iteration and t hat  EXTENDI  will  be  successlul 
As  the  data  base  increases  in  size with ever more 
clauses  involving  predicates  that  will  appear  in 
proof n \ ],  then  It  becomes  more  likely  for 
SHORTDESCR  to generate  several  imaees  for  every 
ax,  €  SOME  in  some  iteration.  At  this  point  it 
will  fail  to EXTEND &  and miss  the  analogy al-
t ogether- To remedy this situation, we need a 
way tor dealing with cases when SHORTDESCR returns 
several candidate images for each ax.  € SOME.  We 
need  some way  to select  the clause  from  the  can­
didate  set  that  is  most  likely  to  be  the  analog 
we seek.  When EXTENDER meets a situation of this 
sort,  it  orders  all  the  images  according  to  their 
likelihood of being analogous  to the ax.  C AXSET 
I  will  mi 11ate  the 
with which  they  are  pai red . 
description of one such ordering relation by a 
simple example. 

Consider,  1 or example,  the clause c  and an 

ana logy G9 that includes 

582 

Session No.  14 Theorem Proving 

R.  £.  KLING 

We  can  compare  c11  and  c12  by  comparing  d11  and 
d12  with  d  10  (relative  t o We  want  a  partial 
ordering  of  a  set  of  descriptions  relative  to  a 
target  description  and  a  particular  analogy,  e.g., 
a 

that  orders  description  d 

10 

.[d,;d9;d;6  ] 
o  1  +• 
J 

with  respect  to  d2-  A  simple  cp^  can  be  developed 
as  follows: 

1 

For  d,  and  d  compute  the  number  of  features, 
eg•>  P°s,  in  common  with  d  .  The  description 
with  the  most  features  in  common  is  closest  to  d. 

In  our  example,  we  have 

d 
d' 
d 

=  neg[group],  neg[subset] 
-  neglidealj 
=  negTring],  negfsubset]. 
than  d 

is  closer  to  d 

Clearly  d 

7  12 
our  closest  description  and  c 

,  so  we 
lT 
as  the 
12 
under  C  .  After  MAPDESCK  maps 

1Q 

select  d 

12 
image  of  c 
c 
10 

**  C 

12 

10 
2 
it  w i ll  add: 

group  °  ring 
subset  °  subset 

A  more  sophisticated  '4^  can  look  at  the  semantic-
types  of  predicate  that  share  common  leatures  if 
two  descriptions  are  equivalent  under  the  simple 

described  above.  EXTENDER  uses  an  operator 
called  MULTIMAP  to  select  the  best  image  (using 

for  a  clause  that  has  several  candidates 

images  with  a  restricted  description  under 
Exploiting  this  notion,  we  can  write  a  more 
powerful  EXTENDER  called  EXTEND2. 
EXTEND2 
(1) 

[Q  ;AXSET]:  -

active  analogies.  Start  with  ana l i st 

. 

(2) 
(3) 

is  complete,  STOP. 

If  Q 
Partition  AXSET  into  [ALL,  SOME,  NONE) 
relative  to  Ct 

(4)  Set 

lmlist 

to  shortdescrTCi  ]. 

If 

lmlist  -  0,  mark  CL  as  " i n f e r t i l e"  and 
go  to  8. 

(5)  Set  unimages  to  the  subset  of  lmlist 

that  has  only  one  candidate  analog  for 
0,  go  to  7. 
each  axiom. 

If  unimages 

(6)  Apply  MAPDESCR  to  each  axiom  and  i ts 
If 

analog  that  appears  on  unimages. 
MAPDESCR  adds  a  new  analogy,  add  it  to 
the  end  of  anallst.  Go  to  8. 

(7)  Apply  MULTIMAP  to  imlist  to  select  an 
optimal  candidate  image  under  cp .  for 
each  axiom.  Set  unimages  to  this  l i st 
of  axioms  paired  with  best  candidates. 
Co  to  6. 
If  analist  is  empty,  STOP.  Otherwise, 
set  d 
to  the  next  element  on  analist. 
Go  to  2. 

(8) 

This  version  of  EXTENDER  is  quite  powerful 
and  w i ll  handle  a  wide  variety  of  theorem  pairs. 
The  reader  who  is  interested  in  the  behavior  of 
EXTENDER  in  generating  the  sequency  6 
is  referred 
to  a  more  detailed  report  (6)  for  case  studies  and 
further  explication.  The  implemented  versions  oi 
EXTENDER  are  far  more  complex  than  these  simpli­
fied  tutorial  versions.  They  (1)  allow  backup, 
(2)  have  operations  for  combining  a  set  of  partial 
analogies  into  a  "larger"  analogy  consistent  with 
a ll  of  them,  (3)  have  a  sophisticated  evaluation 
for  deciding  which  particular  axiom-candidate  set 
to  pass  to  MULTIMAP  (in  lieu  of  step  7  above),  and 
(4)  can  often  localize  which  predicate  associa­
tions  are  contributing  to  an  i n f e r t i le  analogy 
when  one  is  generated.  Table  2B  contains  a  brief 
summary  of  ZORHA-I's  behavior  when  it  is  applied 
to  live  T-TA  pairs  drawn  from  abstract  algebra. 
The  number  of  partial  analogies  generated  i n­
cludes  (J.  generated  by  INITIAL-MAP. 

Table  2A 

THEOREMS  REFERENCED  IN  TABLE  2B 

Tl.  The  intersection  of  two  abell an  groups 

is  an  abelian  group. 

T2.  The  intersection  of  two  commutative 

rings  is  a  cummutative  ring. 

T3.  A  lac tor  group  G/H  is  simple  i ll  H  is  a 

maximal  normal  subgroup  ol  G. 

14.  A  quotient  ring  A/C  is  simple  l fl  C  is  a 

'lt>.  The  intersection  of  two  normal  groups  is 

maximal  ideal  in  A. 

a  normal  group. 

T6.  The  intersections  oi  two  ideals  is  an 

T7.  The  homomorphic  image  oi  a  subgroup  is 

T8.  The  homomorphic  image  oi  a  subring  is  a 

idea 1. 

a  subgroup. 

subring. 

T9.  The  homomorphic  image  of  an  abelian 

group  is  an  abelian  group. 

T10.  The  homomorphic  image  of  a  commutative 

ring  is  a  commulntive  ring. 

Session No. 14 Theorem Proving 

583 

R.  E.  KLING 

T 1 ':  abelian  [AΑ;  *1]  Δ  abelian  [b; *1 ] Δ 

intersection[c;a;b]  =  abelian[c; *1 ] 

T5':  abelian[x;  *2]  Δ  cring[y;*2;+2]  Δ 

intersection^; x;y]  -  abelian[z;  ^] 

ATOMMATCH can map 

abelian[c; *  ]  **  abelian[z; *  ] 
and  abelian[b; *  ]  **  cring[y; *  ; 4-  ] 
at  different  times  and  handle  many-one  predicate 
maps.  However,  the  EXTENDER  would  need  to  know 
(and  It  does  not  yet)  how  to  handle  this  ambiguous 
information. 

The  second  restriction  is  created  by  the  ex­
tension  of  the  analogy  by  finding  image  clauses 
that  satisfy  the  incrementally  improved  analogy. 
To  state  this  condition  on  the  image  clauses  in  a 
formal  way,  I  need  to  introduce  some  simple  termi­
nology.  Let  us  say  that  a  clause  c  bridges  a  set 
of  predicates  P 
X 
i f f: 

to  another  set  of  predicates  P 
2 

preds[T]  -  predicates  used  in  proof  of  T. 
Pr[T]  =  predicates  used  in  statement  of  T 
k  -  analogy  from  T  to  T  . 
A 
descr[cl  =  description  of  clause  c. 
CL[descr[c]]  -  analog  description  of  the 
description  of  c  under  Ci. 
AXSET  -  axioms  used  in  proof  of  T. 

NECESSARY CONDITIONS FOR AN ANALOGY 

ZORBA-1  has  three  necessary  conditions  for 
creating  an  analogy.  The  f i r s t,  created  by  the 
form  of  ATOMMATCH,  pertains  to  the  form  of  the 
statements  of  T  and  T  . A 

(1) 

In  the  statements  of  T  and  TA,  atoms 
must  map  one-one  from  T  to  T  . 
A 

r 

Notice  that  we  do  not  insist  that  predicates  map 
one-one.  Consider  an  INITIAL-MAP  between 

Tl: 

T5: 

and 

The  intersection  of  two  abelian  groups 
is  an  abelian  group 

The  intersection  of  an  abelian  group 
and  a  commutative  ring  is  an  abelian 
group 

584 

Session No.  14 Theorem Proving 

R.  E.  KLING 

More  verbally,  some  subset  of  the  axioms  in 

the  proof  of  T  that  bridge  R  the  domain  of 
INITIAL-MAP  to  preds[TA]  has  a  set  of  image 
clauses  under  G  that  bridge  the  images  of 
INITIAL-MAP  to  predsfT  ].  Thus,  the  proofs  need 
not  be  isomorphic,  merely  that  some  subset  of  the 
axioms  have  a  nearly  isomorphic  set  of  image 
axioms,  similarly  restricted  to  the  bridging 
condition. 

This  bridging  condition  may  seem  rather  non-

mtuitivc  from  the  vantage  point  of  choosing  a 
data  base,  but  it  should  be  clear  that  EXTENDER 
imposes  this  condition. 

To  develop  analogies  in  domains  that  are  de­

scribed  by  predicate  calculus  with  constants 
would  require  wholly  different  analysis  algorithms 
Consider  a  robot  that  is  instructed  to  go  from 
SRI  to  (1)  an  office  on  its  floor,  (2)  Stanford 
University,  (3)  San  Francisco,  (4)  New  York  City, 
(5)  Chicago.  These  five  problems  could  be  stated 
to  QA3  as 

By  t r i v i al  syntactic  matching  we  could  asso­

ciate  office5  with  Chicago,  Stanford  with  San 
Francisco,  etc.  The  robot's  actions  to  get  from 
SRI  to  Stanford  or  San  Francisco,  New  York  City, 
or  Chicago  are  pairwiee  similar.  But  the 
INITIAL-MAP  or  extender  would  have  to  know  the 
"semantics"  of  these  (geographic)  constants 
(with  respect  to  SRI)  and  the  robot's  actions  to 
assess  which  problems  are  adequately  analogical 
and  which  action  rules  should  be  extrapolated  to 
the  unsolved  problem. 

RELATIONSHIP BETWEEN ZORBA-I  AND QA3 

In  the  preceding  section,  I  have  discussed 

In  this  section,  I  merely  want  to  note 

the  organization  and  use  of  ZORBA-I  independently 
of  QA3. 
how  change  in  QA3  can  affect  the  way  in  which  the 
analogical  information  output  by  ZORBA-1  can  be 
used. 

If  every 

The  present  version  of  ZORBA-1  outputs  a  set 
of  clauses  that  it  proposes  as  a  restricted  data 
base  for  proving  T.. 
If  every  clause  in  proof[T] 
has  at  least  one  image  clause,  then  simply  modi­
fying  the  QA3  data  base  is  magnificently  helpful. 
However,  if  the  analogy  is  weak  and  we  have  only 
a  partial  set  of  images,  what  can  we  do? 
predicate  used  in  the  proof[T]  has  an  image,  we 
could  restrict  our  data  base  to  just  those  clauses 
containing  the  image  predicates.  Could  we  do 
better?  And  what  do  we  do  with  a  partial  analogy 
in  which  some  clauses  and  some  predicates  have 
images,  but  not  a ll  of  either?  At  this  point  we 
meet  limitations  imposed  by  the  design  of  QA3. 
A ll  contemporary  theorem  provers,  including  QA3, 
use  a  f a i r ly  homogeneous  data  base.  QA3  does  give 
preference  to  short  clauses,  since  it  is  built 
around  the  unit-preference  strategy.  But  it  has 
no  way  of  focusing  primary  attention  upon  a  select 
subset  of  axioms  A*,  and  attending  to  the  re­
maining  axioms  in  D  -  A*  only  when  the  search  is 
not  progressing  well.  One  can  contrive  various 
devices,  such  as  making  the  clauses  in  A*  pseudo-
units"  that  would  be  attended  to  early.  Or,  with 
torch  and  sword,  one  could  restructure  QA3  around 
a  "graded  memory."  (7)  Basically  we  have  to  face 
the  fact  that  our  contemporary  strategies  for 
theorem  proving  are  designed  to  be  as  optimal  as 
possible  in  the  absence  of  a  priori  problem-
dependent  information.  And  these  optimal  strate­
gies  are  d i f f i c u lt  to  reform  to  wisely  exploit  a 
priori  hints  and  guides  that  are  problem  dependent. 
This  is  not  to  say  that  various  kinds  of  a  priori 
information  cannot  be  added.  Rather,  it  is  a 
separate  and  sizable  research  task  to  decide  how 
to  do  i t. 
I  presume,  but  do  not  know,  that  these 
comments  extrapolate  to  other  problem-solving  pro­
cedures,  and  a  system  that  is  organized  around  a, 
priori  hints,  heretofore  user  supplied,  may  look 
very  different  than  one  which  is  designed  to  do 
its  best  on  its  own.  QA3  was  chosen  because  it 
was  available  and  saved  years  of  work  developing 
a  (new)  suitable  theorem  prover.  However,  further 
research  in  AR  may  well  benefit  from  relating  to 
a  more  flexible  theorem-proving  system. 

WHAT'S NEW? 

What  does  ZORBA  add  to  our  understanding  of 

AR?  What  does  ZORBA  leave  unanswered?  Pre-ZORBA, 
most  researchers  believed  that  analogies  would 
relate  to  plans  and  (possibly  to  probably)  include 
some  sort  of  semantic  information.  ZORBA  adds  the 
following  insights  to  our  understanding  of  AR: 

(1)  Some  f a i r ly  interesting  AR  can  be  handled 

by  modifying  the  environment  in  which  a 
problem  solver  operates  rather  than 
forcing  the  use  of  a  sequential  planning 
language. 

Session No.  14 Theorem Proving 

585 

R.  E.  KLING 

(2)  Each  problem  solver/theorem  prover  w i ll 
use  different  a  priori  information  and 
consequently  w i ll  require  different 
analogy-generation  programs. 

(3)  A  good  analogy  generator  w i ll  output 

some  information  helpful  to  speeding  up 
a  problem  search  as  a  byproduct  of  a 
successfully  generated  analogy. 

(4)  Part  of  the  problem  of  AR  is  to  specify 
precisely  how  the  derived  analogical  in­
formation  is  to  be  used  by  the  problem 
solver. 

(5)  An  effective,  nontrivial  analogy  genera­
tor  can  be  adequately  built  that  uses  a 
simple  theory  and  primitive  semantic 
selection  rules. 

(6)  Although  analogies  are  nonformal  and  are 
semantically  oriented,  nontrivial  analo­
gies  can  be  handled  by  a  special  system 
wrapped  around  a  highly  formal  theorem 
prover. 

5. 

6. 

7. 

C.  Green,  Theorem  Proving  by  Resolution  as  a 
Basis  for  Question  Answering  Systems,"  in 
Machine  Intelligence,  Vol.  4,  D.  Michie  and 
B.  Meltzer,  eds.  (Edinburgh  Univ.  Press, 
Edinburgh,  Scotland,  1969). 
R.  E.  Kllng,  "Reasoning  by  Analogy  with  Ap­
plications  to  Heuristic  Problem  Solving:  A 
Case  Study,"  Stanford  University  Ph.D.  Thesis 
forthcoming. 
R.  E.  Kling, 
Proving  Strategies,"  Al  Group  Technical 
Note  44,  Stanford  Research  Institute,  Menlo 
Park,  California  (1970). 

'Design  Implications  of  Theorem 

In  contrast,  ZORBA  neglects: 
(1)  Methods  for  handling  those  analogies 

that  absolutely  require  a  planning  level 
generalization  and  sequential  informa­
tion. 

(2)  Very  weak  analogies. 
(3)  What  to  do  with  many  rules  of  inference. 
(4)  How  to  describe  the  "structure  of  an 

analogy." 

ZORBA  makes  a  substantial  contribution  to  our 

pale  understanding  of  AR,  and  in  the  process 
helps  articulate  additional  questions  that  reveal 
our  vast  ignorance  of  analogical  ways  of  knowing. 

REFERENCES 

1.  N.  J.  Nilsson,  Problem  Solving  Methods  in 

A r t i f i c i al  Intelligence  (McGraw-Hill,  to  be 
published  1971). 

2.  G.  W.  Ernst  and  A.  Newell,  "Some  Issues  of 

Representation  in  a  General  Problem  Solver," 
AFIPS  Conference  Proceedings,  Vol.  30  (1967), 
pp.  583-600. 

3.  R.  E.  Fikes,  "REF-ARF:  A  System  for  Solving 

Problems  Stated  as  Procedures,"  A r t i f i c i al 
Intelligence,  Vol.  1,  pp.  27-120  (1970). 

4.  R.  E.  Kling,  "An  Information  Processing  Ap­
proach  to  Reasoning  by  Analogy,"  A r t i f i c i al 
Intelligence  Group  TN10,  Stanford  Research 
Institute,  Menlo  Park,  California  (June  1969) 

