Session  3  Theorem  Proving  and 
Logic; 

I 

THE  Q*  ALGORITHM  -  A  SEARCH  STRATEGY  FOR A 

DEDUCTIVE  QUESTION-ANSWERING  SYSTEM 

Jack  Minker 

Daniel  H.  Fishman 
James  R.  McSkimin 

The  University  of  Maryland 
Computer  Science  Center 

College  Park,  Maryland  20742 

Abstract 

An  approach  for  bringing  semantic,  as  w e ll  as 

The  approach  is  embodied  in  a 

information  to  bear  on  the  problem  of 

the  0*  search  algorithm,  developed  to 

syntactic, 
theorem-proving  search  f or  Question-Answering  <QA)  Sys­
tems  is  descrilsed. 
search  algorithm, 
c o n t r ol  deductive  searches  in  an  experimental  system. 
The  Q*  algorithm  is  part  of  a  system, 
termed  the  Mary­
land  Refutation  Proof  Procedure  System  (MRPPS),  which 
incorporates  both  the  Q*  algorithm,  which  performs  the 
search  required  to  answer  a  ouery,  and  an  i n f e r e n t i al 
component,  which  performs  the  l o g i c al  manipulations 
necessary  to  deduce  a  clause  from  one  or  two  other 
clauses.  The  i n f e r e n t i al  component  includes  many  r e­
finements  of  r e s o l u t i o n. 

The  Q*  algorithm  generates  nodes  in  the  search 

information  to 
The  use  of  semantics  permits  paths 

space,  applying  semantic  and  syntactic 
d i r e ct  the  search. 
to  be  terminated  and  f r u i t f ul  paths  to  be  explored. 
The  paper  is  r e s t r i c t ed  to  a  description  of  the  use  of 
syntactic  and  semantic  information  in  the  Q*  algorithm. 
Keywords  and  Phrases: 
problem-solving,  proof  procedure  system,  auestion-
answering,  r e s o l u t i o n,  search  strategies,  semantic 
h e u r i s t i c s,  syntactic  h e u r i s t i c s, 
theorem-proving. 
Introduction 

deductive  system,  h e u r i s t i c s, 

1. 

The  purpose  of  t h is  paper  is  to  describe  an 

The  approach  is  embodied  in  a  search 

the  Q*  search  algorithm,  developed  to  con­

approach  f or  bringing  semantic,  as  w e ll  as  syntactic, 
information  to  bear  on  the  problem  of  theorem-proving 
search. 
algorithm, 
t r ol  the  search  in  an  experimental 
based  question-answering  system.  This  system,  termed 
the  Maryland  Refutation  Proof  Procedure  System 
incorporates  both  the  Q*  alqorithm  which  performs  the 
search  required  to  answer  a  ouery,  and  an  i n f e r e n t i al 
component  which  performs  the  l o g i c al  manipulations 
necessary  to  deduce  a  clause  from  one  or  two  other 
clauses. 

theorem-proving-

(MRPPS), 

The  i n f e r e n t i al  component  of  MRPPS  provides  a 
For  a 

v a r i e ty  of  resolution-based  inference  r u l e s. 
given  query,  a  user  may  select  one,  or  a  combination  of 
the  following  inference  systems: 
r e s o l u t i on  w i th  f a c t o r i n g,  set-of-support, 
input  re-
s o l u t i o n,  Pl-deduction,  A-ordering,  paramodulation, 
l i n e ar  and  SL  r e s o l u t i o n.  A  MRPPS  user  may  also  select 
c e r t a in  search  options  that  are  available  in  the  sys­
tem. 

unrestricted  binary 

The  clauses  from  the  negation  of  a  given  input 
query  and  those  in  the  MRPPS  data  base  together  w i th 
the  selected  inference  system  define  a  search  space 

31 

which  is  a  directed  graph  whose  nodes 
(states)  are 
(labeled  by)  clauses.  The  i n i t i al  states  are  nodes 
labeled  bv  clauses  from  the  negation  of  the  query,  and 
a  goal  state  is  a  node  labeled  by  the  n u ll  clause,  □  . 

The  Q*  algorithm  generates  nodes  in  the  search 

information  to 
space,  applying  semantic  and  syntactic 
This  paper  is  r e s t r i c t ed 
d i r e ct  and  l i m it  the  search. 
For  a  detailed 
to  a  discussion  of  the  Q*  algorithm. 
description  of  the  algorithm  and  of  the  e n t i re  MRPPS 
system,  see  Minker,  et  a l. 
MRPPS  and  of  i ts  i n f e r e n t i al  component  may  be  found  in 
Minker,  et  a l. 

[1972].1  An  overview  of 

[1973].2 

The  Q*  algorithm  has  been  developed  for  eventual 
use  in  a  question-answering  system  of  p r a c t i c al  scale. 
Such  a  system  would  have  a  "large"  number  of  axioms 
stored  in  i ts  data  base.  A  substantial  majority  of 
these  axioms  would  be  f u l ly  instantiated  u n it  clauses, 
termed  "data  axioms."  The  remaining  axioms,  called 
"general  axioms,"  define  the  predicates  used  and  t h e ir 
i n t e r r e l a t i o n s h i p s.  One  would  want  such  a  system  to 
be  very  r e s t r i c t i ve  in  permitting  axioms  to  enter  the 
search, 
I/O  accesses 
to  the  data  base  as  w e ll  as  to  avoid  clause  i n t e r­
action  and  memory  c l u t t e r. 
want  to  be  able  to  answer  simple  questions  simply.  An 
e f f e c t i ve  theorem-proving  search  algorithm  f or  a 
guestion-answering  system  should  generate  the  search 
space  by: 
selecting  only  those  axioms  from  the 
data  base 
the  query,  such  t h at 
the  "more  premising"  ones  enter  the  search  f i r s t;  and 
(2) 
deducing  clauses  from  clauses  already  generated 
in  as  optimal  an  order  as  possible. 

(1) 
that  are  relevant 

In  a d d i t i o n,  one  would 

l i m it  the  number  of 

in  order  to 

to 

Both  of  these  problems  are  handled  in  the  Q* 

The  algorithm  is  subdivided  i n to  two  d i s­
algorithm. 
t i n ct  but  cooperating  subalgprithms: 
the  base  clause 
selection  algorithm  which  handles  the  f i r st  problem, 
and  the  deduction  algorithm  which  handles  the  second 
problem.  The  base  clause  algorithm  uses  p r i m a r i ly 
semantic  information,  while  the  deduction  algorithm 
uses  p r i m a r i ly  syntactic 

information. 

Before  discussing  the  algorithm,  we  review  some 
of  the  background  which  precedes  the  present  work  and 
upon  which  t h is  work  has  been  based. 

2,  Background 

There  has  been  a  great  deal  of  research  in  mech­
anical 
theorem-proving  since  the  resolution  p r i n c i p le 
was  introduced  by  Robinson 
search  has  been  centered  on  developing  refinements  of 
resolution  which  reduce  the  size  of  the  search  space. 
However, 
r e l a t i v e ly  l i t t le  work  has  been  reported  in 

[1965].  Most  of  the  r e­

i n c o r p o r a te 

to 

[1972]4 

[1964]? 

t h at  R e i t er 

is  a t t e m p t i ng 

developing  improved  search  s t r a t e g i es  or  u s i ng  seman­
t i cs  f or  theorem-proving  systems. 
(We  have  r e c e n t ly 
learned 
semantics  w i th  a 
theorem  p r o v er  by  t he  use  of  models.) 
R e s o l u t i on  theorem-proving  programs  t y p i c a l ly  use  t he 
u n it  p r e f e r e n ce  search  s t r a t e g y,  developed  by  Vtos,  et 
a l. 
search 
s t r a t e gy 
p o w e r f ul  enough  to  s u c c e s s f u l ly  g u i de  a  search 
even  moderately  deep  mathematical  p r o o f s. 
it 
f or  use 
a p p l i c a t i o ns  which  c o n s i st 
s i n ce 
regard 

in  which  t he  m e r it  of  a  c l a u se 
t h is 
it 

is  based  on  i ts  l e n g t h.  While 
theorems, 

in  question-answering 
l a r g e ly  of  u n it  c l a u s e s, 

it  g i v es  preference 
to 

in  t he 
is  a  u s e f ul 
is  n ot  n e a r ly 

t h e ir  relevance  to  t he  query. 

to  a il  u n it  clauses  w i t h o ut 

f or  p r o v i ng  s i m p le 

is  n ot  adequate 

f or 

Furthermore, 

Green 

[1969]6 

in  c o n s i d e r i ng  t he  a p p l i c a t i on  of 
in  question-answering  systems,  p a r t i­
theorem-proving 
i n to  two  s e t s,  a c t i ve  and  p a s s i v e.  Ac­
t i o n ed  clauses 
t i ve  clauses  are 
i n f e r r ed  clauses  and  axioms  s e l e c t ed 
from  t he  d a ta  base,  whereas  p a s s i ve  clauses  a re  axioms 
which  have  n ot  y et  been  s e l e c t e d.  Only  a c t i ve  clauses 
may  be  used 
a c t i ve  o n ly 
is  g i v en 
c l a u s e;  preference 
Green 
t h is  search  approach  w i th  t he  u n it 
i n c o r p o r a t ed 
p r e f e r e n ce  s t r a t e gy  in  t he  QA3  system  which  employs, 
e s s e n t i a l l y,  s e t - o f - s u p p o rt  as 
i n f e r e n ce  system. 

it  r e s o l v es  w i th  an  e x i s t i ng  a c t i ve 

in  i n f e r e n c e s. 
if 

to  passive  u n it  c l a u s e s. 

A  p a s s i ve  c l a u se 

is  made 

i ts 

Kowalski 

[1970a, 1970b]7 ,8 S e p a r a t es  t he  n o t i o ns  of 

in 

t he 

theorem-proving  search 
In  a d d i t i o n,  he  d e f i n es  a  c l a ss  of  "upwards 

an  i n f e r e n ce  system  and  a  search  s t r a t e gy  and  d e s c r i b es 
t h e ir  r e s p e c t i ve  r o l es 
problem. 
d i a g o n a l"  search  s t r a t e g i es  which  may  be  a p p l i ed  to 
a r b i t r a ry  problem  domains. 
These  s t r a t e g i es  s i m u l­
t a n e o u s ly  extend  and  r e f i ne 
t he  c l a ss  of  search  s t r a­
t e g i e s,  which  i n c l u d es  t he  A*  a l g o r i t hm  d e s c r i b ed  by 
H a r t,  N i l s s on  and  Raphael 
[1968]9  Kowalski  a l so  p r e-
sents  a  p a r t i c u l ar  upwards  d i a g o n al  search  a l g o r i t h m, 
In  t he  J*  a l g o r i t h m, 
w h i ch  he  c a l ls  t he  J 
t he  p a s s i v e / a c t i ve  clause  concept 
is  employed. 
a d d i t i o n, 
t i on  f u n c t i on 
l e v el  of  a 
c l a u se  a re  c o n s i d e r e d.  Upwards  d i a g o n al  search  s t r a­
t e g i es  could  a l so  be  d e f i n ed  u s i ng  h e u r i s t i cs  o t h er 
t h an  l e n g th  and 
[1972])1 

t he  a l g o r i t hm  employs  a  c l a u se  m e r it  e v a l u a­

in  which  b o th  t he  l e n g th  and 

(see  Minker,  et  a l. 

a l g o r i t h m. 

l e v el 

In 

, 

f ( C) 

in  which 

t he  m e r it 

In  t he  2 
is  a  t u p l e, 
. 

of  clause 
a l g o r i t h m, 
( i , j) 
,  and 
Kowalski  d e f i n es  an  o r d e r i ng  on  t h is 

C 
j  =  l e v e l ( C) 
m e r it  f u n c t i on  which  he  terms  "upwards  d i a g o n al  m e r i t ," 
denoted  by  t he  symbol 
m e r it 
( i, 
C1  £_u  C, 
d i a g o n al  m e r it  than  C2) 

, j1)  and  C2  of  m e r it 
( I . e .,  C, 

.  Given  c l a u s es  C1 
tnen 

is  of  b e t t er  or  equal  upwards 

i  =  l e n g t h ( c) 

( i2, j2) 

of 

u 

if 

+ 

+ 

i2  +  j2 
j1  < 
j1  =  i2  +  j2 

,  or 

and 

i1  < 

i2 

. 

( i i) 

( i) 

i1 
i1 
if  t he 

it 

is  b e t t er 

to  generate 

l e v el  of  two  clauses  sum  to 
t he  s h o r t er 
to 
t h us  advan­
in  t h is  manner 

t he  search  s t r a t e gy 

l e n g th  and 

t he  g o al  of 

Thus, 
t he  same  v a l u e, 
c l a u s e,  s i n ce 
generate  a  c l a u se  of 
tageous 
r a t h er  t h an  s o l e ly  on  t he  b a s is  of 
m e r it  components,  as 
gorithms  such  as  t he  A*  a l g o r i t hm 
[1968]  P. 

is 
to  d i s c r i m i n a te  between  clauses 

l e n g th  z e r o. 

t he  sum  of 

t he 
in  e a r l i er  search  a l­

(Hart,  et  a l. 

is  done 

is 

It 

Based  on  t h is  m e r it  f u n c t i o n,  Kowalski  p a r t i t i o ns 

i n to  m e r it  s e t s,  c a l l ed  A - s e t s, 

t he  search  space 
which  clauses  of  equal  m e r it  a re  g e n e r a t e d. 
a l g o r i t hm  generates  c l a u s es 
i n c r e a s i ng  upwards  d i a g o n al 
generate  a  c l a u se  i n to  A ( 0 , 0) 

i n to 
o r d e r, 

these  m e r it  s e ts 

in 
f i r st  t r i es  to 

which  would  be  p o s s i b le 

The  J* 

i n to 

It 

32 

t he  s t a r t i ng  s et  of 

It  t h en  s u c c e s s i v e ly  attempts 

to  gen­
from  t he  base  s e t,  or  by 

i n to  t he  s e ts  A(0,1) 

,  A(1,0) 

, 

if 

in 

t he  n u ll  c l a u se  were 

(by  s e l e c t i ng  a  c l a u se 

o n ly 
base  c l a u s e s. 
e r a te 
i n f e r e n c e)  clauses 
A(0,2) 
c l a u se 
generate  a ll  of 
successors  which  a re  of  b e t t er  m e r it 
m e r it 

,  A{1,1) 
is  g e n e r a t e d,  an  attempt 

to  which 

,  A(0,3) 

,  A(2,0) 

i ts  successors  and  successors  of 

i ts 

,  e t c.  Any  t i me  a 

is  made 

to  r e c u r s i v e ly 

than 

t he  c u r r e nt 

t he  a l g o r i t hm  has  sequenced. 
r* 

While  t he  above  d e s c r i p t i on  of  the 

l 

a l g o r i t hm 

t e r s e, 

t he  reader 

to 
[1970a,  1 9 7 0 b ] ,7'8a nd  to  Minker,  et  a l. 

is  n e c e s s a r i ly 
Kowalski 
[1972,  1 9 7 3 ]1'2f or  more  d e t a i l ed  d i s c u s s i o n s. 
3. 

A  View  of  R e s o l u t i on  Theorem-Proving  Search 

is  r e f e r r ed 

as  Problem-Reduction  Search 

Before  d e s c r i b i ng 

t he  o p e r a t i on  of 

t he  Q*  al-

it  w i ll  be  u s e f ul 

t h at  s o l u t i on  of  a ll 

is  a p p l i ed  to  a  problem  P 

to  reduce 
t he 
i m p l i es  a  s o l u t i on  to  P 

g o r i t h m, 
to  d e s c r i be  how  r e s o l u t i on 
theorem-proving  search  may  be  i n t e r p r e t ed  as  problem-
r e d u c t i on  s e a r c h. 
In  a  p r o b l e m - r e d u c t i on  search,  an 
o p e r a t or 
s et  of  subproblems  such 
successor  subproblems 
E q u i v a l e n t l y, 
be  considered  a  new  problem  which  must  be  solved  f or 
t he  g i v en  problem  to  be  s o l v e d. 
This  r e d u c t i on  p r o­
cess 
lem  u n t il  t he  o r i q i n al  problem  has  been  reduced 
s et  of  p r i m i t i ve  subproblems  which  are  t r i v i al 
s o l v e. 

is  r e c u r s i v e ly  a p p l i ed 

to  each  generated  subprob-

t he  c o n j u n c t i on  of 

these  subproblems  may 

to  a 
to 

to  a 

it 

. 

M o re p r e c i s e l y,  a  p r o b l e m - r e d u c t i on  c o n s i s ts  of 

t h r ee  s e t s: 

(1) 
(2) 

(3) 

a  s et  of  s t a r t i ng  problems; 
a  s et  of  o p e r a t o rs 
a  s et  of  subproblems;  and, 
a  s et  of 
d e f i n i t i o n,  s o l v e d. 

f i n al  problems  which  a r e,  by 

t h at  reduce  a  problem  to 

In 

t he  c o n t e xt  of  r e s o l u t i on 

to  a  subproblem. 

to  a  problem  and  a 

clause  corresponds 
ponds 
tion  of  subproblems  s i n ce  all  subproblems  must  be 
solved 
l i t­
e r a ls  must  be  e l i m i n a t e d ). 

t he  problem  to  be  solved 

Thus,  a  clause 

( i . e .,  a ll 

f or 

theorem-proving,  a 
l i t e r al  c o r r e s­
is  a  conjunc(cid:173)

The  s t a r t i nq  s et  of  problems  corresponds 

to  a 

The  a c t u al  members  of 
i n f e r e n ce  system  b e i ng 
i n f e r e n ce  system  is  s e t-

if 

t he 

For 

i n s t a n c e, 

s t a r t i ng  s et  of  base  c l a u s e s. 
t h is  s et  w i ll  depend  upon 
t he 
used. 
o f - s u p p o r t,  or 
s t a r t i ng  s et  of  problems  corresponds 
t he  n e g a t i on  of 
tems, 
i . e .,  a ll  of 
c l a u s e s. 

it  c o n s i s ts  of 

t o g e t h er  w i th 

t he  axioms 

t he  cruery. 

if 

it 

i n c l u d es  s e t - o f - s u p p o r t, 

t he 

t he  clauses 
For  o t h er  i n f e r e n ce  s y s­
t he  e n t i re  s et  of  base  c l a u s e s, 

to 

in 

t he  query 

f a c­

t he  s et  of  o p e r a t o rs 

to  problems  by  means  of 

t h at  m ay  be  a p p l i ed  w i ll 

t he  i n f e r e n ce  r u le  used,  e . g ., 

Clauses  may  a l so  be  regarded  as  o p e r a t o rs  which 
i n f e r e n ce  r u l e s. 

a re  a p p l i ed 
However, 
v a ry  depending  on 
t o r i n g,  p a r a m o d u l a t i o n,  and  v a r i o us  r e f i n e m e n ts  of  r e­
For  a  r e s o l u t i on  o p e r a t i o n, 
s o l u t i o n. 
two  c l a u s es  a re 
i n v o l v e d. 
In  g e n e r a l, 
t he  problem  and  which 
a r b i t r a r y. 
However, 
seems  n a t u r al 
t he  t w o. 
For 
each  c l a u se  of  a 
problem  and  a ll  base  clauses  may  be  regarded  as  o p e r­
a t o r s. 
l i n e ar  and  SL  r e s o l u t i o n,  ancestors  of  a 
problem  may  a l so  be  considered  as  o p e r a t o r s, 
a d d i t i on  to  a ll 

i n f e r e n ce  systems, 
to  make  a  c l e a r er  d i s t i n c t i on  between 
i n s t a n c e, 
i n p ut  r e s o l u t i on  is  used, 

t he  c h o i ce  of  which  c l a u se 
is 
is  somewhat 
f or  c e r t a in 

l i n e ar  c h a in  may  be  regarded  as  a 

t he  base  c l a u s e s. 

t he  o p e r a t or 

For 

in 

is 

it 

if 

A  clause  may  also  be  a  f i n al  problem. 

In  p a r t i­

the  n u ll  clause  is  the  only  such  clause  when 

it  may  be  solved  in  a  single  step  bv  applving  an 

c u l a r, 
one  is  attempting  to  r e f u te  a  conjecture.  Thus,  when 
a  n u ll  clause  is  generated,  we  know  t h at  a  s t a r t i ng 
problem  has  been  solved.  Determining  when  a  subprob-
lem  is  solved  is  more  d i f f i c u l t.  This  may  be  seen  by 
considering  the  process  involved  in  solving  a  subprob-
lem.  A  subproblem  P 
(which  corresponds  to  a  l i t e r al 
in  a  clause),  may  be  solved  in  either  of  two  wavs: 
1) 
operator  t h at  refutes  it 
nately,  an  operator  may  be  applied  to  P 
a  set  of  subproblems  such  t h at  P 
only  if  a ll  of  the  subproblems  are  solved. 
t i c e, 
the  determination  of  when  a  given  subproblem  has 
been  solved  may  be  quite  d i f f i c u l t.  Depending  on  the 
inference  system  used,  subproblems  are  attacked  in 
a r b i t r a ry  order.  Consequently, 
the  bookkeeping  r e­
quired  to  keep  track  of  which  l i t e r a ls  of  a  given 
clause  have  been  spawned  by  which  subproblems  may  be 
quite  involved. 

is  solved  if  and 
In  prac­

(a  u n it  clause);  2) 

t h at  spawns 

a l t e r­

However,  one  inference  system,  SL  resolution 

(and  duly  tagged) 

In  SL  r e s o l u t i o n,  a 

in  each  of  the  success­

In  t h is  representation,  a 

[1971]},10  stands  out  as  being 
In  the  f i r st 

{Kowalski  and  Kuehner 
p a r t i c u l a r ly  w e ll  suited  f or  t h is  task. 
place,  SL  r e s o l u t i on  requires  t h at  only  one  subproblem 
be  attempted  at  a  given  l e v e l.  Secondly,  the  required 
bookkeeping  is  b u i lt  i n to  the  clause  representation 
used  in  SL  r e s o l u t i o n. 
clause  is  referred  to  as  a  chain. 
subproblem  to  which  a  solution  is  sought  is  actually 
carried  along 
or  chains.  Such  l i t e r a ls  are  called  "A  l i t e r a l s"  in 
the  successor  clauses.  As  new  l i t e r a ls  (called  "B  l i t­
erals")  are  introduced  in  the  attempt  to  solve  a  sub-
problem, 
When  a ll  such  B  l i t e r a ls  have  been  resolved  awav  (re­
solution  is  only  performed  on  rightmost  B  l i t e r a l s)  and 
an  A  l i t e r al  is  exposed  on  the  r i g h t, 
s t i t u t es  a  solution  to  the  subnroblem  from  which  t h at 
A  l i t e r al  descended.  At  t h is  time,  SL  resolution  r e­
quires  t h at  the  exposed  A  l i t e r al  be  removed  from  the 
clause  -  an  operation  which  is  called  truncation. 
Only  at  t h is  time, 
finements  of  resolution)  may  a  new  subproblem  from  the 
o r i g i n al  problem  be  selected  for  s o l u t i o n. 

they  are  placed  to  the  r i g ht  of  the  A  l i t e r a l. 

(and  not  before  as  w i th  other  r e­

then  t h at  con­

4.  The  Q*  Algorithm 

The  Q*  algorithm  is  based  upon  the  I  algorithm 
of  Kowalski  together  w i th  the  idea  of  Green  to  allow 
only  c e r t a in  base  clauses  to  enter  the  active  clause 
space.  Both  of  these  approaches  have  been  extended  in 
the  current  algorithm.  The  Q*  algorithm  is  subdivided 
i n to  two  major  components: 

1) 

2) 

the  deduction  algorithm  which  uses  p r i m a r i ly 
syntactic  information;  and, 
the  base  clause  selection  algorithm  which 
uses  p r i m a r i ly  semantic  information. 

The  deduction  algorithm  generates  new  problems  by 

the  a p p l i c a t i on  of  operators  to  problems  already  in 
the  search  space.  Any  operator  that  is  applied  must 
i t s e lf  have  been  previously  generated  e i t h er  bv  i n f e r­
ence  or  by  the  selection  of  a  base  clause. 

Problems  and  operators  are  generated  bv  two  major 
subalgorithms,  FILL  and  RECURSE,  which  are  adaptations 
of  analogous  subalgorithms  of  the  £  algorithm.  As  a 
clause  is  generated, 
it  is  placed  i n to  an  A-set  corres­
ponding  to  i ts  m e r i t.  The  algorithm  uses  a  generalized 
upwards  diagonal  merit  function  to  calculate  the  merit 
of  a  clause,  and  generates  clauses  in  approximately 
upwards  diagonal  order. 
function  as  w e ll  as  on  the  deduction  algorithm  are  con­

(Further  d e t a i ls  on  t h is 

33 

tained  in  Minker,  et  a l. 

[1972,  1973]1 , 2.) 

In  using  t h is  merit  f u n c t i o n, 

it  is  hoped  t h at 

clauses  of  better  merit  w i ll  be  more  useful  to  answer­
ing  the  query  than  those  of  worse  merit.  However, 
in 
p r a c t i c e, 
it  is  extremely  d i f f i c u lt  to  develop  c o m-
nonents  of  the  merit  function  t h at  adequately  r e f l e ct 
the  relevance  of  clauses  w i th  respect  to  the  query. 
Most  components  used  to  date  have  been  syntactic  in 
nature,  rather  than  semantic,  and  have  led  to  very  i n­
(See  Slagle  and  F a r r e ll 
e f f i c i e nt  search  strategies. 
[1971]11 and Minker,  et  a l. 
[1972]1 for  examples.)  Con­
theorem-provers  using  such  a  search  s t r a­
sequently, 
tegy  are  often  deluged  w i th  i r r e l e v a nt  clauses  and 
thus  are  inadequate  f or  most  applications. 

There  are  two  ways  to  a l l e v i a te  t h is  problem. 
F i r s t,  a f t er  a  problem  is  generated  by  an  inference 
step,  various  deletion  rules  may  be  applied  so  t h at 
the  problem  may  be  eliminated  in  case  it  is  redundant 
or  semantically  meaningless.  Thus, 
tautologies, 
alphabetic  variants  and  subsumed  clauses  may  be 
eliminated.  Furthermore,  subproblems  as  w e ll  as  prob­
lems  mav  be  eliminated  by  predicate  evaluation.  This 
mav  be  done  bv  referencing  stored  semantic  information 
about  the  problem  domain.  For  instance, 
is 
C  v  F(Mary,  x)  be  a  generated  problem,  where  C 
the  remainder  of  the  clause. 
If  it  is  known  t h at  the 
f i r st  argument  of  the  father  predicate  must  be  male, 
and  we  know  t h at  Mary  is  female,  then  the  l i t e r al 
F(Marv,  x)  w i ll  never  have  a  s o l u t i on  ( i . e .,  no  u n it 
clause/  F{Mary,  a) 
,  can  be  t r u e,  f or  any  person  a ). 
We  can  thus  evaluate  the  l i t e r al  F(Mary,  x) 
as  being 
true  r e l a t i ve  to  the  i n t e r p r e t a t i on  given  to  the  prob­
lem  domain  and  may  eliminate  the  e n t i re  problem  from 
the  search  space  since  it  is 
inference  systems  completeness  should  not  be  v i o l a t ed 
bv  deleting  the  clause.  On  the  other  hand, 
eral  of  a  clause  is  evaluated  as  f a l s e, 
alone,  mav  be  removed,  since  it  corresponds  to  a  sub-
problem 

unsolvable.  With  most 

if  a  l i t­
that  l i t e r al 

is  solved. 

t h at 

l et 

i r r e l e v a nt 

it  does  not  prevent 

Although  predicate  evaluation  using  semantic  i n­
formation  about  the  problem  domain  w i ll  be  useful  in 
theorem-proving, 
clauses  from  being  generated  and  entered  in  the  search 
snace.  We  thus  f e el  t h at  a  more  e f f e c t i ve  method  by 
which  to  cut  down  the  size  of  the  search  space  is  to 
avoid  generating 
place. 
c a r e f u l ly  selecting  those  operators 
levant  to  the  search  in  progress  and  by  i n h i b i t i ng 
those  which  are  i r r e l e v a n t. 
the  base  clause  selection  algorithm. 

t h is  can  be  accomplished  by 

This  is  the  function  of 

i r r e l e v a nt  clauses 

t h at  are  most  r e­

In  p a r t i c u l a r, 

f i r st 

the 

in 

Depending  on  the  inference  system, 

the  algorithm 

locate 

is  used  to 

in  some  cases,  which  possess  a  l i t e r al  which  w i ll 

t r e a ts  one  or  a ll  of  the  l i t e r a ls  of  a  generated 
clause  as  a  s p e c i f i c a t i on  w i th  which  to  select  axioms. 
Thus,  each  l i t e r al  is  termed  a  "spec  l i t e r a l ." 
(This 
mav  be  viewed  as  the  selection  of  operators  to  apply 
to  a  subproblem.) 
In  order  to  select  axioms  relevant 
to  the  querv, 
the  Q*  algorithm  i n i t i a l ly  generates 
clauses  from  the  negation  of  the  query.  Each  spec 
l i t e r al 
those  axioms  which  either 
resolve  w i th  the  generated  clause  on  t h at  l i t e r a l, 
o r, 
u n i fy  w i th  the  spec  l i t e r a l.  The  axioms  t h at  have 
been  located  f or  a  p a r t i c u l ar  spec  l i t e r al  may  be  r e­
duced 
to  be  semantically  inappropriate  ( e . g .,  because  of  i n­
compatible  argument  types).  The  remaining  operators 
f or  a  given  subproblem  then  become  candidates  for 
generation  and  must  be  ordered  so  t h at  "more  promis­
ing"  operators  are  t r i ed  f i r s t.  The  l i st  of  candi­
dates  f or  a  spec  l i t e r al  is  placed  on  a  l i st  c a l l ed 
the  SPECLIST,  which  is  i t s e lf  ordered  by  using  various 

in  number  by  filtering  out 

those  which  are 

found 

Thus, 

the  ordering  of  the  SPECLIST 

h e u r i s t ic  c r i t e r i a. 
r e f l e c ts  the  judgment  of  the  base  clause  algorithm  as 
to  which  subproblems  from  among  a ll  subproblems  in  a ll 
generated  clauses  should  be  attacked  f i r s t. 
That  i s, 
in  a ll  generated  clauses  that 
from  among  a ll  l i t e r a ls 
are  e l i g i b le  f or  resolving, 
the  base  clause  selection 
strategy  picks  the  best  one. 

As  a  r e s u lt  of  the  control  maintained  over  the 
base  clauses  by  the  base  clause  selection  algorithm, 
the  FILL  operation  of  the  deduction  algorithm  w i ll  n o t, 
in  general,  acquire  a ll  base  clauses  of  a  given  FILL 
merit. 
It  obtains  only  those  base  clauses  made  a v a i l­
able  to  it  by  the  base  clause  selection  algorithm.  As 
a  r e s u l t, 
the  base  clauses  that  are  selected  w i ll  not 
necessarily  be  generated  in  merit  order.  Consenuently, 
and  in  contrast  to  the  J*  algorithm, 
is  not  admissible.  However,  as  the  exanples  in  Section 
5  demonstrate, 
only  t h e o r e t i c al  importance  since  it  would  seem  to  be 
more  important  in  p r a c t i c al  QA  amplications  to  f i nd  anv 
solution  quickly  rather  than  to  f i nd  a  simplest  solu­
t i on  at  great  expense,  at  the  r i sk  of  finding  no  s o l u­
t i on  at  a ll  because  of  space  and  time  considerations. 

the  loss  of  a d m i s s i b i l i ty  may  be  of 

the  Q*  algorithm 

The  following  sections  describe  the  manner  in 

which  axioms  are  located, 
the  way  c e r t a in  of  these  are 
f i l t e r ed  out,  and  the  way  those  that  remain  are  order­
ed.  Section  4.4  presents  a  discussion  of  a  olanned 
extension  of  the  search  strategy  in  which  the  base 
clause  algorithm  may  prune  the  search  space  and  delete 
c e r t a in  candidates  from  the  SPBCLIST  upon  the  recogni­
t i on  of  certain  events  in  the  search  process. 
4.1  Locating  Candidate  Axioms 

As  already  indicated, 

the  l i t e r a ls  of  generated 

The  inference  system  t h at 

clauses  are  used  to  locate  axioms  which  may  become 
candidates  f or  generation. 
is  being  used  by  the  deduction  algorithm  w i ll  deter­
mine  which  generated  clauses  should  be  used  f or  t h is 
purpose,  and  what  c r i t e r i on  should  be  applied  to 
If  the  inference  system  in  use  is 
select  the  axioms. 
it 
set-of-support,  or 
if 
incorporates  set-of-support 
as  does  SL  resolution, 
then  only  the  l i t e r a ls  of 
supported  clauses  w i ll  be  used.  Furthermore,  the 
axioms  which  become  candidates  w i ll  be  those  which 
could  resolve  w i th  the  generated  clause.  On  the  other 
if  the  inference  system  does  not  include  set-of-
hand, 
including  generat­
support  then  a ll  genera-ted  clauses, 
ed  axioms,  w i ll  be  used  to  locate  axioms. 
In  a d d i t i o n, 
the  resolution  c r i t e r i on  must  be  weakened,  so  that  an 
axiom  w i ll  p o t e n t i a l ly  become  a  candidate 
tains  a  l i t e r al  which  unifies  w i th  a 
erated  clause. 
c r i t e r i on  is  necessary  in  order 
t i on  completeness  of  the  algorithm,  e . g ., 
where  the  only  refutations  f or  a  given  ouery  involves 
the  use  of  a  lemma,  and  the  ouery  is  not  used  u n t il 
the  lemma  has  been  established. 

The  weakening  of  the  resolution 

to  assure  the  r e f u t a­

l i t e r al  of  a  gen­

in  cases 

it  con­

if 

Not  only  does  the  inference  system  d i c t a te  which 

clauses  are  to  be  used  in  l o c a t i ng  axioms, 
dictates  which  l i t e r a ls  should  be  used.  Thus, 
"single  l i t e r a l" 
t i on  or  A-ordering,  only  one  designated  l i t e r al  of 
each  generated  clause  is  used,  while  f or  other  i n f e r­
ence  systems,  a ll  of  the  l i t e r a ls  w i ll  be  used  f or 
t h is  purpose. 

inference  systems  such  as  SL  resolu­

it  also 
in 

The  approach  to  locating  axioms  which  may  enter 
i n to  the  search,  may, 
f or  a  given  query,  preclude  the 
there  may  be 
generation  of  c e r t a in  axioms.  That  i s, 
axioms  which  are  completely  unrelated  to  the  ouery  in 
t h at  they  concern  a  d i f f e r e nt  problem  domain.  But 
since  these  are  completely  i r r e l e v a nt  to  the  query, 

34 

the  search  strategy  w i ll  not  be  hindered  from  f i n d i ng 
a  r e f u t a t i on  if  one 

is  attainable. 

4.2  Semantic  F i l t e r i ng  of  Candidate  Axioms 

Once  the  p o t e n t i al  candidates  f or  a  given  spec 

the  class  membership,  or 

l i t e r al  are  found,  these  may  be  subjected  to  semantic 
f i l t e r i n g,  and  only  those  which  are  semantically  con­
sistent  w i th  the  spec  l i t e r al  and  i ts  host  clause  may 
become  candidates.  This  f i l t e r i ng  may  be  done  on  the 
type,  of  a  variable 
basis  of 
or  constant  in  the  spec  l i t e r a l. 
For  example,  suppose 
the  generated  clause  l i t e r al  is  ~PARENT  (Dan,  Brett) 
and  it  is  known  t h at  Dan  is  a  male,  or  the  l i t e r al 
is 
~PARENT (x,  Brett) 
x 
two  p o t e n t i al  base  clause  candidates: 

corresponds  to  a  male.  Suppose  further  that  the 

it  is  known  that 

from  context, 

and, 

(1)  ~FATHER(u,v)  V  PARENT(u,v)  ,  and 
(2)  ~MOTHER  (u,v)  V PARENT (u,v) 

were  found  in  the  data  base.  Applying  the  f i l t e r, 
axiom  (2)  would  be  found  semantically  inconsistent 
w i th  the  spec  l i t e r al  since  the  variable  u 
in  the 
PARENT  l i t e r al 
t e x t, 
from  i ts  use  in  MOTHER  l i t e r a l ),  and 
what  is  necessary  is  a  PARENT  l i t e r al  whose  f i r st 
argument  is  of  type  male. 
Thus,  only  (1)  would  be­
come  a  candidate. 

is  found  to  be  of  type  female  from  con­

( i . e ., 

A  further  type  of 

it  becomes  unnecessary  to 

f i l t e r i ng  may  also  be  perform-
ed.  When  a ll  of  the  solutions  to  a  subproblem  are  ex­
p l i c it  in  the  data  base, 
generate  any  general  axioms  which  might  be  used  to  de­
duce  a  solution  to  the  subproblem.  For  example, 
~MOTHER(x, Emily) 
be  a  generated  clause  l i t e r a l. 
Also  assume  t h at 
exactly  one  mother. 
were  found  in  the  data  base, 
p l e t e ly  solves  the  subproblem  at  hand, 
come  the  only  candidate.  No  other  axioms  t h at  could 
resolve  w i th  ~MOTHER{x,  Emily)  would  be  entered  to 
s a t i s fy  t h is  subproblem. 

it  is  known  t h at  every  individual  has 
If  the  axiom  MoTHER(Roz,  Emily) 

then,  since  t h is  com-
it  would  be-

l et 

The  f i l t e r i ng  we  have  described  can  be  seen  to 
reduce  the  number  of  axioms  which  are  generated  i n to 
the  search  space.  As  a  r e s u l t, 
fewer  clauses  w i ll  be 
available  to  i n t e r a ct  l o g i c a l ly  and  so  the  t o t al  num-
ber  of  clauses  which  may  be  generated  is  thereby  r e­
duced, 
c l e a r l y,  the  clauses  of  the  i m p l i c it  search 
space  which  have  become  ungeneratable  as  a  r e s u lt  of 
t h is  f i l t e r i ng  could  not  have  contributed  to  a  r e f u­
t a t i on  so  t h at  although  the  search  algorithm  f a i ls  to 
be  complete 
it  remains 
refutation 

( in  the  sense  of  exhaustive), 
complete. 

4.3  Ordering  of  Candidate  Axioms  and  Subproblems 

Once  the  candidate  axioms  have  been  located  and 
they  must  be  ordered 

subjected  to  semantic  f i l t e r i n g, 
so  t h at  the  "more  promising"  ones  w i ll  be  generated 
f i r s t.  As  already  noted, 
there  is  a  two-level  order­
ing  t h at  is  performed: 
a  p a r t i c u l ar  spec  l i t e r al  must  be  ordered 
corresponds  to  the  ordering  of  operators  to  be  applied 
to  a  subproblem),  and  the  l i s ts  of  candidates  f or  the 
various  spec  l i t e r a ls  are  ordered  w i th  respect  to  one 
another 
(this  corresponds  to  the  ordering  of  subprob-
lems). 

the  candidates  associated  w i th 

(this 

In  ordering  the  candidates  f or  a  p a r t i c u l ar  spec 
In 

two  d i f f e r e nt  approaches  may  be  employed. 

l i t e r a l, 
one  approach, 
Teooimendation  by  the  user. 
This 
recommendation  l i s ts  in  PLANNER 
Another  approach 

[1971] )1 2. 
is  to  order  candidates  according  to 

is  analogous  to  the 
(Hewitt, 

they  may  be  ordered  according  to  a 

the  merit  ordering, 
making  sure  t h at  data  axioms 
u n it  clauses)  precede  any  general  axioms. 

,  used  by  the  deduction  strategy, 
( i . e .,  f u l ly  instantiated 

f 

With  respect  to  ordering  the  subproblems,  a 

if 

In 

(2) 

(constant), 

if  a  query  is  about  a 

(or  unify)  w i th  fewer  base  clauses  than 

(1)  constant-carrying  l i t e r a ls  w i ll  gen­

the  candidates  located  by  using  constant-

h e u r i s t ic  guideline  is  applied  when  one  or  more  con­
stants  occur  in  l i t e r a ls  of  the  query  clauses. 
t h is  event, 
carrying  l i t e r a ls  of  generated  clauses  w i ll  precede  in 
the  ordering  those  candidate  axioms  located  by  the  use 
of  general  l i t e r a l s.  The  reasoning  behind  t h is  h e u r i s­
t ic  is  t h at 
e r a l ly  resolve 
w i ll  general  l i t e r a l s,  and 
p a r t i c u l ar  i n d i v i d u al 
mechanism  w i ll  make  more 
relevance  of  candidate  axioms 
it  concentrates  on 
t h is  i n d i v i d u a l,  -and  to  others  which  are  found  to  be 
related  to  i t,  rather  than  going  o ff  b l i n d ly  on  the 
basis  of  some  general  l i t e r a l. 
In  many  cases,  the 
general  l i t e r al  may  a c t u a l ly  unify  w i th  a  large  subset 
of  the  axioms  in  the  data  base  while  only  a  few  of 
these  may  be  relevant.  Furthermore,  by  pursuing  t h is 
p o l i c y, 
l i t e r a ls  which  are  uninstantiated  at  one  l e v el 
of  the  search  may  become  i n s t a n t i a t ed  at  a  subsequent 
l e v e l.  Thus, 
case  t h at  clues 
the  search  w i ll  be  passed  from  one  subproblem  to 
another  as  the  search  progresses. 

it  w i ll  often  be  the 
to  d i r e ct 

informed  decisions  about  the 

(in  the  form  of  constants) 

in  t h is  approach, 

then  the  search 

Figure  1  i l l u s t r a t es  a  proof  t h at  was  derived 

g i v i ng  preference  to  those  l i t e r a ls  t h at  contain  con­
stants. 
In  Figure  1,  clause  ( l ) y i e l ds  two  l i t e r a ls 
f or  the  SPECLIST.  The  l i t e r al  M(y,  Sally)  would  be 
given  preference  on  t h is  l i st  since  it  contains  a  con­
stant.  The  axioms  t h at  can  i n t e r a ct  w i th  the  l i t e r al 
are  entered  i n to  the  search  before  other 
M(y,  Sally) 
axioms  t h at  may  apply  to  that_clause.  S i m i l a r l y, 
in 
clause 
l i t e r al  preference.  Although  proofs  can  be  found 
without  using  t h is  h e u r i s t i c,  such  proofs  w i ll  tend  to 
generate  many  unneeded  clauses. 

the  constant  in  H(v,  Rita) 

gives  t h is 

(3), 

It  is  reasonable  to  assume  t h at  in  question-
answering  applications  a  large  percentage  of  the 
queries  w i ll  contain  constants.  Even  if  constants 
appear  in  a  given  l i t e r a l, 
it  may  be  reasonable  to 
give  preference  to  a  l i t e r al  containing  only  variables 
based  upon  a  lower  estimate  of  p o t e n t i al  candidates 
s a t i s f y i ng  each  of  these  l i t e r a l s.  However,  we  would 
expect  t h is  to  happen  infrequently  in  question-
answering  systems. 

, 

There  may  be  several  subproblems  (spec  l i t e r a l s) 

In  t h is  case, 

containing  constants  which  must  be  ordered  w i th  r e­
spect  to  one  another  on  the  SPECLIST. 
the  ordering  of  candidate  l i s ts  by  t h e ir  spec  l i t e r a ls 
is  accomplished  by  using  a  prediction  of  the  m e r i t, 
f 
of  a  resolvent  between  the  spec  l i t e r a l 's  host  clause 
and  the  f i r st  axiom  in  the  ordered  l i st  of  candidates 
from  t h at  l i t e r a l.  One  consequence  of  t h is  ordering 
is  t h at  if  a  generated  u n it  clause  is  contradicted  by 
a  u n it  axiom, 
then  t h is  axiom  surely  w i ll  have  become 
a  candidate,  and  it  w i ll  be  placed  f i r st  in  the  order­
ing  so  t h at  it  w i ll  be  the  very  next  axiom  to  be  gen­
erated.  Each  time  an  axiom  is  removed  from  the  l i st 
of  candidates, 
the  next  candidate  in  the  l i st  is  used 
f or  a  new  p r e d i c t i o n,  and  the  corresponding  SPBCLIST 
e n t ry  is  reinserted  i n to  an  appropriate  p o s i t i on  of  the 
l i st  —  it  may  remain  on  top  of  the  l i s t,  or  some  other 
subproblem  may  emerge  as  "most  promising." 

In  some  data  bases, 

there  may  be  certain  constants 

which  occur  in  a  large  number  of  the  data  axioms. 
Generally,  these  would  be  non-specific,  class  specify-
ing  types  of  constants  such  as MALE and  SINGLE  as  used 

in  the  data  axiom. 

PERSON(JOHN,  SMITH,  ID475,  MALE,  FEMALE) 

. 

Since  such  constants  do  not  designate  p a r t i c u l ar  i n­
d i v i d u a l s,  and  since  they  do  occur  throughout  the  data 
base, 
search.  Thus, 
SPECLIST,  spec  l i t e r a ls  containing  these  types  of  con­
stants  alone  are  treated  as  general  l i t e r a l s. 

thev  w i ll  be  of  l i t t le  value  in  d i r e c t i ng  the 

f or  the  purpose  of  ordering  the 

4.4  Semantic  Actions  During  the  Search 

It  was  noted  in  Section  4.2  t h at  some  subproblems 

If  the  number  of  solu­

then,  during  the 
the  progress  of  the  search  r e l a­

may be  comnletelv  solved  by  data  axioms  stored  in  the 
data  base,  More  generally,  some  subproblems  have  an 
exact  number  of  solutions  while  others  have  an  i n­
d e f i n i te  number  of  solutions. 
tions  to  a  given  subproblem  is  known, 
course  of  the  search, 
t i ve  to  f i n d i ng  these  solutions  can  be  monitored. 
When  a ll  of  the  solutions  have  been  found, 
t i on  of  the  search  graph  which  has  been  unnecessarily 
generated  in  the  attempt  to  f i nd  these  solutions  can 
be  pruned. 
In  a d d i t i o n,  the  candidate  axioms  located 
through  the  use  of  l i t e r a ls  in  the  pruned  clauses  or 
in  clauses  along  the  solution  path  w i ll  have  t h e ir 
candidate  status  removed.  The  e f f e ct  of  t h is  pruning 
is  to  reduce  the  number  of 
irrelevant  clauses  in  the 
search  space.  Of  even  greater  significance  is  that 
the  p o t e n t i al  successors  of  these  clauses  are  effec­
t i v e ly  prevented  from  being  generated. 

that  por­

The  bookkeeping  required  to  apply  these  semantic 

actions  would  be  quite  complex  when  a r b i t r a ry  i n f e r­
ence  systems  are  employed,  since, 
for  a  given  clause 
(problem),  attempts  to  solve  a ll  of  the  subpro-
blons  are  carried  out  simultaneously.  However, 
SL  r e s o l u t i on  is  p a r t i c u l a r ly  w e ll  suited  for  t h is 
approach,  since  only  one  subproblem  is  attacked  at  a 
time  and  because  the  bookkeeping  required  to  detect 
the  solution  of  a  subproblem  is  b u i lt  i n to  the  SL 
clause  representation,  as  noted  in  Section  3.  Seman­
t ic  actions  are  taken  when  truncation  occurs,  since 
truncation  only  occurs  when  a  subproblem  has  been 
solved.  The  semantic  action  taken  is  to  increment  a 
count  and  t e st 
sought. 
performed. 

If  t h is  number  is  met,  then  pruning  can  be 

it  against  the  number  of  solutions 

The  above  approach  does  not  require  that  a ll 
solutions  to  a  given  subproblem  be  obtained  before 
It  would  seem  to 
progressing  to  another  subproblem. 
be  desirable, 
in  some  cases,  to  continue  the  search 
for  additional  solutions  to  the  subproblem,  while  at 
the  same  time  advancing  to  the  next  subproblem. 

5.  Example  Runs  With  MRPPS 

The  MRPPS  system  incorporates  a  preliminary  ver­
sion  of  the  Q*  algorithm  plus  an  option  for  selecting 
the 
algorithm.  The  current  implementation  of  Q* 
does  not  yet  include  the  semantic  f i l t e r i ng  of  candi­
dates,  and  no  mechanism  has  been  included  to  take 
semantic  actions.  The  current  version  includes  the 
deduction  strategy  as  o u t l i n e d,  together  w i th  a  base 
clause  selection  strategy  which  locates  and  orders 
axioms  e s s e n t i a l ly  as  described.  A ll  d e t a i ls  concern­
ing  the  current  implementation  are  described  in 
Minker,  et  a l. 
algorithm  uses  the  same  deduction  strategy  as  Q*,  but 
the  base  clause  selection  strategy  merely  locates 
axioms  in  m e r it  order, 
t h at  is  to  say,  by  length, 
without  regard  to  other  clauses  generated  by  the 
search. 

[ 1 9 7 2 ]l.  The  implementation  of  the  £ 

35 

We  present  comparative  s t a t i s t i cs 

f or  two  d i f f e r­
in  which  s e t - o f - s u p p o rt  and  SL  r e s o l u t i on 

e nt  q u e r i e s, 
were  t he  chosen  i n f e r e n ce  systems,  and  t he  m e r it  com­
ponents  were  c l a u se  l e n g th  and  l e v e l.  Clause  l e n g th 
and  l e v el  bounds  were  b o th  s et  at  e l e v e n,  and  an 
v a l ue  bound 
(=  l e n g th  +  l e v e l)  was  set  at  e l e v e n. 
data  base  used  c o n t a i ns  295  data  axioms  which  e x p l i­
c i t ly  s t a te  t he 
and 
i d e n t i f i c a t i on 
t he 
f i r st  and 
i d e n t i f i c a t i on  number. 
general  axioms  which  d e f i ne 
terms  of  o t h er  p r e d i c a t e s. 

t h e ir 
(5)  which  r e l a te 
to  t h e ir 

The  data  base  a l so  i n c l u d es  88 
in 

i n d i v i d u a ls 
( i . d .)  numbers,  and 

t he  v a r i o us  p r e d i c a t es 

l a st  name  of  each 

(4)  b i r t h p l a ce  of 

(3)  b i r th  d a t e, 

(1)  mother, 

in  terms  of 

i n d i v i d u al 

f 
The 

f a t h e r, 

(2) 

Question  1. 

"What 

is  t he  name  of  B r e tt  Fishman's  moth-

The  s i g n i f i c a nt  aspects  of 
form 
i ts  n e g a t i on 

t h at 
t a i n i ng  c o n s t a n t s.  W i th  t he  data  base  used, 
q u i r es 
f o ur  l e v e ls  of  search 
a  r e f u t a t i o n. 

f o ur  axioms  and 

in  clause 

t h is  simple  q u e s t i on 
is  a  u n it  c l a u se  c o n­

it  r e­
to  achieve 

is 

v* 
l 

Both  t he 

l e n g th  one 

t he  s t a t i s t i cs 

t he  }*  a l g o r i t hm  has 

to  generate  a ll  axioms 

t he  minimal  number  of  base 

( i . e .,  a ll  t he  data  axioms), 

and  Q*  a l g o r i t h ms  s u c c e s s f u l ly  com-
in  Table 
l e v e ls  of 

p l e t ed  t he  search,  however  as 
2  demonstrate,  w i th  c o n s i d e r a b ly  d i f f e r e nt 
work  and  r e s o u r c es  r e q u i r e d.  Whereas  t he  Q*  a l g o r i t hm 
f o r t u i t o u s ly  generated 
c l a u s e s, 
of 
t h r ee  and  some  axioms  of 
q u i r ed  general  axiom 
(of 
Once  t h is  general  axiom  was  r e s o l v ed  a g a i n st 
c l a u s e, 
ed  a g a i n st  many  of 
t he  axioms  already 
s i m i l a r ly  f or  t he  r e s o l v e n ts  o b t a i n e d. 
sequence,  many  more  r e s o l v e n ts  were  generated. 
Furthermore, 
in  A - s e ts  r e q u i r ed 
f r ee  space  to  keep  t r a ck  of  t he  clauses  as  w e ll  as  a 
s i g n i f i c a nt 

t he  query 
t he  r e s o l v e n t,  having  support,  c o u ld  be  r e s o l v­

t w o,  and 
l e n g th 
t he  r e­
l e n g th  f o u r)  was  o b t a i n e d. 

l a r ge  number  of  clauses 
t he  use  of  a  considerable  amount  of 

i n c r e a se  in  t he  search  t i me  r e q u i r e d. 

t he  presence  of  a 

in  A - s e t s,  and 

f o ur  b e f o re 

As  a  c o n-

Question  2. 
on  t he 
f a t h er  on  t he  m o t h e r 's  s i de  of 

f a t h e r 's  s i de  of 

" Is  t h e re  a  person  who  is  t he  g r a n d f a t h er 

i n d i v i d u al  67  and 

t he  g r a n d­

i n d i v i d u al  7?" 

The  Q* 
a l g o r i t h ms  w i t h o ut  t he  use  of  semantics  gener-

of  p o s s i b le  s o l u t i o ns  to  a  subproblem  is  used. 
and  1 
ated  t he  same  number  of  i n f e r e n c e s.  However,  £ 
b r o u g ht  in  381  axioms,  o n ly  6  of  which  were  needed. 
Q*  when  n ot  u s i ng  semantics  brought  in  16  axioms,  o n ly 
6  of  which  were  a c t u a l ly  needed.  Q*  w i t h o ut  semantics 
performed  b e t t er  when  u s i ng  SL  r e s o l u t i on  t h an  when 
using  s e t - o f - s u p p o rt  as  t he 
use  of  semantics 
The  number  of  axioms  entered  were  7,  w h i le  o n ly  6  were 
f or 
needed 
is  a  s i g n i f i c a nt 
decrease 
in 
semantics, 
be  t he  t y pe  of 
achieve  u s i ng  semantic  c o n s i d e r a t i o ns 
search. 
i n d i c a t i ve  of 
semantics. 
s o l u t i on  and 

t he  p r o o f. 
t he  number  of  axioms  generated  u s i ng 
t he  one  example  should  n ot  be  considered 

The  t r a ce  of  clauses  generated  by  SL  r e­
t he  proof  are  shown  in  F i g u re  2. 

improvement  t h at  one  w i ll  always 

to  r e s t r i ct 
t he  use  of 

i n f e r e n ce  mechanism. 

i ts  general  u t i l i t y. 

Although  t h e re 

f or  Q*  shows 

However, 

The 

t he 

to 

is 

it 

6. 

Summary 

to  d i r e ct 

t he  search 

in  a  Question-Answering 

i n f o r m a t i on  such  as  clause 

We  have  described  a  search  s t r a t e gy  f or  theorem-
i n f o r­

Experience  w i th  such  systems  may  have  l ed  some 

l e v el 
l e n g th  to  d i r e ct  t he  s e a r c h.  Others  have 
to  use  o n ly  r e f i n e m e n ts  of  r e s o l u t i on  w i th  a 

o r o v i nq  which  uses  both  s v n t a c t ic  and  semantic 
mation 
System.  Most  theorem-proving  systems  have  used 
p r i m a r i ly  s y n t a c t ic 
and  c l a u se 
attempted 
b r e a d t h - f i r st  search  or  an  ad  hoc  use  of  h e u r i s t ic 
r u l e s. 
to  speculate 
must  be  developed  to  perform  d e d u c t i on 
answering,  or 
Hayes 
inadequacy  of  search 
theorem-proving  may  stem  from  t he 
s t r a t e g i es 
"reasonable"  num­
l i m it  t he  search  to  a 
ber  of  nodes  in  f i n d i ng  p r o o f s.  We  agree  t h at  t he  use 
of  o n ly 
n ot  be  s u f f i c i e nt  f or  most 
our  hope 
to  a id 

l o g i c al  r u l es  and  s y n t a c t ic  h e u r i s t i cs  w i ll 
is 

theorem-proving 
in  q u e s t i o n-
( e . g .,  Anderson  and 
t h is  s k e p t i c i sm  of 

in  o t h er  problems 
f or 

t he  search  w i ll  be  u s e f u l. 

i n t r o d u c t i on  of  semantic 

[1972])13  The  reason 

systems.  However, 

t h at  means  o t h er 

in  d i r e c t i ng 

i n f o r m a t i on 

than 

t h at 

We  have  t r i ed  to  show  where  semantic  i n f o r m a t i on 
it  may  c o o r­
l o g i c al  d e­
There  are  s e v e r al  p l a c es  where  semantics 
t he  search  p r o c e s s: 

in  a  theorem  p r o v e r,  and  how 
t he  s y n t a c t ic  h e u r i s t i cs  and 

may  be  used 
d i n a te  w i th 
d u c t i o n. 
e n t er 

i n to 

t he 

to 

it 

The  n e g a t i on  of 

t he  Question 

in  c l a u se 

form 

i s: 

FF(x,  67)  V  FM(x,  7) 

is  t he  p r e d i c a te  " g r a n d f a t h er  on  t he 

where  FF 
is  t he  p r e d i c a te  " g r a n d f a t h er 
f a t h e r 's  s i d e ",  and 
T h is  q u e s t i o n,  which  r e q u i r es 
on  t he  m o t h e r 's  s i d e ." 
s ix  l e v e ls  of  search  r e q u i r es 
t he  f o l l o w i ng  s ix  axioms 
from  t he  s et  of  295  d a ta  axioms  and  88  g e n e r al  axioms: 

FM 

(1) 

(2) 

(3) 

(4) 

t he 

at 
mine  whether 
it 
in  s e l e c t i ng  a 
pand; 
in 
t he 
a t o r s;  and 
in 

time  a  c l a u se 

is  g e n e r a t e d, 

to  d e t e r­
is  s e m a n t i c a l ly  m e a n i n g f u l; 
l i t e r al  of  a  c l a u se  to  e x­

f i l t e r i ng  o ut  of 

i r r e l e v a nt  o p e r­

t a k i ng  a c t i o ns  when  a 

l i t e r al 

is  s o l v e d. 

F ( x,  y)  V  M(y,  z)  v  FM(x,  z) 
F(x,  y)  V  F { y,  z)  V  FF(x,  z) 
M(4,  7 ), 

F ( 6,  4 ), 

F ( 6,  6 3 ),  and  F ( 6 3,  67) 

. 

Proofs  were  found  u s i ng  s e t - o f - s u p p o rt  and  SL 

i n f e r e n ce  mechanism. 

r e s o l u t i on  as  t he 
f or  s e t - o f - s u p p o rt  i n d i c a te  t h at  t he  Q*  a l g o r i t hm  was 
q u i te  s e l e c t i ve  as  compared  to 
b o th  w i th  r e s p e ct  to 
t he  number  of  r e s o l v e n ts  and  axioms  generated.  How­
e v e r,  0*  d id  o b t a in  c o n s i d e r a b ly  more  general  axioms 
t h an  a c t u a l ly  needed. 

The  s t a t i s t i cs 

The  same  q u e s t i on  was  t e s t ed  using  SL  r e s o l u t i on 

as  t he  i n f e r e n ce  mechanism. 
f or  t he  Q*  a l g o r i t hm  as  generated  by  t he  computer, 
a l so  shows  s t a t i s t i c s,  generated  by  hand, 
a l g o r i t hm  when  t he  semantic  r u le  of  c o u n t i ng 

The  t a b le  shows  s t a t i s t i cs 

t he  number 

f or  t he  Q* 

it 

36 

There  i s,  however,  a  t r a d e o ff  as 
s h o u ld  be  a p p l i e d. 
determine  whether  or  n ot  a  c l a u se 
t a ke  more 
Hence,  s t u d i es  must  be  performed 
determine  t he  v a r i o us  c o s ts 

i n v o l v e d. 

It  may  r e s u lt  t h at 

t he  a t t e m pt  to 

to  when  semantics 

is  s o l v a b le  c o u ld 

t i me  than  t he  s o l v i ng  of  t he  problem. 

in  t h is  area 

to 

W i th  an  a r b i t r a ry 

i n f e r e n ce  system  it  is  n ot 
always  easy  to  determine  when  a  l i t e r al  f r om  some 
c l a u se  has  been  s o l v e d. 
i n v o l v ed  c o u ld  become  unmanageable.  However,  as  de-
s c r i b ed  p r e v i o u s l y,  SL  r e s o l u t i on  minimizes 
t he  book-
keeping  problem. 
advantage  of  p r o v i d i ng 
subproblem 

SL  r e s o l u t i on  has  t he  a d d i t i o n al 

The  bookkeeping  t h at  m i g ht  be 

t he  o p p o r t u n i ty 

to  s e l e ct  w h i ch 

to  a t t a ck  n e x t. 

Some  of 

t he  semantic 

e r a l,  e . g ., 
subproblem; 

t he  count  of 
if  such  i n f o r m a t i on 

i n f o r m a t i on  we  use  is  gen-
to  a 

t he  number  of  s o l u t i o ns 

is  s u p p l i ed  by 

t he 

10.  Kowalski,  R.  and  Kuehner,  D. 

"Linear  Resolution 

w i th  Selection  Function."  A r t i f i c i al  Intelligence 
2,  3/4, 

(1971),  221-260. 

1 1.  Slagle,  J.R.  and  F a r r e l l,  C D. 

"Experiments  in 
Automatic  Learning  f or  a  Multipurpose  Heuristic 
Program."  Ccmm. ACM 14,  2(Feb.  1971),  91-98. 

12.  Hewitt,  C. 

PLANNER."  Proc. 
London,  England,  1971,  167-182. 

"Procedural  Embedding  of  Knowledge  in 
IJCAI,  B r i t i sh  Computer  Society, 

13.  Anderson,  D.  and  Hayes,  P.J.  An  Arraignment  of 

Theorem-Proying  or  the  Logician's  F o l l y,  Memo  No. 
54,  Dept.  of  Computational  Logic,  School  of  A . I ., 
University  of  Edinburgh,  Scotland,  1972  . 

14.  Sussman,  G.J.,  and  McDermott,  D.V. 

"From  PLANNER 

to  CONNIVER  -  A  Genetic  Approach."  Proc.  FJCC, 
AFIPS  Press,  Montvale,  N . J .,  1972,  1171-1179. 

user  it  could  be  used  to  advantage  f or  any  problem 
domain.  A  general  framework  f or  representing  and 
applying  semantic  information  is  needed. 
our  semantic  considerations  have  been  directed 
p r i m a r i ly  at  the  meaning  of  constants,  and  not  at  the 
meaning  of  functions  and  Skolem  functions  t h at  may 
frequently  occur  in  clauses.  These  must  also  be  con­
sidered. 

In  a d d i t i o n, 

We  have  presented  a  f i r st  version  of  the  Q*  a l­

gorithm  t h at  carbines  syntactic  and  semantic  consider­
ations. 
Improvements  must  be  made  in  the  algorithm  to 
handle  p a r a l l el  searching  such  as  in  CONNIVER  (Sussman 
and  McDermott[1972])14  and  to  implement  some  of  the 
features  that  were  described,  but  not  incorporated  i n­
to  the  f i r st  version.  However,  based  on  l i m i t ed  ex­
perience  w i th  the  current  version  of  Q*, 
it  has  been 
observed  that  the  search  does  r e s t r i ct  the  generation 
of  clauses. 

The  area  of  semantics  and  theorem-proving  r e­
quires  considerably  more  research  and  experimentation. 
This  paper  has  described  a  f i r st  step  in  exploring 
t h is  area. 

References 

1.  Minker,  J .,  Fishman,  D.H.,  and  McSkimin,  J.R.  The 

Maryland  Refutation  Proof  Procedure  System  (MKPPS). 
TR-208,  Computer  Science  Center,  University  of 
Maryland,  College  Park,  Md.,  1972. 

2.  Minker,  J .,  McSkimin,  J . R. ,  Fishman,  D.H. 

MRPPS-An  Interactive  Refutation  Proof  procedure 
System  f or  Question-Answering.  TR-228,  Computer 
Science  Center,  University  of  Maryland,  College 
Park,  Md.,  1973. 

3.  Robinson,  J.A. 

the  Resolution  P r i n c i p l e ." 
23-41. 

"A  Machine  Oriented  Logic  Based  on 
J.ACM  12,  l ( J a n.  1965), 

4.  Reiter,  R.  The  Use  of  Models  in  Automatic  Theorem 

Proving,  Technical  Report  72-09,  Department  of'  ' 
Computer  Science,  University  of  B r i t i sh  Columbia, 
Vancouver  B.C.,  Canada,  September,  1972. 

5.  was,  L.T.,  Carson,  D.F.,  and  Robinson,  G.A. 

Unit  Preference  Strategy  in  Theorem  Proving." 
Proc.  FJCC,  Thompson  Book  Co.,  New  York,  1964, 
6X5-621. 

"The 

6.  Green,  C.C. 

"Theorem  Proving  by  Resolution  as  a 

gence  4,  American  Elsevier,  New  York,  1969,  183-

Basis  f or  Question-Answeriiig  Systems." 
Meltzer,  B.  and  Michie,  D. 
0 5 :— 

(Eds.),  Machine  I n t e l l i-

I n: 

7.  Kowalski,  R.  Studies  in  the  Completeness  and 

Efficiency  of  Theorem-Proving  by  Resolution.  Ph.D. 
Thesis,  U.  of  Edinburgh,  1970a. 

8.  Kowalski,  R. 

"Search  Strategies  f or  Theorem 

I n:  Meltzer,  B.  and  Michie,  D. 

Proving." 
Machine Intelligence  5, A m e r i c an Elsevier,  Hew 
York,  l970b,  181-266. 

(Eds.), 

9.  Hart,  P.,  Nilsson,  N.,  and  Raphael,  B. 

"A  Formal 
Basis  f or  the  Heuristic  Determination  of  Minimum 
Cost  Paths." 
2(1968),  100-107. 

IEEE  Trans.  Sys.  S c i.  Cybernetics  4, 

37 

Table  1 

(1)  Figures  do  not  include  the  clause  from  the  negation  of  the  theorem 

(2)  These  calculations  were  performed  by  hand  since  the  routines 

semantics  have  not  yet  been  implemented. 

that  are  to  handle 

(3) 

Set-of-support 

Linear  r e s o l u t i on  w i th  selection  function 

(4) 
(5)  Freespace  refers  to  the  storage  needed  by  clauses  formed  by  resolving  or  factoring 

38 

Figure 

1. 

The  use  of  constants  to  guide  the  search. 

39 

TRACE  OF  GENERATED  CLAUSES 

PROOF 

