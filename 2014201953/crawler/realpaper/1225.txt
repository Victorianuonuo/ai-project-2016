APPLICATION  OF  THEOREM  PROVING  TO  PROBLEM  SOLVING* 

Cordell  Green 

Stanford  Research 

I n s t i t u te 

Menlo  Park,  C a l i f o r n ia 

Abstract 

This  paper  shows  how  an  extension  of  the 
r e s o l u t i on  proof  procedure  can  be  used  to  con(cid:173)
s t r u ct  problem  s o l u t i o n s.  The  extended  proof 
procedure  can  solve  problems 
involving  state 
transformations.  The  paper  explores  several 
a l t e r n a te  problem  representations  and  provides 
a  discussion  of  solutions  to  sample  problems 
including  the  "Monkey  and  Bananas"  puzzle  and 
the 
solutions  to  these  problems  obtained  by  QA3,  a 
computer  program  bused  on  these  theorem-proving 
methods. 
In  a d d i t i o n,  the  paper  shows  how  QA3 
can  w r i te  simple  computer  programs  and  can  solve 
p r a c t i c al  problems 

'Tower  of  Hanoi"  puzzle.  The  paper  exhibits 

for  a  simple  robot. 

Key  Words:  Theorem  proving,  r e s o l u t i o n,  problem 
s o l v i n g,  automatic  programming,  pro(cid:173)
gram  w r i t i n g,  robots,  state  t r a n s(cid:173)
formations,  question  answering. 

Automatic  theorem  proving  by  the  resolution 

the  extended  proof  procedure  w i ll  f i nd  or 

f i r s t - o r d er 
In  an  e a r l i er  paper  Green  and  Raphael" 

proof  procedure  §  represents  perhaps  the  most 
powerful  known  method  f or  automatically  determin(cid:173)
ing  the  v a l i d i ty  of  a  statement  of 
l o g i c. 
i l l u s t r a t ed  how  an  extended  resolution  procedure 
can  be  used  as  a  question  answerer—e.g., 
if  the 
statement 
(3x)P(x)  can  be  shown  to  follow  from  a 
set  of  axioms  by  the  resolution  proof  procedure, 
then 
construct  an  x  that  s a t i s f i es  P(x).  This  e a r l i er 
paper  (1)  showed  how  one  can  axiomatize  simple 
question-answering  subjects, 
question-answering  program  called  QA2  based  on 
t h is  procedure,  and  (3)  presented  examples  of 
simple  question-answering  dialogues  with  QA2 . 
In  a  more  recent  paper" 
the  answer  construction  method 
proves  i ts  correctness, 
version  of  the  program,  QA3,  and  (3) 
state-transformation  methods 
t i ve  proof  formalism. 
question-answering  applications 
in 
these  e a r l i er  papers,  QA3  has  been  used  as  an 
SRI  robot4  problem  solver  and  as  an  automatic 
program  w r i t e r.  The  purpose  of  t h is  paper 
is 

(2)  describes  the  l a t e st 
introduces 
the  construc(cid:173)

the  author  (1)  presents 

In  addition  to  the 

(2)  described  a 

in  d e t a il  and 

i l l u s t r a t ed 

i n to 

This  research  is  a  part  of  Project  Defender  and 
was  supported  by  the  Advanced  Research  Projects 
Agency  of  the  Department  of  Defense  and  was 
monitored  by  Rome  A ir  Development  Center  under 
Contracts  AF  30(602)-4147  and  F30602-69-C-0056. 

This  p r e p r i nt 
subject 

is  a  preliminary  version  and 

is 
to  modification  p r i or  to  p u b l i c a t i o n. 

(1) 

to  explore  the  question  of  p r e d i(cid:173)

t w o f o l d: 
cate  calculus  representation 
transformation  problems  in  general,  and  (2) 
to 
elaborate  upon  robot  and  program-writing  a p p l i(cid:173)
cations  of  t h is  approach  and  the  mechanisms 
underlying  them. 

f or  s t a t e-

Exactly  how  one  can  use  logic  and  theorem 

the 

that 

the  f i r st  d i f f i c u l t i es  encountered 

in  formal 
I n t e r e st  has  been  shown  in  seeing  several 
i l l u s t r a te  alternate  meth(cid:173)

proving  f or  problem  solving  requires  careful 
thought  on  the  part  of  the  user. 
.Judging  from  my 
experience,  and  that  of  others  using  QA2  and  QA3, 
one  of 
is 
representation  of  problems,  especially  s t a t e-
transformation  problems,  by  statements 
l o g i c. 
detailed  examples 
ods  of  axiomatizing  such  problems—i.e., 
niques 
f i r s t - o r d er 
This  paper  provides  detailed  examples  of  various 
methods  of  representation.  A f t er  presenting 
methods  in  Sees. 
I I,  a  s o l u t i on  to  the 
classic  "Monkey  and  Bananas"  problem  is  provided 
I I I.  Next,  Sec.  IV  compares  several  a l(cid:173)
in  Sec. 
ternate  representations 
f or  the  "Tower  of  Hanoi 
puzzle.  Two  a p p l i c a t i o n s,  robot  problem  solving 
and  automatic  programming,  are  discussed 
V  and  V I,  r e s p e c t i v e l y. 

for  "programming" 

tech(cid:173)
l o g i c. 

in  Sees. 

I  and 

in 

1.  An  Introduction  to 

State-Transformation  Methods 

these  concepts 

the  usefulness  of 

The  concepts  of  states  and  state  transforma(cid:173)
long 

tions  have  of  course  been  in  existence  for  a 
time,  and 
for 
problem  solving  is  w e ll  known.  The  purpose  of 
t h is  paper  is  not 
to  discuss  states  and  state 
transformations  as  such,  but  instead  to  show  how 
these  concepts  can  be  used  by  an  automatic  resolu(cid:173)
t i on  theorem  prover. 
the  employment 
of  these  methods  has  greatly  extended  the  problem-
solving  capacity  of  QA2  and  QA3.  McCarthy  and 
Hayes  present  a  relevant  discussion  of  philosophi(cid:173)
cal  problems 
zations  . 

involved  in  attempting  such  f o r m a l i(cid:173)

In  p r a c t i c e, 

F i r st  we  w i ll  present  a  simple  example.  We 
begin  by  considering  how  a  p a r t i c u l ar  universe  of 
discourse  might  be  described 

l o g i c. 

in 

Facts  describing  the  universe  of  discourse 

in  the  form  of  statements  of  mathe(cid:173)
l o g i c.  Questions  or  problems  are  stated 

If  a  theorem  is 

are  expressed 
matical 
as  conjectures  to  be  proved. 
proved, 
prover  is  such  that  the  proof 
if 
i . e ., 
object 
such  an  o b j e c t. 

then  the  proof 

then  the  nature  of  our  extended  theorem 

"constructive"— 
the  theorem  asserts  the  existence  of  an 

is 

finds  or  constructs 

References  are  l i s t ed  at  the  end  of  t h is  paper. 

At  any  given  moment  the  universe  under  con(cid:173)

s i d e r a t i on  may  be  said  to  be  in  a  given  s t a t e. 

-219-

We  w i ll  represent  a  p a r t i c u l ar  state  by  a 
subscripted  s — e . g .,  sl 7.  The  l e t t er  s,  w i th  no 
subscript,  w i ll  be  a  v a r i a b l e,  ranging  over 
s t a t e s.  A  state  is  described  by  means  of  p r e d i(cid:173)
cates. 
AT(objectx,b,s1) 
o b j e c t,  o b j e c t !, 
predicate  be  axiom  A l: 

is  t r u e, 
is  at  p o s i t i on  b. 

then  in  state  s1  the 

the  predicate 

For  example, 

Let  t h is 

if 

A l.  AT (object!  b,s1  )  . 
The  question  "where 
be  expressed  in  l o g ic  as  the  theorem 
.  The  answer  found  by  using 
(r5x)AT(object1  x,s1) 
system  QA3  to  prove  t h is  theorem  is  "yes,  x  =  b. 

in  state  S!?"  can 

is  o b j e c t! 

Changes 

in  states  are  brought  about  by  per(cid:173)

forming  actions  and  sequences  of  a c t i o n s.  An 
action  can  be  represented  by  an  action  function 
that  maps  states  i n to  new  states  (achieved  by 
executing  the  a c t i o n ).  An  axiom  describing  the 
e f f e ct  of  an  action 

t y p i c a l ly  of  the  form 

is 

(Vs)[P(s)  3  Q(f ( s ) )] 

where  s 

is  a  state  variable 

P  is  a  predicate  describing  a  state 
f 

function  (corresponding  to 
is  an  action 
some  action) 
that  maps  a  state  i n to  a 
new  state  (achieved  by  executing  the 
action) 

Q  is  a  predicate  describing  the  new  s t a t e. 

( E n t i t i es  such  as  P  and  f  are  termed  " s i t u a t i o n al 
f l u e n t s"  by  McCarthy.) 

As  an  example,  consider  an  axiom  describing 
the  fact  that  object1  can  be  pushed  from  point  b 
to  point  c. 

The  axiom  is 

A2. 

( V s ) [ A T ( o b j e c t1b , s)  3 

A T ( o b j e c t ! , c , p u s h ( o b j e c t ! , b , c , s ) ) ]. 

The  f u n c t i on  push(object!,b,c,s)  corresponds  to 
the  action  of  pushing  object! 
(Assume, 
executor  of 

f r om  b  to  c. 
is  the 

these  actions.) 

that  a  robot 

f or  example, 

Now  consider  the  question,  "Does  there  e x i st 

is  at 

a  sequence  of  actions  such  that  object1 
point  c?"  Equivalently,  one  may  ask, 
e x i st  a  s t a t e,  possibly  r e s u l t i ng  from  applying 
i n i t i al  state  s1,  such 
action  functions  to  an 
in 
t h at  object1 
l o g i c, 
(3s)AT(object1  ,c,s)  ,  and  the  answer, 
provided  by  the  theorem-proving  program  applied 
to  axioms  Al  and  A2, 
s  =  push(object 

is  at  point  c?"  This  question, 

is  "yes, 

is 

'Does  there 

, bfc ,s  ) ." 
t h i rd  axiom9  indicates 

that  objec1 

Suppose  a 

can  be  pushed  from  c  to  d: 

A3. 

(Vs)[AT(object!,c,s)  => 

ATCobject1 

jdjpushfobject 

, c , d , s ) ) l. 

-220-

imply 

that  s t a r t i ng 

these  three  axioms 

Together, 
in  state  s1  ,  object1  can  be  pushed  from  b  to  c 
and  then  from  c  to  d.  This  sequence  of  actions 
(a  program  f or  our  robot)  can  be  expressed  by 
the  composition  of 
p u s h ( o b j e c t1, c , d , p u s h ( o b j e c t1, b , c , s1) ). 
normal  order  of 
innermost 
correct  sequence 

from  the 
f u n c t i on  to  the  outermost,  gives  the 

the  two  push  f u n c t i o n s, 

f u n c t i on  evaluation, 

in  which  to  perform  the  a c t i o n s. 

The 

To  f i nd  t h is  s o l u t i on  to  the  problem  of  get(cid:173)

to  p o s i t i on  d, 

t i ng  object1 
j e c t u re  is  posed  to  the  theorem  prover: 
there e x i st a state such that object1 is atposition d?" or, stated in l o g i c, 
(3s)AT(object1  ,d,s)  .  The  answer  returned  is 
"yes,  s  =  p u s h ( o b j e c t1, c , d , p u s h ( o b j e c t1, b , c , S ! ) ) ." 

the  f o l l o w i ng  con(cid:173)
"Does 

in 

i t. 

The  proof  by  r e s o l u t i o n,  given  below,  demon(cid:173)

in  d e t a il 

l i t e r a l ,* 

in  Ref.  3. 

is  a  special 

the  object  being 

the  clause  containing 

In  t h is  exam(cid:173)
the  sequence 

the  proof  the  answer  l i t e r al  w i ll 

strates  how  the  desired  answer  is  formed  as  a 
composition  of  action  f u n c t i o n s, 
thus  describing 
a  sequence  of  necessary  actions .  The  mechanism 
f or  f i n d i ng  t h is  answer 
the  "answer  l i t e r a l ."  This  method  of  f i n d i ng  an 
answer  is  explained 
For  our 
purposes  here,  we  w i ll 
j u st  show  how  it  works  by 
example. 
In  the  proof  below,  each  answer  l i t e r al 
is  displayed  beneath 
At  each  step 
contain  the  current  value  of 
constructed  by  the  theorem  prover. 
ple  the  object  being  constructed 
is 
of  actions  s.  So  i n i t i a l ly  the  answer  l i t e r al 
ANSWER(s) 
is  added  to  the  clause  representing 
the  negation  of  the  question. 
is  not 
t h is  clause,  Clause  1,  as  " e i t h er  object1 
The  state 
at  d 
is  the 
variable  s, 
is 
"place  holder"  where  the  s o l u t i on  sequence 
in  t h is 
constructed.  The  construction  process 
proof  consists  of  successive 
i n s t a n t i a t i o ns  of 
s.  An  i n s t a n t i a t i on  of  s  can  occur  whenever  a 
l i t e r al  containing  s 
creation  of  a  r e s o l v e n t.  Each  i n s t a n t i a t i o n*  of 
s  f i l ls  in  a  new  action  or  an  argument  of  an 
action  f u n c t i o n. 
ence  step  in  the  proof 
(either  by  f a c t o r i n g*  or 
resolving*)  need  not  necessarily  f u r t h er  i n s t a n(cid:173)
t i a te  s.  For  example, 
the  step  might  be  an 
inference  that  v e r i f i es  that  some  p a r t i c u l ar 
property  holds 
that 
step  in  the  proof. 
yields  Clause  7, 
push(object 
terminates 

in  state  s,  or  s  is  an  answer.") 
inside  the  answer  l i t e r a l, 

In  general,  a  p a r t i c u l ar  i n f e r(cid:173)

The  f i n al  step  in  the  proof 

f or  the  current  answer  at 

(One  can  i n t e r p r et 

,b,c,s  ) ) ,"  which 

,c,d,push(object 

"an  answer  is 

i n s t a n t i a t ed 

the  proof. 

in  the 

is 

* 

We  assume  the  reader  is  f a m i l i ar  w i th  the 
vocabulary  of  the 
theorem  proving 
by  r e s o l u t i on  as  described  in  Refs.  1,  7,  and  8. 

f i e ld  of 

P r o of 

1. 

2. 

3. 

4. 

5. 

6. 

7. 

C o n t r a d i c t i on 

Axiom  A2 

Resolve  3,4 

Axiom  Al 

Resolve  5,6 

For 

t he  p a r t i c u l ar  p r o of  e x h i b i t ed  h e r e, 

t he 
t he  s o l u t i on  sequence  d u r i ng 

to  be 

t he  same 

i n d i c a t es 
T h is  o r d er  c o n s i s ts  of  w o r k i ng 

t he  p r o of 

f i l l i ng 

in 

t he 

l a st 

the  n e x t - t o - l a st  a c t i o n,  e t c. 

In 

t h en 

f r om 

the  g o al  by 

t he  p r o of  happens 
t he  p r i n t o ut  of 

f or 
in  w h i ch 
i n s t a n t i a t e d. 

o r d er  of  g e n e r a t i ng 
t he  s e a r ch 
o r d er 
s 
is 
backward 
a c t i o ni 
g e n e r a l, 
is  g e n e r a t ed  depends  upon 
s i n ce 
in  w h i ch  c l a u s es  a re  r e s o l v ed  or 
p r o of 
a n s w e r s,  g i v en 
a re  c o r r e ct 

in  R e f.  4,  shows 

r e g a r d l e ss  of 

t he  o r d er 

in  which 

t h at 

t he  p r o of  s t r a t e gy  d e t e r m i n es 

t he  s o l u t i on  sequence 

t he  p r o of  s t r a t e g y, 
t he  o r d er 

f a c t o r e d. 

The 

t h at 

t he  answers 

t he  p r o of  s t r a t e gy  u s e d. 

t h is  method  always  produces  c o r r e ct 

I I. 

Refinements  of 

t he  Method 

The  purpose  of 

t h is  s e c t i on 

is 

t he 

f o r m u l a t i on  p r e s e n t ed 

v a r i a t i o ns  of 
p r e v i o us  s e c t i on  and 
t i o ns  such  as 
be  b r o u g ht 
i n t e r e s t ed 
m a t e r i al  on  r e p r e s e n t a t i on  may  omit  Sees. 
and 

to  show  how  o t h er  c o n s i d e r a(cid:173)
t i me  and  c o n d i t i o n al  o p e r a t i o ns  can 
is 
t h an  a d d i t i o n al 
I I I, 

i n to 
in  a p p l i c a t i o ns 

I V,  and  r e ad  Sees.  V  and  V I. 

The  r e a d er  who 

f o r m a l i s m. 

r a t h er 

t he 

I I, 

to  d i s c u ss 
t he 

in 

A. 

An  A l t e r n a te  F o r m u l a t i on 

is  an 

in 

f o r m u l a t i o n. 

to 

t he  o r i g i n a l,  p r e s e n t ed 

f i r st  s u b j e ct  we  s h a ll  d i s c u ss 
to 

t he  p r e v i o u s ly  g i v en 

I,  as 

f o r m u l a t i on 

The 
a l t e r n a te 
We  s h a ll  r e f er 
Sec. 
f o r m u l a t i on 
s y s t e m - t h e o r e t ic  n o t i on  of  s t a te 
The  s t a te 
f u n c t i on 
g i v es 
a  new  s t a t e. 
m a t i on 

I,  and 
F o r m u l a t i on 

t r a n s f o r m a t i on 

f  r e p r e s e nt 

t he  mapping  of  an  a c t i on  and  a  s t a te 

t he  s t a te 

L et 

I I. 

f u n c t i o n,  whose  arguments  a re  an  a c t i on 

t h is  a l t e r n a te  as 
II  c o r r e s p o n ds 

to  a 

t r a n s f o r m a t i o n s. 
f or  a  system 
i n to 

t r a n s f o r(cid:173)

[ a1]  be 

L et  g  be  a 

is 
t he  a c t i on 

t he  new  s t a te 
t he  s t a t e. 
to 
t he  a c t i o n s,  and  n il  be 
t he  n u ll 

and  a  s t a te  and  whose  v a l ue 
o b t a i n ed  by  a p p l y i ng 
L et 
a c t i o n. 
i n to  a  s i n g le  composite  a c t i on  whose  e f f e ct 
t he  same  as 
s e q u e n t i a l l y. 
i ng 
f o r m a t i on 

t he  argument  a c t i o ns  a p p l i ed 
f o l l o w(cid:173)
t r a n s(cid:173)

f o rm  would  p a r t i a l ly  d e f i ne 

For  example,  axioms  of 

t he 
t he  s t a te 

t h at  maps 

f u n c t i on 

f u n c t i on 

t h at  of 

is 

f: 

two  a c t i o ns 

B l. 

(Vs)[P(s)  =>  Q(f (ai  , s ) )l 

B 2. 

( V s ) [f ( n i l , s)  =  si 

B 3. 

( V s , a1, aj) [ f ( aj, f ( a1, s ))  = 

f ( g^  ,a 

)  , s)  ]  . 

The  p r e d i c a t es  P  and  Q  r e p r e s e nt  d e s c r i p t o rs 

in 

t h at 

t h at 

t h at 

t h at  a re 

in  B3  says 

t he  e f f e ct  of 

t he  r e s u lt  of  an 

Axiom  Bl  d e s c r i b es 

t he  c l a ss  of  s t a t es 

t he  n u ll  a c t i on  has  no  e f f e c t. 

to 
they  a ll  have 
The  r e s u l t i ng  s t a t es  are 
t h ey  have  p r o p e r ty  Q ( s ). 

of  s t a t e s. 
a c t i on  ax  a p p l i ed 
e q u i v a l e nt 
t h at 
t he  p r o p e r ty 
P(s)  . 
t h us  e q u i v a l e nt 
in 
i n d i(cid:173)
Axiom  B2 
c a t es 
The 
e q u a t i on 
t he  com(cid:173)
p o s i te  a c t i on  sequence 
t he  same  as 
t h at  of  a c t i o ns  a1  and  aj  a p p l i ed  s e q u e n t i a l l y. 
The  q u e s t i on  posed 
i n c l u de  an 
be 
sequence  of  a c t i o ns  x 
s t a te  s a t i s f y i ng 
we  a re  n ot 
sequence  of  a c t i o n s,  but  any  sequence 
us 
t he 
c l a ss  of  s t a t e s. 

i n i t i al  s t a t e — e . g .,  a  q u e s t i on  m i g ht 
t h e re  e x i st  a 
i n to  a 
t h at 

t he  p r e d i c a te  Q?"  Observe 
f i n d i ng  a  p a r t i c u l ar 

to  a  s a t i s f a c t o ry  s t a te  w i t h in 

t h at  maps  s t a te  Sy 

,  meaning  "Does 

f o r m u l a t i on  can 

i n s i s t i ng  on 

t h at 
t a r g et 

g(a,a1.) 

leads 

t h is 

in 

is 

T h is 

r e p r e s e n t a t i on 

is  more  complex,  but  has 

t he  p r e v i o us 

r e p r e s e n t a t i on 

t he  s t a r t i ng  s t a te  of  a 

t r a n s f o r m a t i on 
t he  sequence  of  a c t i o ns  a re  e x p l i c i t ly  g i v en 
t he  arguments  of 

t he  s t a t e - t r a n s f o r m a t i on 

T h u s,  one  can  q u a n t i fy  o v e r,  or  s p e c i fy 

t he  advantage  o v er 
t h at  b o th 
and 
as 
f u n c t i o n. 
in  p a r t i c u l a r,  e i t h er 
sequence,  or  b o t h. 

t he  s t a r t i ng  s t a te  or 

t he 

Next  we  s h a ll  show  how  o t h er  c o n s i d e r a t i o ns 

can  be  b r o u g ht 
i s m. 
a l t e r n a te 

Both 

i n to  a  s t a t e - t r a n s f o r m a t i on 
( I)  and 

f o r m u l a t i on 

t he  o r i g i n al 

f o r m a l(cid:173)
t he 

( I I)  w i ll  be  used  as  needed. 

B.  No  Change  of  S t a te 

r e p r e s e n ts  an 

i m p l i c a(cid:173)

f or  a 

T h is  k i nd  of  s t a t e m e nt 
t h at  h o l ds 

f i x ed  s t a t e. 

t i on 
t y p i c al  of 
t h is  c l a ss  m i g ht  d e s c r i be 
s h ip  between  movable  o b j e c t s;  e . g ., 
l e ft  of  y  and  y 
l e ft  of  z, 
t he 

l e ft  of  z. 

t he 

to 

is 

An  axiom 

r e l a t i o n(cid:173)
t he 
t he 
if  x 
is 
t h en  x 
to 

to 
is 

C. 

Time 

Time  can  be  a 
t i m i ng  of  a c t i o ns  and  s t a t e s. 
f u n c t i on 

t i m e ( s)  g i v es 

f u n c t i on  of  a  s t a t e, 

t i me  of  an 

t he 

to  express 
if 

For  example, 

t he 
t he 

- 2 2 1-

leads  to 
The  above  f i g u re  shows  t h at  action  i 
e i t h er  b  or  c  from  a.  The  f u n c t i on  f 
is  s i n g l e-
valued  but  we  don't  know  i ts  value.  The  goal  d 
can  be  reached  from  b  by  action  j,  or  from  c  by 
In  the  f o r m a l i z a t i on  given  below  it 
action  k. 
is  possible  to  prove  that 
is  reachable 
although  a  correct  sequence  of  actions  necessary 

the  goal 

-222-

that  a  c o n d i t i o n al  operation  is  needed  to  create 
a  single  conditional  answer.  This 
vides  a  useful  h e u r i s t ic 
applications  of  QA3:  When  a  clause  having  two 
answer  l i t e r a ls 
proof  strategy  c a ll 
the  c o n d i t i o n al  operation  (such  as  M5  and  M6). 
These  axioms  are  then  applied  to  create  a  single 
c o n d i t i o n al  answer. 

f or  the  program-writing 

l et  the 
that  describe 

to  be  generated, 

f or  the  axioms 

is  about 

information  pro(cid:173)

Waldinger  and  Lee  have  implemented  a  program-

(The 

w r i t i ng  program  PROW  that  also  uses  a  r e s o l u t i on 
theorem  prover  to  create  constructive  proofs,  but 
by  a  d i f f e r e nt  method  than  that  of  QA3. 
second  method  f or  creating  conditionals  by  combin(cid:173)
ing  two  answers 
is  closely  r e l a t ed  to  a  technique 
used  in  PROW.) 
the  target 
Information  about 
program  operations, 
the  general  r e l a t i o n s h ip 
of  the  problem  statement  and  axioms  to  the  allowed 
target  program  operations 
d i t i o n s,  and 
is  embedded  in  the  PROW  program. 
information  is  a ll 
M5,  M6,  and  M7. 

in  the  axioms—such  as  axioms 

the  syntax  of  the  target 

including  the 

In  QA3  t h is 

test  con(cid:173)

(2) 

(1) 

(3) 

language, 

H. 

A c q u i s i t i on  of 

Information 

Another  s i t u a t i on  that  arises 

in  problem 

i n s u f f i c i e nt 

in  which  at  the  time  the  problem 

solving  is  one 
there 
is  stated  and  a  s o l u t i on  is  to  be  produced, 
information  to  completely  specify 
is 
a  s o l u t i o n.  More  p r e c i s e l y, 
the  s o l u t i on  cannot 
name  every  action  and  t e st  condition  in  advance. 
As  an  example,  consider  a  robot  that  is  to  move 
from  a  to  c.  The  action  i 
leads  from  a  to  b  but 
no  path  to  c  is  known,  as  i l l u s t r a t ed  below. 

where  PATH(a,b,i)  means  that  i 
to  b.  The  question  (3s)AT(c,s) 
s o l u t i o n, 

is  a  path  from  a 

r e s u l ts 

in  the 

Axiom  N3  i l l u s t r a t es  an  important  aspect  of 

is  not 

if  we  want 

i n d i c a te  that 

If  a  condition 

is  made  state  dependent, 

l o c a t i on 
In  a  pure  theorem-
that 
to 

t h is  formalism  f or  problem  s o l v i n g: 
(such  as  the  robot's) 
then  we  must  specify  how  t h is  c o n d i t i on  changes 
when  the  state  is  changed.  Thus  in  axiom  N3  we 
must 
the  r o b o t 's 
changed  by  asking  f or  a  p a t h. 
proving  formalism, 
t h is  means 
know  any  condition  in  a  given  s t a t e,  we  must  prove 
what  that  condition  i s. 
state-dependent  conditions  need  to  be  known  at  each 
state  in  a  s o l u t i o n, 
prove  what  each  condition  is  at  each  state  in  a 
conjectured  s o l u t i o n. 
prover  w i ll  take  a 
McCarthy 
to  t h is  problem  as  the  frame 
problem,  where  the  word  "frame"  refers  to  the 
frame  of  reference  or  the  set  of  relevant  con(cid:173)
d i t i o n s.  Discussion  of  a  method  f or  easing  t h is 
problem  is  presented 

In  such  a  case  the  theorem 
long  time  to  f i nd  the  s o l u t i o n. 

then  the  theorem  prover  must 

If  a  large  number  of 

in  Sec.  V. 

r e f e rs 

1. 

Assignment  Operations 

An  assignment  operation  is  one  that  assigns 
a  value  to  a  v a r i a b l e.  An  example  of  an  assign(cid:173)
ment  is  the  statement  a  •-  h(a)  ,  meaning  that  the 
value  of  a  is  to  be  changed  to  the  value  of 
f u n c t i on  h ( a ). 
use  an  assignment  f u n c t i o n — i . e .,  assign(a,h(a))  . 
Using  Formulation 
by  the  axiom 

the 
In  our  representation,  we  s h a ll 

f u n c t i on  is  described 

t h is 

II 

However,  once  point  b  is  reached,  more  information 
can  be  acquired—for  example,  a  guide  to  the  area 
l i v es  at  b  and  w i ll  provide  a  path  to  point  c 
asked.  Or  perhaps  once  point  b  is  reached, 
robot  might  use  i ts  sensors 
paths 

to  observe  or  discover 

if 
the 

to  c. 

To  formalize  t h i s,  assume  that  the  action 

ask-path(b,c)  w i ll  r e s u lt 
when  taken  at  b.  For  s i m p l i c i t y,  assume  that  the 
name  of  the  path 
is  equal  to  the  state  r e s u l t i ng 
from  asking  the  question.  Using  formulation  I I, 
one  s u i t a b le  set  of  axioms 

in  a  proper  path  to  c, 

i s: 

I I I.  An  Example: 

The  Monkey  and  The  Bananas 

To  i l l u s t r a te  the  methods  described  e a r l i e r, 

we  present  an  axiomatization  of  McCarthy's  "Monkey 
and  Bananas"  problem. 

The  monkey  is  faced  with  the  problem  of  get(cid:173)
t i ng  a  bunch  of  bananas  hanging  from  the  c e i l i ng 
j u st  beyond  his  reach.  To  solve  the  problem, 
the 
monkey  must  push  a  box  to  an  empty  place  under 
the  bananas,  climb  on  top  of  the  box,  and  then 
reach  them. 

224-

The  c o n s t a n ts  are  monkey,  box,  bananas,  and 

The 

f u n c t i o ns  are  r e a c h,  c l i m b,  and 

u n d e r - b a n a n a s. 
move,  meaning 

t he 

f o l l o w i n g: 

r e a c h ( m , z , s) 

c l i m b ( m , b , s) 

The  s t a te  r e s u l t i ng 
a c t i on  of  m  r e a c h i ng  z,  s t a r t(cid:173)
i ng 

f r om  s t a te  s 

f r om 

t he 

The  s t a te  r e s u l t i ng 
a c t i on  of  m  c l i m b i ng  b,  s t a r t(cid:173)
i ng 

f r om  s t a te  s 

f r om 

t he 

m o v e ( m , b , u , s)  The  s t a te  r e s u l t i ng 

f r om 

t he 

a c t i on  of  m  moving  b 
u,  s t a r t i ng 

from  s t a te  s. 

to  p l a ce 

The  p r e d i c a t es  a r e: 

MOVABLE(b) 

,b  is  movable 

A T ( m , u , s) 

m  is  at  p l a ce  u 

in  s t a te  s 

ON(m,b,s) 

m  is  on  b 

in  s t a te  s 

HAS(m,z,s) 

m  has  z 

in  s t a te  s 

CLIMBABLE(m,b,s)  m  can  c l i mb  b 

in  s t a te  s 

REACHABLE(m,b,s)  m  can  r e a ch  b 

in  s t a te  s. 

The  axioms 

a r e: 

M B 1.  MOVABLE(box) 

*  The  a s t u te 
l e a ve  much 
" t oy  p r o b l e m" 
t ic  a x i o m a t i z a t i on  of 
The  p r o b l e m 's  v a l ue 
a  r e a s o n a b ly 
f a m i l i ar 

t he 

to 

r e a d e r. 

t h at 

r e a d er  w i ll  n o t i ce 
to  be  d e s i r e d. 

t he  axioms 
t he 
t r a d i t i on  we  p r e s e nt  an  u n r e a l i s(cid:173)
t h is  u n r e a l i s t ic  p r o b l e m. 
is 

In  k e e p i ng  w i th 

t h at 

f a ct 

l i es 

t he 

in 

it 

i n t e r e s t i ng  problem 

t h at  may  be 

MB8. 

The  question  is  "Does  there  exist  a  state  s 
(sequence  of  actions) 
bananas?" 

in  which  the  monkey  has  the 

QUESTION: 

The  answer  is  yes, 

s  =  reach(monkeyibananas,climb(monkey, 

box,move(monkey,box,under-bananas 

By  executing  t h is  f u n c t i o n, 

the  monkey  gets 

the  bananas.  The  monkey  must,  of  course,  execute 
the  functions 
the  innermost  and  working  outward.  Thus  he  f i r st 
moves  the  box  under  the  bananas, 
the  box,  and  then  reaches  the  bananas. 

in  the  usual  order,  s t a r t i ng  with 

then  climbs  on 

The  p r i n t o ut  of  the  proof 

appendix. 

is  given 

in  the 

IV. 
the  Tower  of  Hanoi  Puzzle 

Formalizations 

for 

The  f i r st  applications  of  our  question-

for  a  given  subject 

(The  major  d i f f i c u l ty 

answering  programs  were  to  "question-answering" 
examples.  Commonly  used  question-answering  exam(cid:173)
ples  have  short  proofs,  and  usually  there  are  a 
lew  obvious  formulations 
area. 
problems  usually 
is  searching  a  large  data  base, 
rather  than  f i n d i ng  a  long  and  d i f f i c u lt  proof.) 
Typically  any  reasonable  formulation  works  w e l l. 
As  one  goes  on  to  problems  l i ke  the  Tower  of  Hanoi 
puzzle,  more  e f f o rt 
sentation 
s o l v i n g. 

is  required  to  f i nd  a  repre(cid:173)
is  suitable  f or  e f f i c i e nt  problem 

in  question-answering 

that 

This  puzzle  has  proved  to  bo  an  i n t e r e s t i ng 

study  of  representation.  Several  people  using 
QA3  have  set  up  axiom  systems  for  the  puzzle. 
Apparently,  a  "good"  axiomatization--one  leading 
to  quick  s o l u t i o n s - - is  not  e n t i r e ly  obvious, 
since  many  axiomatizations  did  not  result 
in 
s o l u t i o n s. 
compare  several  alternate  representations, 
ing  ones  that 

In  t h is  section  we  w i ll  present  and 

lead  to  a  s o l u t i o n. 

i n c l u d(cid:173)

There  are  three  pegs—pegx,  peg2,  and  peg3. 

There  are  a  number  of  discs  each  of  whose  diameter 
is  d i f f e r e nt 
I n i t i a l ly  a ll  discs  are  stacked  on  pegx, 
of  descending  s i z e.  The  three-disc  version  is 
i l l u s t r a t ed  below. 

the  other  d i s c s. 

from  that  of  a ll 

in  order 

- 2 2 5-

that  w i ll 

to  f i nd  a  sequence  of 

t r a n s f er  a ll  the  discs 

The  object  of  the  puzzle  is 
moves 
from  peg1 
to  peg3.  The  allowed  moves  consist  of  taking  the 
top  disc  from  any  peg  and  placing  it  on  another 
peg,  but  a  disc  can  never  be  placed  on  top  of  a 
smaller  d i s c. 

In  order  to  c o r r e c t ly  specify 

the  problem, 

any  f o r m a l i z a t i on  must: 
of  the  discs 
(2)  specify  how  ac(cid:173)
t i o ns  change  the  p o s i t i on  of  the  d i s c s;  and  (3) 
specify  the  rules  of  the  game, 

f or  each  s t a t e; 

(1)  specify  the  positions 

i . e .,  what 

l e g a l. 

is 

Let  the  predicate  ON  specify  disc  p o s i t i o n s. 

is 

in  state  s  disc1 

In  the  simplest  representation  the  predicate  ON 
s p e c i f i es  the  p o s i t i on  of  one  d i s c — e . g ., 
ON(disc,peg_  ,s)  says  that 
on  peg1.  This  representation  requires  one  p r e d i(cid:173)
cate  to  specify  the  p o s i t i on  of  each  d i s c.  The 
r e l a t i ve  p o s i t i on  of  each  disc  e i t h er  must  be 
specified  by  another  statement,  or  else  if 
two 
discs  are  on  the  same  peg  it  must  be  i m p l i c i t ly 
understood  that 
Perhaps 
predicate  another  argument 
the  d i s c — i . e ., 
p o s i t i on  of 
t h is  requires 
ON(disc1,peg 
, p o s i t i o n g , s ).  Again, 
many  statements  to  specify  a  complete  configura(cid:173)
t i o n. 

in  the  proper  order. 
to  allow  the 
the 

the  simplest  extension 

that  s p e c i f i es 

they  are 

is 

Since  various  moves  are  constructing  stacks 

l(x,y) 

represent 

i ts  f i r st  element 

(representing  the  top  disc 

in  the  s t a c k ). 
f u n c t i on  i  corresponds  to  the  "cons"  f u n c t i on 

of  d i s c s,  and  since  stacks  can  be  represented 
as  l i s t s,  consider  as  an  a l t e r n a t i ve  representa(cid:173)
t i on  a  l i st  to  represent  a  stack  of  d i s c s. 
Let 
the  function 
the  l i st  t h at  has 
x  as 
in  the  stack)  and  y  as  the  r e st  of  the  l i st 
(representing  the  r e st  of  the  discs 
This 
in  LISP. 
ment  ON(i  (disc1  ^ ( d i s c2  , n i l ))  ,pegx  ,s)  asserts  that 
the  stack  having  top  d i s c,  d i s cx,  and  second  d i s c, 
discg  , 
a  useful  technique  in  logic—namely, 
functions  as  the  construction  (and  selection) 
operators. 
This  notion  is  consistent  w i th  the 
use  of  action  functions  as  constructors  of 
sequences. 

Let  n il  be  the  empty  l i s t.  The  s t a t e(cid:173)

is  on  peg-1  .  This  representation  i l l u s t r a t es 

the  use  of 

Next,  consider  how  to  express  possible 

idea  is 

is  a  b it 

that  c e r t a in 

in  s t a t e s.  Perhaps  the  simplest 

changes 
to  say  that  a  given  state  implies 
moves  are  l e g a l.  One  must  then  have  other  s t a t e(cid:173)
ments  i n d i c a t i ng  the  r e s u lt  of  each  move.  This 
lengthy. 
method 
in  one  statement  the  f a ct 
a  new  state  is  the  r e s u lt  of  a  move.  Thus  one 
such  move  to  a  new  state  is  described  by  (Vs)[ON 
( K d i s c1n i l)  j p e g1s)  A  ON(nil.pegg,s)  A  O N ( l ( d i s c2, 
j£(disc3  , n i l ))  ,peg3 ,s)  3  ON(nil,peg1 ,move(disc1 , 
peg1 ,pega  ,s))  A  O N ^ d i s^  i n i l)  ,peg2  ,move(disc1  , 
peg1pegg  ,s))  A  0 N ( l ( d i s c2, j e ( d i s c3, n i l ))  ,peg3, 
move(disc1,peg1  ,pegg,s))]  . 

is  easier  to  express 
It 
that  given  some  s t a t e, 

With 

t h is  method 

it 

a ll  possible  moves  and  c o n f i g u r a t i on  combinations. 
However, 
represent  whole  classes  of  states  and  moves.  Thus 

is  s t i ll  easier  to  use  variables 

to 

it 

is  possible 

to  enumerate 

( V s , x , y , z , p1pj .  ,Pk,d)[ON(L(d,x)  . p i , s)  A  ON(y,p,,s) 
A  ON(z,pk,s)  3  ON(x,pi,move(d,pi,p1,,s))  A  0N(L 
( d , y ) ,p .  »move(d,p1,p.,s))  A  ON(z,pk,move(d,pi,pj, 
s ) )]  specifies  a  whole  class  of  moves.  The  problem 
here  is  that  a d d i t i o n al  r e s t r i c t i o ns  must  be  added 
so  that  i l l e g al  states  cannot  be  part  of  a  s o l u t i o n, 
In  the  previous  formalism,  one  could  l et  the  axioms 
enumerate  j u st  the  l e g al  moves  and  s t a t e s, 
preventing 

incorrect  s o l u t i o n s. 

thus 

The 

f o r c i ng 

i l l e g al  but 

that  cannot 

f i r st  method 

l e g a l,  one  might 

f or  adding  r e s t r i c t i o ns 

is 
to  have  a  predicate  that  r e s t r i c ts  moves 
to  j u st 
the  l e g i t i m a te  s t a t e s.  Since  the  s t a r t i ng  state 
think  that  only  legal  states 
is 
can  be  reached.  However, 
the  r e s o l u t i on  process 
(set-of-support  strategy  ) 
t y p i c a l ly  works  back(cid:173)
ward  from  the  goal  state  toward  states  that  can 
reach  the  goal  state—such  states  are  sometimes 
called  " f o r c i ng  s t a t e s ."  Thus 
states  can  be  reached  by  working  backward  from 
incorrect 
the  goal  s t a t e.  This  does  not  allow  f or 
s o l u t i o n s,  since  the  only  f o r c i ng  states 
that  can 
appear  in  the  s o l u t i on  must  be  those  reached  from 
the  s t a r t i ng  state  (which  is  a  legal  state)  .  The 
r e s t r i c t i on  of  moving  only 
to  new  legal  states 
thus  prevents  an  e r r o r.  But  the  search  is  un(cid:173)
necessarily 
is 
lead  to  a 
considering 
to  eliminate 
s o l u t i o n.  So  a  better  s o l u t i on  is 
these  i l l e g al 
f o r c i ng  states  by  allowing  moves 
only  from  legal  states  to_  legal  s t a t e s.  This 
perhaps  the  best  s p e c i f i c a t i o n, 
an  axiom  is 

l a r g e,  since  the  theorem  prover 
i l l e g al  states 

( V s , x , y , z , pi,p . , pk, d ) [ 0 N ( 4 ( d , x ) , pi, 
s)  A  O N ( y , P j , s)  A  O N ( z , pk, s)  A  L E G A L ( L ( d , x ))  A 
LEGAL(X(d,y))  A  D I S T I N C T ( p . ,p 
, 
K  1 
move(d,p 
A  ON(z,p 
LEGAL(x) 
l i s t ed  in  order  of 
"cheat"  and  have  a  simpler  axiom  by  o m i t t i ng  the 
predicate  that  requires 
the  state  r e s u l t i ng 
from  a  move  have  a  legal  stack  of  d i s c s.  Since 
the  set-of-support  strategy 
the  theorem 
prover  to  work  backward  s t a r t i ng  from  a  legal 
f i n al  s t a t e, 
However,  one  is  then  using  an  axiomatization  t h a t, 
by  i t s e l f, 
The  a d d i t i o n al  LEGAL 
predicate  is  a  t y p i c al  example  of  how  a d d i t i o n al 
information  in  the  axioms  r e s u l ts 
s o l u t i o n.  The  predicate  DISTINCT(p.,p.,pk) 
means  no  two  pegs  are  equal. 

,p 
,move(d,p  ,p 
is 

, s ))  A  O N ( 4 ( d , y ) , p . , m o v e ( d , pi,p  P,s) 

the  discs  are 
(One  can 

, s ) )]  .  The  predicate 

it  w i ll  only  consider 

in  a  sense.  Such 

increasing  s i z e. 

true  if  and  only 

is  i n c o r r e c t .) 

legal  s t a t e s. 

in  a  quicker 

,p  )  3  0 N ( x ,p 

forces 

that 

is 

if 

1 

J 

The  clauses  generated  during  the  search  that 

are  concerned  w i th  i l l e g al  states  are  subsumea 
by  ~LEGAL  predicates  such  as  (Vs)~LEGAL(£(disc2  , 
( d i s c1, x ) ) ).  The  stacks  are  formed  by  placing 
If  the  new 
one  new  disc  on  top  of  a  legal  stack. 
top  disc 
top  disc  then  it 
is  of  course  smaller  than  a ll 
stack.  Thus  the  l e g al  stack  axioms  need  only  to 
specify  that 
second  disc  f or  a  stack  to  be  legal .  This  blocks 
the  construction  of 

is  smaller  than  the  old 

is  smaller  than  the 

the  others  on  the 

incorrect  stacks. 

the  top  disc 

-226-

One  complete  axiomatization  is  as  follows: 

the  disc  number 
that  repre(cid:173)

Instead  of  naming  each  disc, 

n  is  an  argument  of  the  function  d(n) 
sents  the  nth  d i s c.  This  representation  i l l u s(cid:173)
t r a t es  how  the  proof  procedure  can  be  shortened 
by  solving  frequent  decidable  subproblems  with 
special  available  tools—namely, 
the  LISP  pro(cid:173)
gramming  language.  The  theorem  prover  uses  LISP 
(the  "lessp"  function) 
to  evaluate  the  LESS(n,m) 
predicate—a  very  quick  step.  This  mechanism  has 
the  e f f e ct  of  generating,  wherever  needed,  such 
axioms  as  ~LESS(3,2)  or  LESS(2,3) 
against  or  subsume  l i t e r a ls 
in  generated  clauses. 
S i m i l a r l y,  LISP  evaluates  the  DISTINCT  predicate. 

to  resolve 

Note  that  the  move  axiom,  AX1,  breaks  up  i n to 

three  clauses,  each  clause  specifying  the  change 
in  the  task  f or  one  p a r t i c u l ar  peg.  The  process 
of  making  one  move  requires  nine  binary  resolutions, 
and  two  binary  factorings  of  clauses. 

S t i ll  other  solutions  are  possible  by  using 

term-matching  c a p a b i l i t i es 

special 
extend  the  u n i f i c a t i on  and  subsumption  algorithms 
to  include  l i st  terms,  set  terms,  and  c e r t a in 
types  of  symmetries. 

in  QA3 

that 

In  another  axiomatization, 

the  complete  con(cid:173)

the  puzzle  in  a  given  state  is 

in  state  s,  stack  x  in  on  peg1,  stack  y  is 

f i g u r a t i on  of 
specified  by  the  predicate  ON.  ON'  
that 
on  peg2,  and  stack  z  is  on  peg3.  Thus  if  the 
predicate 
holds,  the  stack"d1  -  d3  is  on  pegx  and  d3 
is  on 
peg3.  The  predicate  LEGAL  again  indicates  that 
a  given  stack  of  discs 

is  allowed. 

means 

In  t h is 

last-mentioned 

f o r m a l i z a t i o n,  using 

13  axioms  to  specify  the  problem,  QA3  easily  solved 
t h is  problem  f or  the  three-disc  puzzle.  During 
the  search  f or  a  proof,  98  clauses  were  generated 
buy  only  25  of  the  clauses  were  accepted.  Of  the 

-227-

if  a  s u f f i c i e n t ly  poor 

thus  passing  through  eight 
(counting  the  i n i t i al  and  f i n al  states)  . 

25,  12  were  not  in  the  proof.  The  s o l u t i on 
e n t a i ls  seven  moves, 
states 
The  12  clauses  not  in  the  proof  correspond  to 
searching  through  5  states  that  are  not  used  in 
the  s o l u t i o n.  Thus  the  s o l u t i on  is  found  rather 
e a s i l y.  Of  course, 
axiomatization  is  chosen—one  r e q u i r i ng  an  enumera(cid:173)
t i on  of  enough  correct  and 
the  system  becomes  saturated  and  f a i ls  to  obtain  a 
s o l u t i on  w i t h in  time  and  space  c o n s t r a i n t s.  An 
important 
elimination  of  extra  clauses  corresponding  to 
alternate  paths  that  reach  a  given  s t a t e. 
In 
the  above  problem  it  happens 
h e u r i s t ic 
clauses.  However, 
sumption  is  problem  dependent, 
examine  any  given  problem  formulation  to  deter(cid:173)
mine  whether  or  not  subsumption  w i ll  eliminate 
alternate  paths 

t h is  p a r t i c u l ar  use  of  sub(cid:173)
thus  one  must 

eliminates  73  of  these  redundant 

to  equivalent  s t a t e s. 

in  the  proof  search 

the  subsumption 

factor 

that 

the 

is 

incorrect  disc  positions— 

The  four-disc  version  of  the  puzzle  can  be 
much  more  d i f f i c u lt  than  the  three-disc  puzzle 
in  terms  of  search.  At  about  t h is 
d i f f i c u l ty  one  must  be  somewhat  more  careful  to 
obtain  a  low-cost  s o l u t i o n. 

level  of 

Ernst 

formalizes 

the  notion  of  " d i f f e r e n c e" 

used  by  GPS  and  shows  what  properties  these  d i f f e r(cid:173)
ences  must  possess  f or  GPS  to  succeed  on  a  problem. 
He  then  presents  a  "good"  set  of  differences  for 
the  Tower  of  Hanoi  problem.  U t i l i z i ng  t h is 
mation,  GPS  solves  the  problem  f or  four  discs, 
considering  no  incorrect  states  in  i ts  search. 
Thus  Ernst  has  chosen  a  set  of  differences  that 
guide  GPS  d i r e c t ly  to  the  s o l u t i o n. 

i n f o r(cid:173)

Another  method  of  s o l u t i on  is  possible. 

Save  the 

(using  the 

F i r s t,  solve  the  three-disc  puzzle. 
s o l u t i on  to  the  three-disc  puzzle 
answer  statement  ).  Then  ask  for  a  s o l u t i on  to 
the  f o u r - d i sc  puzzle.  The  s o l u t i on  then  i s: 
Move  the  top  three  discs  from  peg1  to  peg2  ,  m o ve 
disc4 
from  peg1  to  peg3  ;  move  the  three  discs  on 
peg2 
to  peg3  .  This  method  produces  a  much  easier 
s o l u t i o n.  But  t h is  can  be  considered  as  cheating, 
since  the  machine  is  "guided"  to  a  s o l u t i on  by 
being  t o ld  which  subproblem  to  f i r st  solve  and 
store  away.  The  use  of  the  differences  by  GPS 
s i m i l a r ly 
toward  a  s o l u t i o n. 

l e ts  the  problem  solver  be  "guided" 

There  is  another  possibly  more  desirable 

s o l u t i o n.  The  four-disc  puzzle  can  be  posed  as 
the  problem,  with  no  three-disc  s o l u t i o n. 
s o l u t i on  of 
the  search  f or  a  s o l u t i on  to  the  four-disc  puzzle, 
and 
as  a  lemma, 
f o l l ow  e a s i l y. 

is  automatically  recognized  and  saved 

then  the  four-disc  solution  should 

three-disc  puzzle  occurs  during 

If  the 

the 

if 

it 

F i n a l l y, 

if  an  induction  axiom  is  provided, 

imply  a  s o l u t i on  in  the  form  of  a 

the  axioms 
recursive  program  that  solves  the  puzzle  for  an 
a r b i t r a ry  number  of  d i s c s.  Aiko  Hormann 
d i s(cid:173)
cusses 
the  four-disc 
problem  by  the  program  GAKU  (not  an  automatic 

the  r e l a t ed  solutions  of 

theorem-proving  program).  The  solutions  by  lemma 
f i n d i n g, 
have  not  been  run  on  QA3. 

i n d u c t i o n,  and  search  guided  by  differences 

V.  Applications  to  the  Robot  Project 

A. 

I n t r o d u c t i on  to  Robot  Problem  Solving 

of 

R l. 

The 

f i r st  axiom  d e s c r i b es 

t he 

r o b o t: 

t he  move 

r o u t i n es 

In  t h is  section  we  discuss  how  theorem-proving 

I n s t i t u te  A r t i f i c i al 

t h is  section  describes  work 

methods  are  being  tested  f or  several  applications 
in  the  Stanford  Research 
I n t e l l i g e n ce  Group's  Automaton  ( r o b o t ).  We  empha(cid:173)
is  now 
size  that 
is  completed. 
in  progress,  r a t h er  than  work  t h at 
These  methods  represent  explorations 
in  problem 
s o l v i n g,  rather  than  f i n al  decisions  about  how 
the  robot  is  to  do  problem  s o l v i n g.  An  overview 
of 
project  is  provided  by  Nilsson 
veloped  an  E n g l i s h - t o - l o g ic  t r a n s l a t or  that 
part  of 

the  current  status  of  the  e n t i re  SRI  robot 

the  r o b o t. 

.  Coles 

has  de(cid:173)

that 

is 

information  storage  and  r e t r i e v al  system 

We  use  theorem-proving  methods  f or  three 
purposes,  the  simplest  being  the  use  of  QA3  as 
a  c e n t r al 
that 
the  system 
as  w e ll  as  the  human  users.  The  data  base  of  QA3 
is  thus  one  of  the  r o b o t 's  models  of 
including 

is  accessible  to  various  parts  of 

i ts  w o r l d, 

i t s e l f. 

A  second  use  is  as  an  experimental  t o ol  to 

found, 

implements 

f o r m u l a t i o n, 

t h is 
i n v o l v i ng  l i t t le  or  no  search. 

test  out  a  p a r t i c u l ar  problem  f o r m u l a t i o n.  When  a 
it  may  then  be 
s u i t a b le  formulation  is 
desirable  to  w r i te  a  f a s t er  or  more  e f f i c i e nt 
s p e c i f ic  program  that 
perhaps 
If  the 
special  program  is  not  as  general  as  the  axiom 
system  i s,  so  that 
in 
the  axioms  can  be  retained  to  be 
c e r t a in  cases, 
used  in  the  troublesome  cases.  Both  solutions  can 
be  made  available  by  s t o r i n g,  as  the  f i r st  axiom 
to  be  t r i e d,  a  special  axiom  t h at  describes  the 
special  s o l u t i o n.  The  predicate-evaluation  mech(cid:173)
anism  can  then  c a ll  LISP  to  run  the  special 
s o l u t i o n. 
be  used. 

the  special  program  f a i ls 

the  other  axioms  w i ll 

f a i l s, 

then 

If 

it 

The  t h i rd  use  is  as  a  r e a l - t i me  problem  s o l v e r. 

logic—clauses—are  the  basic  units  of 

In  the  implementation  we  are  now  using,  statements 
of 
informa(cid:173)
t i o n.  Statements  are  derived  from  several  sources: 
teletype  e n t r i e s,  axioms  stored  in  memory,  clauses 
or  statements  generated  by  the  theorem  prover, 
and  statements  evaluated  by  programs—subroutines 
in  LISP,  FORTRAN,  or  machine  language.  These 
programs  can  use  robot  sensors  and  sensory  data 
to  v e r i f y,  disprove,  or  generate  statements  of 
l o g i c. 

The  SRI  robot  is  a  cart  on  wheels,  having  a  TV 

camera  and  a  range-finder  mounted  on  the  c a r t. 
There  are  bumpers  on  the  c a r t,  but  no  arms  or  grasp(cid:173)
ing  agents,  so  the  only  way  the  robot  can  manipulate 
i ts  environment 
Given  t h is  rather  severe  r e s t r i c t i on  of  no  grasping, 
the  robot  must  be  clever  to  e f f e c t i v e ly  solve  prob(cid:173)
lems  i n v o l v i ng  modifying  i ts  w o r l d.  We  present 
below  some  axioms  f or  robot  problem  s o l v i n g. 

is  by  simple  pushing  a c t i o n s. 

-228-

T h is  axiom  says 
t h e re 
is  a  p a th 
a f t er  moving  a l o ng 
i n d i c a t es 
f r om  p l a ce  p1 
p a th  adequate 
terms 
r o b o t. 

to  p l a ce 
f or 

t h at 
to  p2, 

t he  r o b ot 

if 
t he  r o b ot  w i ll  be  at  p2 

is  at

 

and 

t he  p a t h. 

The  p r e d i c a te  PATH 

t h e re  e x i s ts  a  r o b o t - p a t h,  p a t hl 2, 

. 

A  r o b o t - p a th 

is  a 

t he  r o b o t 's  movement. 

a n d d e s c r i be 

t he  p o s i t i on  of 

The 
t he 

In  g e n e r a l, 

it  may  be  v e ry 

i n e f f i c i e nt 

to 
t he  p a t h12  such 

,p 

t he 

t h r o u gh  o b s t a c l es 

F or 

to 
is 

f i nd 
t r u e. 

f i nd  a  more 

S e v e r al  e x i s t(cid:173)

to  d e t e r m i ne  a  good  p a th 

t h e o r em  p r o v er 
, p a t hl 2) 

l a t er  a  case  where 
to 
l e ss  o b s c u re  p a t h s, 

l e v el  g r o u n d.  We  w i ll  show 
t h e o r em  p r o v er  may  be  used 
t he 

use 
t h at  PATH(p 
i ng  FORTRAN  s u b r o u t i n e s,  h a v i ng  s o p h i s t i c a t ed 
p r o b l e m - s o l v i ng  c a p a b i l i t i es  of 
t h e ir  own,  may 
be  used 
on 
t he 
o b s c u re  k i nd  of  p a t h. 
t he  axiom  Rl 
t he 
s e m a n t i cs  of 
t h at  new 
and  m e a n i n g f ul  programs  can  be  g e n e r a t ed  by  QA3 
by  u s i ng 
t he  e f f i c i e nt  p a t h - g e n e r a t i ng  programs 
as  s u b p r o g r a m s. 
mechanism 
is  used 
f i n d i ng  r o u t i n e s. 
mechanism 
of 
P2  such 
memory  and  a v a i l a b le 

The  " p r e d i c a t e - e v a l u a t i o n" 
to  c a ll 
The  e f f e ct  of 
t he 

t h at  p a t hl2  e x i s t s,  were  a ll  s t o r ed 
t h e o r em  p r o v e r. 

t h is  e v a l u a t i on 
f a m i ly  of  axioms 
f or  a ll  p1  and 
in 

is  m e r e ly  a  d e s c r i p t i on  of 
t h e se  FORTRAN  p r o g r a m s,  so 

t he  FORTRAN  p a t h-

t he  same  as 

f o rm  PATH  

t he 

t he 

to 

is 

if 

The  second  axiom 

is  a  push  axiom 

t he  e f f e ct  of  p u s h i ng  an  o b j e c t. 

t h at  d e(cid:173)
The 
j u st  a  bumper. 

I ts 

s c r i b es 
r o b ot  has  no  arm  or  g r a s p e r s, 
w o r ld  c o n s i s ts  of 
wedges,  c u b e s,  e t c. 
t he  same  s i ze  as 

t he  r o b ot 

l a r ge  o b j e c ts  such  as  b o x e s, 
These  o b j e c ts  a re  r o u g h ly 

i t s e l f. 

The  b a s ic  p r e d i c a te 

t h at  s p e c i f i es 

t he 

is  ATO,  meaning  a t - o b j e c t. 

p o s i t i on  of  an  o b j e ct 
The  p r e d i c a te 

'. 

At 

So 

is  at 

is 
t he 

" d e s c r i p t i o n ", 

in  p o s i t i on 
t i me  of 

The  s i m p l e st  d e s c r i p t i on 

t h at  o b j e c t1,  h a v i ng  s t r u c t u r al  d e s c r i p(cid:173)

" p o s i t i o n1', 
t h is  w r i t i n g,  a 
" s t a n d a r d"  s t r u c t u re  d e s c r i p(cid:173)
f ar  s e v e r al 

i n d i c a t es 
t i on 
in  s t a te  
p a r t i c u l ar  s et  of 
t i o ns  has  n ot  y et  been  s e l e c t e d. 
have  been  u s e d. 
p o i nt  whose  p o s i t i on 
of  g r a v i ty  of 
used 
f or 
r o u t i n e. 
w o r ld  a re  p o l y h e d r o n s, 
s t r u c t u r al  d e s c r i p t i o ns  a re  p o s s i b l e. 
one  s t r u c t u r al  d e s c r i p t i on  c o n s i s ts  of 
p o l y g o ns 
In 
t u rn 
t he  s et  of  v e r t i c es 
of  s t r u c t u r es  can  be  s t a t ed  e x p l i c i t ly  or  e l se 

is  a 
t he  e s t i m a t ed  c e n t er 
T h is  d e s c r i p t i on 
in  a  s t r a i g ht 

is 
l i n e" 
t he  r o b o t 's 

t h at 
t he  s t r u c t u re  of 

F or  example, 
t he  s et  of 
t he  p o l y h e d r o n. 
is  g i v en  by 
C o n n e c t i v i ty 

r e a s o n a b ly  s i m p le  c o m p l e te 

t he  FORTRAN  "push 

t he  s u r f a ce  of 

i ts  b o u n d a r y. 

t he  p o l y g o ns 

t he  o b j e c ts 

t he  o b j e c t. 

S i n ce  a ll 

f o rm 

in 

in 

implied  by  common  boundaries.  The  p o s i t i on  of  an 
object  is  given  by  a  mapping  of  the  t o p o l o g i c a l l y-
described  structure 
system.  Such  s t r u c t u r al  descriptions  may  be  given 
as  axioms  or  supplied  by  the  scene-analysis  pro(cid:173)
grams  used  by  the  robot. 

i n to  the  robot's  coordinate 

A  basic  axiom  describing  the  robot's  manipula(cid:173)

t i on  of  an  object 

is 

R2. 

( 

This  axiom  says  that 

if  object  1,  described 
is  at  p o s i t i on  1,  and  object  1 

by  d e s c r i p t i on  1, 
is  movable,  and  object  1  can  be  t h e o r e t i c a l ly 
r o t a t ed  and  translated  to  the  new  p o s i t i on  2,  and 
there  is  an  object-path  from  1  to  2,  then  object  1 
w i ll  be  at  p o s i t i on  2  as  a  r e s u lt  of  pushing  it 
along  the  path.  The  predicate 
ROTATE-TRANSLATABLE  (desc1  pos1  pos2)  checks  the 
necessary  condition  that  the  object  can  be  theo(cid:173)
r e t i c a l ly  rotated  and  translated  i n to  the  new 
p o s i t i o n.  The  predicate 
OBJECT-PATH(desc1,pos1,pos2,path12)  means 
pos2 
pushing  along  push-path, 

is  the  estimated  new  position  r e s u l t i ng  from 

that 

Let  us  now  r e t u rn  to  the  frame  problem.  More 
s p e c i f i c a l l y, 
in  a  state  r e s u l t i ng  from  pushing  an 
o b j e c t,  how  can  we  indicate  the  location  of  objects 
which  were  not  pushed?  One  such  axiom  is 

R3. 

for  handling  classes  of  deductions 

This  axiom  says  that  a ll  objects  that  are  not  the 
same  as  the  pushed  object  are  unmoved.  The  p r e d i(cid:173)
cate  evaluation  mechanism  is  used  to  evaluate  SAME 
and  speed  up  the  proof.  One  can  use  t h is  p r e d i(cid:173)
cate  evaluation  mechanism,  and  perhaps  other  fast 
methods 
(such 
as  special  representations  of  state-dependent 
information  and  special  programs  f or  updating  t h is 
information—which  is  done  in  the  robot)  ,  but 
another  problem  remains.  Observe  that  axiom  R3 
assumes  that  only  the  objects  d i r e c t ly  pushed  by 
the  robot  move.  This  is  not  always  the  case, 
since  an  object  being  pushed  might  accidentally 
s t r i ke  another  object  and  move  i t.  This 
leads 
to  the  question  of  dealing  with  the  r e al  world 
and  using  axioms  to  approximate  the  real  world. 

B. 

Real-World  Problem  Solving:  Feedback 

Our  descriptions  of  the  r e al  world,  axio(cid:173)
matic  or  otherwise,  are  at  best  only  approxima(cid:173)
t i o n s.  For  example, 
object  moved  by  the  robot  w i ll  not  necessarily  be 

the  new  p o s i t i on  of  an 

-229-

the  bumper  is  s t i ll 

feedback—namely, 
in  contact 

accurately  predicted,  even  if  one  goes  to  great 
extremes  to  calculate  a  predicted  new  p o s i t i o n. 
The  robot  does  not  have  a  grasp  on  the  object  so 
that  some  slippage  may  occur.  The  f l o or  surface 
is  not  uniform  and  smooth.  The  weight  d i s t r i b u(cid:173)
t i on  of  objects 
is  not  known.  There  is  only  r u d i(cid:173)
mentary  kinesthetic  sensing 
whether  or  not 
it  appears  that  a  large 
with  the  o b j e c t.  Thus 
feedback  loop  i t e r a t i ng  toward  a  s o l u t i o n, 
is 
necessary:  Form  a  plan  for  pushing  the  object 
(possibly  using  the  push  axiom),  push  according 
to  the  plan,  back  up, 
take  a  look,  see  where  the 
object 
p o s i t i o n,  s t a rt  over  again.  The  new  p o s i t i on  (to 
some  l e v el  of  accuracy) 
is  provided  by  the  sensors 
of  the  robot.  This  new  p o s i t i on  is  compared  to 
the  p o s i t i on  predicted  by  the  axiom. 
is  not  successful, 
sensors  in  the  new  state) 
r a t e ly  gives  the  o b j e c t 's  position 
in  the  new 
state  must  be  used  as  the  description  of  the 
i n i t i al  state 

i s,  compare  the  position  to  the  desired 

the  predicate  (provided  by 

for  the  next  attempt. 

that  reasonably  accu(cid:173)

If  the  move 

This  feedback  method  can  be  extended  to 
sequences  of  actions.  Consider  the  problem: 
Find  Sf  such 
s t a r t i ng  state  is  SQ,  with  property 
Suppose  the  axioms  are  as 
f o l l o w s: 

is  t r u e.  Suppose  the 

that 

The  sequence  of  actions 

forms  state  SO  with  property  PO(SO)  i n to  state 
having  property 

t r a n s(cid:173)

Corresponding  to  each  " t h e o r e t i c a l"  predicate 
is  a  corresponding  "real-word"  predicate 

The  t r u th  value  of  

is  determined  by 

i n t e r n al  model  of 

It  has  b u i l t - in  bounds  on  how  close  i ts 

sensors  and  the  robot's 
w o r l d. 
measurements  must  be  to  the  correct  values 
order  to  assert 
The  proof 
implies 
a f t er  each  step  of  execution  of 

f o l l o w i ng  d e s c r i p t i on  of 

the  r e s u lt 

that 

is 

t r u e .* 

the 

the 

in 

it 

At  t h is  time,  a  many-valued  logic  having 
degrees  of  t r u th  is  not  used,  although  t h is 
is  an  i n t e r e s t i ng  p o s s i b i l i t y. 

is 

that 

t r u e. 

If  not, 

the  itjh  step,  one 

To  measure  progress  a f t e r,  say, 
checks 
then  some 
other  condition  P\(si)  holds  and  a  new  problem 
generated,  given  
as  the  s t a r t i ng  p o i n t. 
new  information  is  present,  such  as  is  the  case 
in  i ts 
when  the  robot  h i ts  an  obstacle  that  is  not 
model, 
the  model  is  updated  before  a  new  s o l u t i on 
is  attempted.  The  p o s i t i on  of  t h is  new  object  of 
course  i n v a l i d a t es  the  previous  p l a n — i . e .,  had 
the  new  o b j e c t 's  p o s i t i on  been  known, 
plan  would  not  have  been  generated. 

the  previous 

is 
If 

The  new  s o l u t i on  may  s t i ll  be  able  to  use 

jth 

is  not 

i n v a l i(cid:173)

the  old  s o l u t i on  that 

if 
it  may  s t i ll  be  possible  to  reach 

holds, 
intermediate  state  and  then  continue  the 
jth  s t a t e. 
the  object-pushing  axiom  is  an  example 

that  part  of 
dated  by  any  new  i n f o r m a t i o n.  For  example, 
P"1 
the 
planned  sequence  of  actions  from  the 
However, 
of  an  axiom  that  probably  w i ll 
d i ct  r e s u l ts  and  yet  no  f u r t h er  information, 
except  f or  the  new  p o s i t i o n,  w i ll  be  a v a i l a b l e. 
For  t h is  case, 
is  probably  to 
i t e r a te  toward  the  target  s t a te  by  repeated  use 
of  the  push  axiom  to  generate  a  new  p l a n.  Hope(cid:173)
f u l l y, 

the  process  converges. 

the  best  approach 

i n c o r r e c t ly  p r e(cid:173)

For  a  given  axiomatization  feedback  does  not 

necessarily  make 
it  any  easier  to  f i nd  a  proof. 
However,  knowing  that  the  system  uses  feedback 
allows  us  to  choose  a  simpler  and  less  accurate 
axiom  system.  Simple  axiom  systems  can  then 
lead 

to  shorter  p r o o f s. 

One  can  envision  formalizing  t h is  e n t i re 

including  the  notion  of 

problem-solving  process, 
feedback,  v e r i f y i ng  whether  or  not  a  given  con(cid:173)
d i t i on  is  met,  updating  the  model,  recursively 
c a l l i ng  the  theorem  prover,  e t c.  The  author  has 
not  attempted  such  a  f o r m a l i z a t i o n,  although  he 
has  w r i t t en  a  f i r s t - o r d er  f o r m a l i z a t i on  of 
the 
theorem  prover's  own  problem-solving  s t r a t e g y. 
This  raises 
i n t e r e s t i ng  p o s s i b i l i ty  of 
s e l f - m o d i f i c a t i on  of  s t r a t e g y;  however, 
in  prac(cid:173)
t i ce  such  problems 
theorem-proving  capacity  of 

l ie  w e ll  beyond  the  current 

the  program. 

the  very 

C. 

A  Simple  Robot  Problem 

Now  l et  us  consider  a  problem  r e q u i r i ng  the 

use  of  a  ramp  to  r o ll  onto  a  p l a t f o r m,  as  i l l u s(cid:173)
t r a t ed  below. 

The  goal 

is 

to  push  the  box  b1  from  p o s i t i on 

to  x2  .  To  get  onto  the  p l a t f o r m, 
must  push  the  ramp 
r o ll  up  the  ramp  onto  the  p l a t f o r m. 

to  the  p l a t f o r m,  and  then 

the  robot 

A  simple  problem  formulation  can  use  a 

special  ramp-using  axiom  such  as 

R4. 

w i th  the  obvious  meaning.  Such  a  s o l u t i on  is 
quick  but 
g e n e r a l i t y. 

leaves  much  to  be  desired  in  terms  of 

A  more  general  problem  statement  is  one  in 

i ts  a b i l i t i es 

i n to  the  basic  terms 

It  then  learns  from  a  fundamental 

which  the  robot  has  a  d e s c r i p t i on  of  i ts  own 
c a p a b i l i t i e s,  and  a  t r a n s l a t i on  of  t h is  statement 
of 
scribe  i ts  sensory  and  human-given  model  of  the 
w o r l d. 
l e v el 
to  deal  with  the  w o r l d.  Such  a  knowledge  doesn't 
make  f or  the  quickest  s o l u t i on  to  a  f r e q u e n t l y-
encountered  problem,  but  c e r t a i n ly  does 
i t s e lf 
s o l v i n g,  and  s e l f - r e l i a n ce  in  a  new  problem 
s i t u a t i o n. 

l e a r n i n g,  greater  degrees  of  problem-

that  de(cid:173)

lend 

to 

Closer 

to 

t h is  extreme  of  greatest  g e n e r a l i ty 

the  f o l l o w i ng  axiomatization. 

is 

R5. 

This  axiom  says  that  r  describes  a  rectangle  hav(cid:173)
ing  ends  x1  a n d T he  maximum  slope 
than  a  constant  
the  r o b o t 's  width  w0  , 
r o b o t 's  height  hQ 
has  a  s o l id  surface. 

less 
is  greater 
the  space  above  r  to  the 
is  c l e a r,  and  the  rectangle  r 

the  width  

is 

r 

than 

Two  paths  can  be  joined  as  f o l l o w s: 

-230-

R6. 

From  these  two  axioms  (R5  and  R6)  ,  the  push 

axiom  (R2),  and  a  recognition  of  a  s o l id  object 
that  can  be  used  as  a  ramp,  a  solution  can  be 
obtained  in  terms  of  climb,  push, 
j o i n,  e t c.  This 
more  general  method  of  solution  would  of  course  be 
slower  than  using  the  special  ramp  axiom.  On  the 
other  hand, 
the  more  general  method  w i ll  probably 
be  more  useful 
if  the  robot  w i ll  be  required  to 
construct  a  ramp,  or  recognize  and  push  over  a 
p o t e n t i al  ramp  that  is  standing  on  i ts  wide  end. 

The  danger  in  t r y i ng  the  more  general  methods 
is  that  one  may  be  asking  the  theorem  prover  to  r e-
derive  some  s i g n i f i c a nt  portion  of  math  or  physics, 
in  order  to  solve  some  simple  problem. 

V I.  Automatic  Programming 

A. 

I n t r o d u c t i on 

The  automatic  w r i t i n g,  checking,  and  debug(cid:173)
ging  of  computer  programs  are  problems  of  great 
i n t e r e st  both  f or  t h e ir  independent  importance  and 
as  useful  t o o ls  f or  i n t e l l i g e nt  machines.  This 
section  shows  how  a  theorem  prover  can  be  used  to 
solve  c e r t a in  automatic  programming  problems.  The 
f o r m a l i z a t i on  given  here  w i ll  be  used  to  precisely 
state  and  solve  the  problem  of  automatic  generation 
of  programs, 
with  concurrent  generation  of  proofs  of  the  correct(cid:173)
ness  of  these  programs.  Thus  any  programs  auto(cid:173)
m a t i c a l ly  w r i t t en  by  t h is  method  have  no  e r r o r s. 

including  recursive  programs,  along 

functions  having  either 

the 
formalization—as 
value  NIL  (false)  or  else  a  value  not  equal 
to 
NIL  ( t r u e ).  The  semantics  are  given  by  axioms 
r e l a t i ng  LISP  functions 
(Vx,y)car(cons(x,y))  =  x,  where  cons(x,y) 
l i st  whose  f i r st  element 
is  y. 

to  l i st  s t r u c t u r e s,  e . g ., 
is  the 
is  x  and  whose  remainder 

In  our  formulation  of  programming  problems, 
we  emphasize  the  d i s t i n c t i on  between  the  program 
(represented  as  a  function  in  LISP), 
that  solves 
a  problem  and  a  test  for  the  v a l i d i ty  of  a  s o l u(cid:173)
t i on  to  a  problem  (represented  as  a  predicate  in 
l o g i c ). 
the 
predicate  than 
the  f u n c t i o n. 
Indeed,  one  may  say  that  a  problem  is  not  w e ll 
defined  u n t il  an  e f f e c t i ve  test 
i ts  s o l u t i on 
is  provided. 

is  often  much  easier  to  construct 

to  construct 

f or 

is 

It 

it 

For  example,  suppose  we  wish  to  w r i te  a  pro(cid:173)

gram  that  sorts  a  l i s t.  This  problem  is  not 
f u l ly  specified  u n t il 
the  meaning  of  " s o r t" 
explained;  and  the  method  of  explanation  we  choose 
is 
l i st  y  is  a  sorted  version  of 
otherwise. 
r e l a t i on  R  w i ll  be  given  l a t e r .) 

(The  precise  method  of  defining  t h is 

to  provide  a  predicate  R(x,y) 

true 
l i st  x  and  f a l se 

that 

is 

is 

if 

In  general,  our  approach  to  using  a  theorem 
in  LISP  r e(cid:173)

prover  to  solve  programming  problems 
quires  that  we  give  the  theorem  prover  two  sets  of 
i n i t i al  axioms  : 

(1)  Axioms  d e f i n i ng  the  functions  and  con(cid:173)

structs  of  the  subset  of  LISP  to  be  used 

We  s h a ll  take  LISP  "' 

as  our  example  of  a 

(1) 

(2) 

i ts  side  e f f e c t.  Side  effects  can 

In  the  LISP  language,  a 
i ts 

in  terms  of  t h e ir  effect  upon  the 
the  program.  Methods  f or  describing 

programming  language. 
f u n c t i on  is  described  by  two  e n t i t i e s: 
value,  and 
be  described 
state  of 
state-transformation  operations,  as  w e ll  as  meth(cid:173)
ods  f or  the  automatic  w r i t i ng  of  programs 
state-transformation  language,  were  presented  in 
Secs.  I  and  I I.  For  s i m p l i c i t y, 
we  s h a ll  discuss  "pure"  LISP,  in  which  a  LISP 
f u n c t i on  corresponds  to  the  standard  notion  of  a 
f u n c t i o n — i . e ., 

it  has  a  value  but  no  side  e f f e c t. 

in  t h is  section 

in  a 

to  a  l i st  returns 

the  f i r st 
if  the  variable  x  has 
then  car(x)  =  a.  The 

Thus  we  s h a ll  use  pure  LISP  1.5  without  the 
is  essentially  the  lambda 
In  t h is  r e s t r i c t ed  system,  a  LISP  pro(cid:173)
the  LISP 

program  f e a t u r e,  which 
calculus. 
gram  is  merely  a  f u n c t i o n.  For  example, 
f u n c t i on  car  applied 
element  of  the  l i s t.  Thus 
as  value  the  l i st  (a  b  c ), 
LISP  f u n c t i on  cdr  yields  the  remainder  of 
thus  CDR(x)  =  ( b e ),  and  car(cdr(x))  =  b.  There 
are  several  approaches  one  may  take  in  f o r m a l i z(cid:173)
ing  LISP;  the  one  given  here  is  a  simple  mapping 
from  LISP's 
lambda  calculus  to  the  predicate  c a l(cid:173)
culus.  LISP  programs  are  represented  by  functions. 
The  syntax  of  pure  LISP  1.5, 
composition,  and  the  corresponding  syntax  f or  the 
f o r m a l i z a t i on  is  also  function  composition. 
LISP 
in  t h is 
"predicates"  are  represented 

in  LISP—and 

is  normal 

the  l i s t, 

function 

-231-

(2)  Axioms  d e f i n i ng  an 

input-output  r e l a t i on 

such  as  the  r e l a t i on  R ( x , y ),  which  is  to  be  true 
if  and  only 
the  appropriate 
form  f or  some  LISP  program  and  y  is  the  corre(cid:173)
sponding  output  to  be  produced  by  such  a  program. 

input  of 

is  any 

if  x 

Given  t h is  r e l a t i on  R,  and  the  LISP  axioms, 
by  having  the  theorem  prover  prove  (or  disprove) 
the  appropriate  question  we  can  formulate  the 
following 
four  kinds  of  programming  problems: 
checking,  simulation,  v e r i f y i ng  (debugging),  and 
program  w r i t i n g.  These  problems  may  be  explained 
using  the  sort  program  as  an  example  as  follows: 

(1)  Checking:  The  form  of  the  question  is 

R(a,b)  where  a  and  b  are  two  given  l i s t s.  By 
proving  R(a,b) 
is  checked  to  be 
either  a  sorted  version  of  a_  or  n o t.  The  desired 
answer 

is  accordingly  e i t h er  yes  or  no. 

true  or  f a l s e,  

(2)  Simulation:  The  form  of  the  question  is 
(3x)R(a,x),  where  a  is  a  given  input 
If 
the  question 
then  a 
sorted  version  of  x  exists  and  a  sorted  version 
is  constructed  by  the  theorem  prover.  Thus  the 
theorem  prover  acts  as  a  sort  program. 
If  the 
then  it  has  proved  that  a  sorted 
answer  is  no, 
version  of  x  does  not  e x i st  (an  impossible  answer 
if  a  is  a  proper 

is  answered  yes, 

l i s t)  . 

l i s t. 

< 

The  form  of  the  question  is 

vhere  g(x) 

is  a  program  w r i t t en 

If 

t he  u s e r. 

T h is  mode 

t he  answer 

i n c o r r e c t. 
to 
t h en  g ( x)  s o r ts  e v e ry  p r o p er 

by 
is  known  as  v e r i f y i n g,  d e(cid:173)
b u g g i n g,  p r o v i ng  a  program  c o r r e c t,  or  p r o v i ng  a 
p r o g r am 
is  y e s, 
t he  program 
c o u n t e r e x a m p le 
s o r t,  must  be  c o n s t r u c t ed  by 
T h is  mode  r e q u i r es 
l o o p i ng  or 

t he  answer 
is  n o,  a 
t he  program  w i ll  n ot 
t h e o r em  p r o v e r. 

r e c u r s i ve  programs  c o n v e r g e. 

is  c o r r e c t. 
l i st  c, 

( V x ) R ( x , g ( x )) 
i n p ut 
l i st  and 

i n d u c t i on  axioms 

to  p r o ve 

If 
t h at 

t h at 

t he 

(4)  Program  W r i t i n g: 

In 

If 

( V x ) ( e y ) R ( x , y ). 
is 
c o n s t r u c t. 
say 
p r o p er 
a b le 
d u c e d. 
The 
o v e r s i m p l i f i ed 
f or 
f o rm  w i ll  be  shown 

f o rm  of 

i n p ut 

l i st 

l i s t s. 

If 
( i m p o s s i b l e, 
T h is  mode  a l so 

The 

f o rm  of 

t he  q u e s t i on 

is 

t h is  s y n t h e s is  mode 

t he  program 

to  be  c o n s t r u c t ed  or  e l se  proved 

t he  answer 

is  y e s, 

i m p o s s i b le 

to 
t h en  a  p r o g r a m, 

f ( x ),  must  be  c o n s t r u c t ed 

t h at  w i ll  s o rt  a ll 

is  n o,  an  u n s o r t-

t he  answer 
in 
r e q u i r es 

t h is  case)  must  be  p r o(cid:173)

i n d u c t i on  a x i o m s. 

t he  p r o b l em  s t a t e m e nt  shown  h e re 

is 

t he  sake  of  c l a r i t y. 
l a t e r. 

The  e x a ct 

In  a d d i t i on 

to 

t he  p o s s i b i l i ty  of 

" y e s"  answer 

t h e re 

" n o"  answer, 
"no  p r o of 

and 
t he 
if 
i ty  of  a 
h a l t ed  by  some 
t i me  or  space  bound. 
t i on  of  d i s j u n c t i ve  a n s w e r s,  w h i ch 
t h is  s e c t i o n,  was  e x p l a i n ed 

f o u n d"  answer 

is  always 

in  Sec.  B. 

t he  s e a r ch 

t he  p o s s i b i l(cid:173)
is 
The  e l i m i n a(cid:173)
in 

is  assumed 

These  methods  a re  summarized 

in 
r e a d er  may  v i ew  R ( x , y)  as 

t he 
f o l l o w i ng 
r e p r e s e n t i ng 

i n p u t - o u t p ut 

r e l a t i o n s h i p. 

t a b l e. 
some  g e n e r al  d e s i r ed 

The 

Programming 

Problem 

Form  of 
Q u e s t i on 

(1)  C h e c k i ng 
(2)  S i m u l a t i on 

R ( a , b) 

( ex ) R ( a , x) 

(3)  V e r i f y i ng 

( Vx) R ( x , g ( x )) 

(4)  Program 
W r i t i ng 

(Vx) 

E y ) R ( x , y) 

D e s i r ed 
Answer 

yes  or  no 
y e s,  x  =  b 
or  no 

yes 

or  n o,  x  =  c 
y e s,  y  - 
f ( x) 
or  n o,  x  =  c 

The  v a r i a b l es  x,  y,  and  z  a re  bound  by 

f r om  o t h e r s,  b ut  a re 

d e r i v a b le 
i t y. 
u n i v e r s al  q u a n t i f i e r s,  b ut 
o m i t t ed 
p o s s i b l e. 

t he  sake  of 
The 

f o r m u l a t i on 

f or 

t he  q u a n t i f i e rs  a re 

r e a d a b i l i ty  w h e r e v er 

is  g i v en  b e l o w: 

i n c l u d ed 

f or  c l a r(cid:173)

P r e d i c a t es 

Meaning 

NULL(x) 
L I S T ( x) 
ATOM(x) 
x  =  y 

l i st 

x  =  n il 
x 
is  a 
is  an  atom 
x 
x 
is  e q u al 

to  y 

F u n c t i o ns 

Meaning 

c a r ( x) 
c d r ( x) 
c o n s ( x , y) 

c o n d ( x , y , z) 

n il 

e q u a l ( x , y) 

atom(x) 

n u l l ( x) 

Axioms 

t he  v a l ue  of 
l i st 
t h at  has 

f i r st  element  and  y  as 

t he 

t he 

l i s t, 

l i st  x. 

r e st  of 

i n s t e ad  of  a 

l i st 
t h en 
is  a  new 

l i s t,  e . g ., 
( 12  3 ). 

f i r st  element  of 
The 
r e st  of 
The 
If  y 
is  a 
c o n s ( x , y) 
x  as 
i ts 
t he 
t he 
c o n s ( l , (2  3 ))  = 
an  atom 
c o n s ( x , y)  has  as  v a l ue  a 
p a i r ,"  e . g .,  c o n s ( l , 2)  = 
The  c o n d i t i o n al  s t a t e m e n t, 
n il 
s y n t ax  of 
d i f f e r e nt 
The  n u ll 
e l e m e n t s. 
E q u a l i ty 
if  x  does  n ot  e q u al  y. 
Atom 
t e s t,  whose  v a l ue 
x 
N u ll 

t h is 
t h an 
(empty) 

t e s t,  whose  v a l ue 

t e s t,  whose  v a l ue 

is  n ot  an  a t o m. 

t h en  y  e l se  z. 

is 

is 

x 

is  n ot  e q u al 

to  n i l. 

if  x  = 
t he 

Note 
f u n c t i on 
t he  u s u al  LISP  s y n t ax 

t h at 
is  s l i g h t ly 

l i st  c o n t a i n i ng  no 

l i st  x. 

If  y 

is 

" d o t t ed 
( 1 - 2 ). 

is 

" n i l" 

" n i l" 

if 

" n i l" 

if 

We  now  p r e s e nt  an  a x i o m a t i z a t i on  of  LISP 

f o l(cid:173)

two  a x i o m a t i z a t i o ns  of 

t he  s o rt 

r e l a t i on  R 

f or  a  s p e c i al  case  and  one  more  g e n e r a l ). 

lowed  by 
(one 

L I: 

x  =  c a r ( c o n s ( x , y )) 

L 2: 

y  =  c d r ( c o n s ( x , y )) 

B. 

A x i o m a t i z a t i on  of  a  Subset  of  LISP 

L3 :  ~ATOM(x)  =>  x  =  cons ( c ar (x)  , c d r ( x )) 

A ll  LISP 

f u n c t i o ns  and  p r e d i c a t es  w i ll  be 

f a l se  and  s o m e t h i ng  n ot  e q u al 

in  s m a ll 

l e t t e r s. 

" a t ( x ) ,"  and 

if 
" T ," 

w r i t t en 
" e q u a l ( x , y ) ," 
" n i l" 
say 
l o g ic 
in  c a p i t al 
v a l u e s. 

if 

t r u e. 

t h at  a re  used 
l e t t e r s. 

f u n c t i o ns 

The 
" n u l l ( x )"  e v a l u a te 

The  p r e d i c a t es  of 

to 
" n i l ," 
f i r s t - o r d er 
to  d e s c r i be  LISP  a re  w r i t t en 
T h e s e,  of  c o u r s e,  have 
t r u th 

to 

The  v e r s i on  of  LISP  d e s c r i b ed  h e re  does  n ot 

f o l l o w i ng 

There 
f o r m u l a t i o n, 

d i s t i n g u i sh  between  an  S - e x p r e s s i on  and  a  copy  of 
t h at  S - e x p r e s s i o n. 
t he 
t i o ns  and  p r e d i c a t es  c o u ld  have  been  d e f i n ed 
t e r ms  of  o t h e r s;  however, 
to  s t a te 
axioms  c o u ld  have  been  e l i m i n a t ed  s i n ce 

is  some  redundancy 
in 

t he  p r o b l em  more  c o n c i s e l y. 

A l s o,  some 
t h ev  a re 

t he  redundancy  a l l o ws  us 

in 
f u n c(cid:173)
in 

t h at  c e r t a in 

L 4: 

~ A T O M ( c o n s ( x , y )) 

L 5: 

ATOM(nil) 

L 6: 

x  =  n il  3  c o n d ( x , y , z)  =  z 

L 7: 

x  f  n il  3  c o n d ( x , y , z)  =  y 

L 8: 

x  =  y  =  e q u a l ( x , y)  #  n il 

L 9:  ATOM(x)  =  atom(x)  #  n il 

L 1 0:  NULL(x) 

-  n u l l ( x)  #  n il 

C. 

A  S i m p l i f i ed  S o rt  Problem 
B e f o re  e x a m i n i ng  a  more  g e n e r al  s o rt  p r o b l e m, 

c o n s i d er 

t he 

f o l l o w i ng  v e ry  s i m p le  s p e c i al  c a s e. 

- 2 3 2-

sort(x) 

A  LISP  sort  f u n c t i on  (to  be  con(cid:173)
structed)  g i v i ng  as 
i ts  value  a 
sorted  version  of  x. 

merge(x,u)  A  LISP  merge  f u n c t i on  merging  x 
l i st  u,  such  that 

l i st  returned  contains 

i n to  the  sorted 
the 
elements  of  u»  and  also  contains 
x,  and 

is  s o r t e d. 

t h is 

l i st 

the 

P(x,u,y) 

A  predicate  s t a t i ng  that  y 
r e s u lt  of  merging  x 
l i st  u. 

is  the 

i n to  the  sorted 

We  define  P ( x , u , y ), 
i t: 

i n to 

that  y  is  u  w i th  x  merged 

S4. 

implies 

if  and  only  if 

the  f a ct  t h at  u 
that  y  contains  x  in  addition  to 

Thus  P(x,u,y)  holds 
is  sorted 
the  elements  of  u,  and  y  is  s o r t e d.  One  such  merge 
f u n c t i on  is  merge(x,u)  =  c o n d ( n u l l ( u ) , c o n s ( x , u ), 
cond(lessp(x,car(u))(cons(x,u),cons(car(u),merge(x, 
c d r ( u ) ) ) ) ). 

name  of  the  f u n c t i on  to  be  w r i t t e n.  We  w i ll  now 
give  the  problem  statement 
f or  the  sort  program, 
introducing  appropriate 
where  necessary. 

induction  information 

F. 

The  Sort  Problem 

Examples 

i l l u s t r a t i ng  the  four  kipds  of  prob(cid:173)

lems  are  shown  below. 

(1)  Checking: 

A: 

yes 

(2)  Simulation: 

(3)  V e r i f y i n g:  Now  consider  the  v e r i f y i ng  or  de(cid:173)
bugging  problem.  Suppose  we  are  given  a  proposed 
d e f i n i t i on  of  a  sort  f u n c t i on  and  we  want  to  know 
if 
the  proposed  d e f i n i t i on 
is 

is  c o r r e c t. 

Suppose 

it 

The  axiom  required  to  describe  the  merge  func(cid:173)
is  : 

S6. 

t i on 
S5. 

This  completes  a  d e s c r i p t i on  of 

the  predicates 

ON,  SD,  R,  and  P.  Together, 
these  specify  the 
input-output  r e l a t i on  f or  a  sort  f u n c t i on  and  a 
merge  f u n c t i o n.  Before  posing  the  problems  to  the 
theorem  prover,  we  need  to  introduce  axioms  that 
describe 
the  convergence  of  recursive  f u n c t i o n s. 

E. 

Induction  Axioms 

In  order  to  prove  that  a  recursive  f u n c t i on 
the  theorem  prover 

converges  to  the  proper  value, 
requires  an  induction  axiom.  An  example  of  an 
induction  p r i n c i p le 
if  one  keeps  taking 
"cdr"  of  a  f i n i te  l i s t,  one  w i ll  reach  the  end  of 
the 
is 
analogous  to  an  induction  p r i n c i p le  on  the  non-
negative  i n t e g e r s, 
l et  " p"  be  a  predicate, 
and  " h"  a  f u n c t i o n.  Then  f or  f i n i te  l i s t s, 

in  a  f i n i te  number  of  steps.  This 

i . e ., 

that 

l i st 

is 

is  analogous 

to 

f or  nonnegative 

i n t e g e r s. 

There  are  other  kinds  of 

besides  the  one  given  above.  Unfortunately, 
each  recursive  f u n c t i on  that 
converge, 
the  appropriate  induction  axiom  must  be 
c a r e f u l ly  formulated  by  the  user.  The  induction 
axiom  also  serves  the  purpose  of  introducing  the 

to  be  shown  to 

is 

induction  c r i t e r ia 
f or 

is  defined 

Thus  sort 
in  terms  of  car,  cdr,  cond, 
n u l l,  merge,  and  s o r t.  Each  of  these  functions 
except  sort 
is  already  described  by  previously 
given  axioms.  We  also  need  the  appropriate  induc(cid:173)
t i on  axiom  in  terms  of  s o r t.  Of  course, 
t i c u l ar 
d e f i n i t i on  of 
For 
t h is  sort 
axiom  needed 

the  p a r t i c u l ar  sort 
f u n c t i on  the  p a r t i c u l ar 
is 

induction  axiom  needed  depends  on  the 

f u n c t i on  given. 

induction 

the  par(cid:173)

S7. 

The  f o l l o w i ng  conjecture  can  then  be  posed  to  the 
theorem  prover: 

A: 

yes 

(4)  Program  w r i t i n g:  The  next  problem  is  that  of 

in  a d d i t i on  to  i ts  primary  purpose  of  ask(cid:173)

that  no  d e f i n i t i on  such  as  S6  is  pro(cid:173)
information  needed  f or  t h is  par(cid:173)

synthesizing  or  w r i t i ng  a  sort  f u n c t i o n.  We  assume, 
of  course, 
vided.  Certain 
t i c u l ar  problem  might  be  considered  to  be  a  part  of 
t h is  p a r t i c u l ar  problem  statement  rather  than  a 
part  of  the  data  base.  We  s h a ll  phrase  the  question 
so  that 
ing  f or  a  s o l u t i o n, 
pieces  of  i n f o r m a t i o n: 
(a)  The  question  assigns  a 
name  to  the  f u n c t i on  t h at  is  to  be  constructed.  A 
recursive  f u n c t i on 
so  to  construct  t h is  d e f i n i t i on  the  name  of  the 
f u n c t i on  must  be  known  (or  else  created  i n t e r n a l l y ). 
(b)  The  question  specifies  the  number  of  arguments 
of 

the  question  provides  three  more 

is  to  be  considered. 

the  function  t h at 

in  terms  of 

is  defined 

i t s e l f, 

-234-

(c)  The  question  (rather  than  an  induction  axiom) 
gives  the  p a r t i c u l ar  inductive  hypothesis  to  be 
used 

in  constructing  the  f u n c t i o n. 

In  t h is  formi 

the  question  and  answer  are 

Thus  the  question  names  the  function  to  be  " s o r t" 
and  specifies  that  it 
ment .  The  question  gives  the  inductive  hypothesis— 
that  the  function  sorts  cdr(x)—and  then  asks  for 
a  function  that  sorts  x.  When  the  answer  y  is 
y  is  labeled  to  be  the  function  sort(x)  . 
found 

is  a  function  of  one  argu(cid:173)

Using  t h is  formulation  QA3  was  unable  to  w r i te 

the  sort  program  in  a  reasonable  amount  of  time, 
although  the  author  did  f i nd  a  correct  proof  w i t h in 
the  resolution  formalism*.  The  creation  of  the 
merge  function  can  also  be  posed  to  the  theorem 
prover  by  the  same  methods. 

G. 

Discussion  of  Automatic  Programming  Problems 

The  axioms  and  conjectures  given  here  i l l u s(cid:173)
ideas  of  automatic  program(cid:173)
t h is  work  as  well  as  e a r l i er  work 

t r a te  the  fundamental 
ming.  However, 

and  others  pro(cid:173)
vides  merely  a  small  part  of  what  needs  to  be  done. 
Below  we  present  discussion  of  issues  that  might 
p r o f it 

i n v e s t i g a t i o n. 

from  f r u t h er 

Loops.  One  obvious  extension  of  t h is  method 
is  to  create  programs  that  have  loops  rather  than 
recursion.  A  simple  technique  exists  for  carrying 
out  t h is  operation.  F i r s t,  one  writes  j u st  recurs(cid:173)
ive  f u n c t i o n s.  Many  recursive  functions  can  then 
be  converted  i n to  i t e r a t i o n — i . e ., 
faster-running 
loops  that  do  not  use  a  stack.  McCarthy30  gives 
c r i t e r ia  that  determine  how  to  convert  recursion 
i t e r a t i o n.  An  algorithm  for  determining  cases 
in 
which  recursion  can  be  converted  to  i t e r a t i o n,  and 
then  performing  the  conversion  process 
is  embedded 
in  modern  LISP  compilers.  This  algorithm  could  be 
applied  to  recursive  functions  w r i t t en  by  the 
theorem-proving  program. 

to 

Let 
I n f o r(cid:173)

Separation  of  Aspects  of  Problem  Solving. 

(1) 

us  divide  information  i n to  three  types: 
mation  concerning  the  problem  description  and 
semantics.  An  example  of  such  information  is  given 
in  the  axiom  
sorted 
l i s t. 
programming  language,  such  as  the  axiom 
cond(x,y,z)  =  z ]. 
i n t e r r e l a t i on  of  the  problem  and  the  target 
guage,  such  as  [LESS(x,y)  = 

or  axiom  SI  that  defines  a 
Information  concerning  the  target 

Information  concerning  the 
l a n(cid:173)

lessp(x,y) 

(2) 

(3) 

A f t er  t h is  paper  was  w r i t t en  the  problem  was  r e(cid:173)
formulated  using  a  d i f f e r e nt  set  of  axioms. 
In 
the  new  formulation  QA3  created  the  sort  program 
"sort(x)  =  c o n d ( x , m e r g e ( c a r ( x ) , s o r t ( c d r ( x ) ) ) , n i l ). 

These  kinds  of  information  are  not,  of  course, 
mutually  exclusive. 

In  the  axiom  systems  presented,  no  d i s t i n c t i on 

information  of  type  2.  Such 

is  made  between  such  classes  of  information.  Con(cid:173)
sequently,  during  the  search  f or  a  proof  the  theorem 
prover  might  attempt  to  use  axioms  of  type  1 
for  pur(cid:173)
poses  where  it  needs 
attempts  lead  nowhere  and  generate  useless  clauses. 
However,  as  discussed  in  S e c . I I - G,  we  can  place  in 
the  proof  strategy  our  knowledge  of  when  such 
mation  is  to  be  used, 
proofs.  One  such  method—calling  f or  the  conditional 
axioms  at  the  r i g ht  time,  as  discussed  in  Sec.  I I - G— 
has  been  implemented  in  QA3. 

i n f o r(cid:173)
leading  to  more  e f f i c i e nt 

thus 

The  PROW  program  of  Waldinger  and  Lee6  provides 

In  t h e ir  system, 

information  about 

a  very  promising  method  of  separating  the  problem 
of  proof  construction  from  the  problem  of  program 
construction. 
the  only  axioms 
used  are  those  that  describe  the  s u b j e c t — i . e ., 
state  the  problem.  Their  proof  that  a  solution 
exists  does  not  d i r e c t ly  construct  the  program. 
Instead, 
language,  as  well  as  information  about  the  r e l a t i o n(cid:173)
ship  of  the  target-programming  language  to  the 
problem-statement 
the  PROW  program—the  "post-processor."  The  post(cid:173)
processor  then  uses  t h is 
the  completed  proof  i n to  a  program.  The  post(cid:173)
processor  also  converts  recursion  into  loops  and 
allows  several  target  programming  languages. 

the  target  programming 

information  to  convert 

in  another  part  of 

language, 

is 

If  our  goal 

is 

to  do  automatic  programming 

information  in 

the  problem-statement 

involving  complex  programs,  we  w i ll  probably  wish 
to  do  some  optimization  or  problem  solving  on  the 
target  language  i t s e l f.  For  t h is  reason  we  might 
want  to  have  axioms  that  give  the  semantics  of  the 
target  language,  and  also  allow  the  intercommunica(cid:173)
t i on  of 
guage  with  information  in  the  target 
Two  p o s s i b i l i t i es  for  how  to  do  t h is  e f f i c i e n t ly 
suggest  themselves: 
here  in  which  a ll 
in  f i r s t - o r d er 
l o g i c.  To  gain  e f f i c i e n c y,  use  special  problem-
i n t e r(cid:173)
solving  strategies 
a c t i o n; 
in 
which  the  program  construction  is  separated  from 
the  proof  construction,  possibly  by  being  at 
another  l e v e l.  The  program  construction  process 
might  then  be  described  in  terms  of  the  f i r s t-
order  existence  proof. 

that  minimize  unnecessary 
(b)  Use  a  higher-order  logic  system, 

(a)  Use  the  methods  presented 

information  is 

language. 

lan(cid:173)

Problem  Formulation.  The  axiomatization  given 
here  has  considerable  room  f or  improvement:  Missing 
portions  of  LISP  include  the  program  features  and 
the  use  of 
to  be  w r i t t en  must  be  named  by  the  user,  and  the 
number  of  arguments  must  also  be  specified  by  the 
user. 

lambda  to  bind  variables.  The  functions 

Heuristics  f or  Program-Writing  Problems.  Two 
h e u r i s t i cs  have  been  considered  so  f a r.  The  f i r st 
consists  of  examining  the  program  as  it 
structed  (by  looking  inside  the  answer  l i t e r a l ). 
Even  though  the  syntax  is  guaranteed  correct, 
answer 
undefined  constructions  (such  as  c a r ( n i l ) ).  Any 

l i t e r al  may  contain  various  nonsense  or 

is  con(cid:173)

the 

-23b-

is  to  a c t u a l ly 

clause  containing  such  constructed  answers  should 
be  e l i m i n a t e d.  Another  h e u r i s t ic 
run  the  p a r t i al  program  by  a  pseudo-LISP  i n t e r(cid:173)
preter  on  a  sample  problem.  The  theorem  prover 
knows  the  correct  performance  on  these  sample 
problems  because  they  have  e i t h er  been  solutions 
or  else  counterexamples 
questions  that  were  stored 
have  been  provided  by  the  user. 
LISP  i n t e r p r e t er  can  produce  a  p a r t i al  output  that 
is  i n c o r r e c t, 
If  done  properly,  such  a  method  might  be  valuable, 
but 
not  yet  c l e a r. 

in  memory,  or  else  they 

to  program-simulation 

the  p a r t i al  program  can  be  eliminated. 

l i m i t ed  experience, 

i ts  usefulness 

If  the  pseudo-

in  our 

is 

Higher-Level  Programming  Concepts.  A 

is 

f or  p r a c t i c al  program  w r i t(cid:173)

necessary  requirement 
ing 
(such  as  the  LISP  "map"  function) 
the  use  of  frequently  employed  constructs 
tions)  or  p a r t i al  constructs. 

the  development  of  h i g h e r - l e v el  concepts 
that  describe 
(func(cid:173)

I n d u c t i o n.  The  various  methods  of  proof  by 

induction  should  be  studied  f u r t h er  and  r e l a t ed 
to  the  kinds  of  problems 
The  automatic  selection  or  generation  of  appro(cid:173)
p r i a te  induction  axioms  would  be  most  h e l p f u l. 

in  which  they  are  u s e f u l. 

f or  the  subfunctions 

Program  Segmentation.  Another  i n t e r e s t i ng 
that  of  automatically  generating  the 
to  be  called 

problem  is 
s p e c i f i c a t i o ns 
before  w r i t i ng  these  f u n c t i o n s.  For  example, 
in  our  system, 
the  sort  problem  was  divided  i n to 
two  problems:  F i r s t,  specify  and  create  a  merge 
f u n c t i o n,  next  specify  a  sort  function  and  then 
construct 
f u n c t i o n.  The  segmentation  i n to  two  problems  and 
the  s p e c i f i c a t i on  of  each  problem  was  provided  by 
the  user. 

function  in  terms  of  the  merge 

t h is 

V II  .  Discussion 

The  theorem  prover  may  be  considered  an 
" i n t e r p r e t e r"  f or  a  h i g h - l e v el  assertional  or 
declarative  language—logic.  As 
most  h i g h - l e v el  programming  languages  the  user  may 
be  somewhat  d i s t a nt 
from  the  e f f i c i e n cy  of  " l o g i c" 
programs  unless  he  knows  something  about  the 
strategies  of 

in  the  case  w i th 

the  system. 

The  f i r st  applications  of  QA2  and  QA3  were 

to  "question  answering."  Typical  question-
answering  applications  are  usually  easy  f or  a 
r e s o l u t i o n - t y pe  theorem  prover.  Examples  of 
such  easy  problem  sets  given  QA3  include  the 
questions  done  by  Raphael's  SIR21  Slagle's 
DEDUCOMV  and  Cooper's  chemistry  question-
answering  program. 
obvious  formulations  f or  some  subject  area,  and 
any  reasonable  formulation  works  w e l l.  As  one 
goes 
l i ke  the  Tower  of  Hanoi 
puzzle,  and  program-writing  problems,  good  and 
reasonably  well-thought-out  representations  are 
necessary 

f or  e f f i c i e nt  problem  s o l v i n g. 

Usually  there  are  a  few 

to  harder  problems 

it 

I  don't  believe  these  goals 

a  given  problem  and  representation,  or  even  change 
the  representation. 
are  impossible,  but  at  present 
is  not  done. 
However,  a  l i b r a ry  of  strategy  programs  and  a 
strategy  language  is  slowly  evolving  in  QA3.  To 
change  strategies 
in  the  present  version  the  user 
must  know  about  set-of-support  and  other  program 
parameters  such  as  l e v el  bound  and  term-depth 
bound.  To  r a d i c a l ly  change  the  strategy, 
presently  has  to  know  the  LISP  language  and  must 
be  able  to  modify  c e r t a in  strategy  sections  of 
the  program. 
i n d i v i d u a ls 
who  have  used  the  system  have  modified  the  search 
strategies  to  s u it  t h e ir  needs.  To  add  and  debug 
a  new  h e u r i s t ic  or  to  modify  a  search  strategy 
where  reprogramming  is  required  seems  to  take  from 
a  few  minutes  to  several  days,  perhaps  averaging 
one  day.  Ultimately 
w i ll  be  able  to  w r i te  simple  strategy  programs 
i t s e l f,  and  "understand"  the  semantics  of 
i ts 
s t r a t e g i e s. 

In  p r a c t i c e,  several 

intended  that  the  system 

the  user 

is 

it 

Experience  w i th  the  robot  applications  and 

the  automatic  programming  applications  emphasize 
the  need  f or  a  very  v e r s a t i le  l o g i c al  system.  A 
suitable  higher-order  l o g ic  system  seems 
to  be  one 
of  the  best  candidates.  Several  recent  papers  are 
relevant  to  t h is  t o p i c.  A  promising  higher  order 
system  has  been  proposed  by  Robinson. 
Banerji 
discusses  a  higher  order  language.  One  c r u c i al 
factor 
f or  the  treatment  of 
cussion  of  methods 
is  provided  by  Wos  and  Robinson, 
and  Wos, 
include  a  discussion  of  modal 

the  equality  r e l a t i o n.  Dis(cid:173)
f or  the  treatment  of  equality 
and  Robinson 
and  Kowalski.  McCarthy  and  Hayes° 

in  an  inference  system  is  a  suitable  method 

l o g i c s. 

The  theorem-proving  program  can  be  used  as  an 

t o ol 

I  believe  that 

In  exploring  d i f f i c u lt  problems 

in  the  t e s t i ng  of  problem  formu(cid:173)

experimental 
l a t i o n s. 
it  can 
be  useful  to  w r i te  a  computer  program  to  t e st  a 
problem  formulation  and  s o l u t i on  technique,  since 
the  machine  tends  to  sharpen  one's  understanding 
of  the  problem. 
in  some  problem-
solving  applications  the  " h i g h - l e v el 
language"  of 
l o g ic  along  with  a  theorem-proving  program  can  be 
a  quick  programming  method  f or  t e s t i ng  ideas.  One 
reason  is  that  a  representation  in  the  form  of  an 
axiom  system  can  correspond  q u i te  closely  to  one's 
conceptualization  of  a  problem.  Another  reason  is 
that 
is  sometimes  easier  to  reformulate  an 
axiom  system  rather  than  to  r e w r i te  a  problem-
solving  program,  and  t h is  ease  of  reformulation 
f a c i l i t a t es  e x p l o r a t i o n. 

it 

Resolution  theorem-proving  methods  are  shown 

in  t h is  paper  to  have  the  p o t e n t i al 
a  general  problem-solving  system.  A  modified  theorem-
proving  program  can  w r i te  simple  robot  problems,  and 
solve  simple  puzzles.  Much  work  remains  to  be  done 
before  such  a  system  is  capable  of  solving  problems 
that  are  d i f f i c u lt  by  human  standards. 

to  serve  as 

Acknowledgment 

Some  representations  are  better  than  others 

the  p a r t i c u l ar  strategy  used  to 

only  because  of 
search  f or  a  proof. 
theorem  prover  could  adopt 

It  would  be  desirable  if  the 
the  best  strategy  f or 

I  would 

l i ke  to  acknowledge  valuable  d i s(cid:173)

cussions  w i th  Dr.  Bertram  Raphael  and  Mr.  Robert 
Yates. 

-236 

REFERENCES 

1. 

J.  A.  Robinson,  "The  Present  State  of  Mechan(cid:173)
i c al  Theorem  Proving,"  a  paper  presented  at 
the  Fourth  Systems  Symposium,  Cleveland,  Ohio, 
November  19-20,  1968  (proceedings  to  be  pub(cid:173)
l i s h e d ). 

2.  C.  Green  and  B.  Raphael,  "The  Use  of  Theorem-

Proving  Techniques 
Systems,"  Proc.  23rd  N a t ' l.  Conf.  ACM, 
(Thompson  Book  Company,  Washington,  D.C., 
1968). 

in  Question-Answering 

3.  C.  Green,  "Theorem  Proving  by  Resolution  as  a 

f or  Question-Answering  Systems," 

Basis 
Machine  I n t e l l i g e n ce  4,  D.  Michie  and  B. 
Meltzer,  Eds. 
Edinburgh,  Scotland,  1969). 

(Edinburgh  University  Press, 

4.  N.  J.  Nilsson,  "A  Mobile  Automaton:  An  A p p l i(cid:173)
Intelligence  Techniques," 

cation  of  A r t i f i c i al 
a  paper  presented  at  the 
Conference  on  A r t i f i c i al 
Washington,  D.C.,  May  7-9,  1969  (proceedings 
to  be  published). 

International  Joint 
I n t e l l i g e n c e, 

5. 

from 

J.  McCarthy  and  P.  Hayes,  "Some  Philosophical 
Problems 
the  Standpoint  of  A r t i f i c i al 
I n t e l l i g e n c e ,"  Machine  Intelligence  4,  D. 
Michie  and  B.  Meltzer,  Eds.  (Edinburgh  Univer(cid:173)
s i ty  Press,  Edinburgh,  Scotland,  1969). 

6.  R.  J.  Waldinger  and  R.  C.  T.  Lee,  "PROW:  A 

Step  Toward  Automatic  Program  W r i t i n g ,"  a 
paper  presented  at 
International  Joint 
Conference  on  A r t i f i c i al 
I n t e l l i g e n c e,  Wash(cid:173)
ington,  D.C.,  May  7-9,  1969  (proceedings  to 
be  published). 

the 

7. 

8. 

L.  Wos,  G.  A.  Robinson,  and  D.  F.  Carson, 
"Efficiency  and  Completeness  of 
the  Set  of 
Support  Strategy  in  Theorem  Proving,"  J.ACM, 
V o l.  12,  No.  4,  pp.  536-541  (October  1965). 

J.  A.  Robinson,  "A  Machine-Oriented  Logic 
Based  on  the  Resolution  P r i n c i p l e ,"  J.ACM, 
V o l.  12,  No.  1,  pp.  23-41  (January  1965). 

9.  George  Ernst, 

" S u f f i c i e nt  Conditions 

f or  the 

Success  of  GPS,"  Report  No.  SRC-68-17,  Systems 
Research  Center,  Case  Western  Reserve  Univer(cid:173)
s i t y,  Celveland,  Ohio  (July  1968). 

10.  A.  Hormann,  "How  a  Computer  System  Can  Learn," 

IEEE  Spectrum  (July  1964). 

1 1.  L.  S.  Coles,  "Talking  With  a  Robot  in  E n g l i s h ," 

paper  submitted  at  the 
Conference  on  A r t i f i c i al 
ington,  D.C.,  May  7-9,  1969  (proceedings  to  be 
published). 

I n t e l l i g e n c e,  Wash(cid:173)

International  Joint 

12.  John  McCarthy,  Paul  W.  Abrahams,  Daniel  J. 

Edwards,  Timothy  P.  Hart,  and  Michael 
Levin,  LISP  1.5  Programmer's  Manual  (The  MIT 
Press,  Cambridge,  Mass.,  1962). 

I. 

13.  C.  Weissman,  LISP  1.5  Primer  (Dickenson  Pub(cid:173)

l i s h i ng  Company, 

I n c .,  Belmont,  C a l i f .,  1967). 

14.  Lawrence  Wos  and  George  Robinson,  "Paramodu-
l a t i on  and  Set  of  Support,"  summary  of  paper 
presented  at  the  IRIA  Symposium  on  Automatic 
Demonstration  at  V e r s a i l l e s,  France,  December 
16-21,  1968  (proceedings  to  be  published). 

15.  G.  Robinson  and  L.  Wos,  "Paramodulation  and 
Theorem-Proving 
in  First-Order  Theories  with 
E q u a l i t y ,"  Machine  I n t e l l i g e n ce  4,  B.  Meltzer 
and  D.  Michie,  Eds.  (Edinburgh  University 
Press,  Edinburgh,  Scotland,  1969). 

16.  H.  Simon,  "Experiments  with  a  Heuristic  Com(cid:173)
p i l e r ,"  J.ACM,  V o l.  10,  pp.  493-506  (October 
1963). 

17.  J.  R.  Slagle,  "Experiments  with  a  Deductive, 

Question-Answering  Program,"  Comm.  ACM, 
V o l.  8,  pp.  792-798  (December  1965). 

18.  R.  W.  Floyd,  "The  V e r i f y i ng  Compiler," 

Computer  Science  Research  Review,  Carnegie 
Mellon  University  (December  1967). 

19. 

20. 

z.  Manna,  "The  Correctness  of  Programs," 
J.  Computer  and  Systems  Sciences,  V o l.  3 
(1969). 

J.  McCarthy,  "Towards  a  Mathematical  Science 
of  Computation,"  Proceedings 
Holland  Publishing  Company,  Amsterdam, 
1962). 

ICIP  (North 

2 1.  B.  Raphael,  "A  Computer  Program  Which  'Under(cid:173)

s t a n d s ' ,"  Proc.  FJCC,  pp.  577-589  (1964). 

22.  W.  S.  Cooper,  "Fact  Retrieval  and  Deductive 

Question  Answering  Information  Retrieval 
Systems,"  J.ACM,  V o l.  1 1,  pp.  117-137  ( A p r il 
1964). 

23. 

J.  A.  Robinson,  "Mechanizing  Higher  Order 
L o g i c ,"  Machine  I n t e l l i g e n ce  4,  D.  Michie  and 
B.  Meltzer,  Eds. 
(Edinburgh  University  Press, 
Edinburgh,  Scotland,  1969). 

24.  R.  B.  B a n e r j i,  "A  Language  for  Pattern  Recog(cid:173)
n i t i o n ,"  Pattern  Recognition,  V o l.  1,  No.  1, 
pp.  63-74  (1968). 

25.  R.  Kowalski,  "The  Case  for  Using  Equality 
Axioms  in  Automatic  Demonstration,"  paper 
presented  at  the  IRIA  Symposium  on  Automatic 
Demonstration  at  V e r s a i l l e s,  France,  December 
16-21,  1968  (proceedings  to  be  published)  . 

-237-

The  axioms 
SK24(S,P2,P1,B) 
e l i m i n a t i on  of 
it  as 

t he  o b j e ct 

f or 
t h at 

(Vx) 

t he  Monkey  and  Bananas  p r o b l em  a re 

l i s t ed  b e l o w, 

f o l l o w ed  by 

t he  p r o o f. 

The 

t e rm 

f i r st  appears 

in  c l a u se  16  of 
t he  c o n v e r s i on  of  axiom  MB4 

in 

t he  p r o of 
to  q u a n t i f i e r - f r ee  c l a u se 

is  a  Skolem 

f u n c t i on  g e n e r a t ed  by 

t he 

f o r m. 

(One  may 

t h i nk  of 

t h at 

is  not  at  p l a ce  P2 

in  s t a te  S.) 

APPENDIX 

LIST  MONKEY 
MB1 

(MOVABLE  BOX) 
(FA(X)(NOT(AT  X  UNDER-BANANAS  S 0 ) )) 
(AT  BOX  PLACEB  30) 
(FA(B  PI  P2  S)(IF(AND(AT  B  PI  S)  (MOVABLE  B)  (FA(X)  (NOT(AT  X  P2  S ) ) ) ) ( A N D ( AT  MONKEY  P2 
(MOVE(MONKEY  B  P2  S ) ) ( AT  B  P2(MOVE  MONKEY  B 
(FA(S)(CLIMBABLE  MONKEY  BOX  S)) 
(FA(M  P  B  S)(IF(AND(AT  B  P  S)(CLIMBABLE  M  B  S))(AND(AT  B  P(CLIMB  M  B  S ) ) ( ON  M  B 
(CLIN©  M  B 
(FA(S)(IF(AND(AT  BOX  UNDER-BANANAS  S)(ON  MONKEY  BOX  S))(REACHABLE  MONKEY  BANANAS 
(FA(M  B  S)(IF(REACHABLE  M  B  S)(HAS  M  B(REACH  M  B 

(EX(S)(HAS  MONKEY  BANANAS  S)) 
YES,  S  =  REACH(MONKEY,BANANAS,CLIMB(MONKEY,BOX,MOVE(MONKEY,BOX,UNDER-BANANAS,S0))) 

PROOF 

1 
2 
3 
4 

5 
6 

7 
8 

9 
10 

-AT(X,UNDER-BANANAS,S0) 
AT(BOX,PLACEB,S0) 
CLIMBABLE(MONKEY,BOX,S) 
-HAS(MONKEY,BANANAS,S) 

ANSWER(S) 

HAS(M,B,REACH(M,B,S)) 
-REACHABLE(MONKEY,BANANAS,S) 

-REACHABLE(M,B,S) 

ANSWER(REACH(MONKEY,BANANAS,S)) 

REACHABLE(MONKEY,BANANAS,S) 
-AT(BOX,UNDER-BANANAS,S) 

-ON(MONKEY,BOX,S) 

-AT(BOX,UNDER-BANANAS,S) 

-ON(MONKEY,BOX,S) 

ANSWER(REACH(MONKEY,BANANAS,S)) 

ON(M,B,CLIMB(M,B,S)) 
-AT(BOX,UNDER-BANANAS,CLIMB(MONKEY,BOX,S)) 

- A T ( B , P , S) 

-CLIMBABLE(M,B,S) 

-AT(BOX,P,S) 

-CLIMBABLE(MONKEY,BOX,S) 

ANSWER(REACH(MONKEY,BANANAS,CLIMB(MONKEY,BOX,S))) 

11 

-AT(BOX,UNDER-BANANAS,CLIMB(MONKEY,BOX,S)) 

-AT(BOX,P,S) 

ANSWER(REACH(MONKEY,BANANAS,CLIMB(MONKEY,BOX,S))) 

12 
13 

A T ( B , P , C L I M B ( M , B , S )) 
-AT(BOX,XXI,S) 

- A T ( B , P , S) 

-CLIMBABLE(M,B,S) 

-AT(BOX,UNDER-BANANAS,S) 

-CLIMBABLE(MONKEY,BOX,S) 

ANSWER(REACH(MONKEY,BANANAS,CLIMB(MONKEY,BOX,S))) 

14 

-AT(BOX,XXI,S) 

-AT(BOX,UNDER-BANANAS,S) 

ANSWER(REACH(MONKEY,BANANAS,CLIMB(MONKEY,BOX,S))) 

15 

-AT(BOX,UNDER-BANANAS,X) 

ANSWER(REACH(MONKEY,BANANAS,CLIMB(MONKEY,BOX,S))) 
- A T ( B , P 1 , S) 

AT(B,P2,MOVE(MONKEY,B,P2,S)) 

-MOVABLE(B) 

16 

A T ( S K 2 4 ( S , P 2 , P 1 , B ) , P 2 , S) 

- 2 3 8-

17 

-MOVABLE(BOX) 

-AT(BOX,Pl,S) 

AT(SK24(S,UNDER-BANANAS,PI,BOX),UNDER-BANANAS,S) 

FROM  1 5 , 16 

ANSWER (REACH (MONKEY, BANANAS ,CLIMB (MONKEY, BOX, MOVE (MONKEY, BOX , UNDER-BANANAS , S) )) ) 

18 

-MOVABLE(BOX)  AT (SK2 4 (S0, UNDER-BANANAS ,PLACEB, BOX)  , UNDER-BANANAS ,S0) 

ANSWER(REACH(MONKEY,BANANAS,CLIMB(MONKEY,BOX,MOVE(MONKEY,BOX,UNDER-BANANAS,S0) 

) )) 

19 

-MOVABLE(BOX) 

ANSWER (REACH (MONKEY, BANANAS ,CLIMB (MONKEY, BOX, MOVE (MONKEY, BOX , UNDER-BANANAS , S0) ) ) ) 

20 
21 

MOVABLE(BOX) 
CONTRADICTION 

FROM  2,17 

FROM  1,18 

AXIOM 
FROM  19,20 

ANSWER (REACH (MONKEY, BANANAS , CLIMB (MONKEY, BOX, MOVE (MONKEY, BOX , UNDER-BANANAS, S0) )) ) 

11  CLAUSES  LEFT 
28  CLAUSES  GENERATED 
22  CLAUSES  ENTERED 

- 2 3 9-

