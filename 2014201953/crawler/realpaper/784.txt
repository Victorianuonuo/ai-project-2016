A New Perspective on Stable Models

∗

Paolo Ferraris1, Joohyung Lee2 and Vladimir Lifschitz1

1Department of Computer Sciences

2Dept. of Computer Science and Engineering

University of Texas at Austin
1 University Station C0500

Austin, TX 78705

{otto,vl}@cs.utexas.edu

Arizona State University
South Mill Avenue 574

Tempe, AZ 85281
joolee@asu.edu

Abstract

The deﬁnition of a stable model has provided a
declarative semantics for Prolog programs with
negation as failure and has led to the development
of answer set programming. In this paper we pro-
pose a new deﬁnition of that concept, which covers
many constructs used in answer set programming
(including disjunctive rules, choice rules and con-
ditional literals) and, unlike the original deﬁnition,
refers neither to grounding nor to ﬁxpoints. Rather,
it is based on a syntactic transformation, which
turns a logic program into a formula of second-
order logic that is similar to the formula familiar
from the deﬁnition of circumscription.

1 Introduction

Two widely used deﬁnitions of the semantics of logic
programs—in terms of program completion [Clark, 1978]
and in terms of stable models [Gelfond and Lifschitz,
1988]—look very different from each other. The former treats
a logic program as shorthand for its completion, which is a
ﬁrst-order formula. For instance, the program

p(a),
q(b),
r(x) ← p(x), not q(x)

is shorthand for

∀x(p(x) ↔ x = a) ∧ ∀x(q(x) ↔ x = b)
∧∀x(r(x) ↔ (p(x) ∧ ¬q(x))).

(1)

(2)

On the other hand, according to the stable model seman-
tics, (1) is shorthand for the set of the ground instances of
its rules:

p(a),
q(b),
r(a) ← p(a), not q(a),
r(b) ← p(b), not q(b).

(3)

The deﬁnition of a stable model describes a ﬁxpoint construc-
tion that determines which sets of atomic formulas from (3)

∗The ﬁrst and third authors were partially supported by the Na-
tional Science Foundation under Grant IIS-0412907. The second
author was partially supported by DTO AQUAINT.

are considered “stable models”; it turns out that the only sta-
ble model of (3) is

{p(a), q(b), r(a)}.

(4)

In spite of this difference between the two deﬁnitions, there
is often a close relationship between the completion of a pro-
gram and its stable models. For instance, in every model
of (2) (in the sense of ﬁrst-order logic) that satisﬁes the unique
names assumption a (cid:7)= b, the elements of set (4) are true, and
all other ground atoms are false.

Practical needs of answer set programming (ASP) have
led to the invention of several declarative programming con-
structs that are not used in Prolog. Clark’s completion seman-
tics is not applicable to these constructs, at least directly. For
instance, the last rule of the program

p(a),
p(b),
{q(x) : p(x)}

(5)

is a “choice rule” containing a “conditional literal” [Simons
et al., 2002]. Intuitively, this rule says: for any x such that
p(x), choose arbitrarily whether or not to include q(x) in the
stable model. The semantics of programs with choice rules,
like the original stable model semantics, is deﬁned in terms of
grounding and a ﬁxpoint condition. For instance, grounding
turns the last line of (5) into the ground choice rule

{q(a), q(b)}.

As it turns out, program (5) has 4 stable models:

{p(a), p(b)},
{p(a), p(b), q(a)},
{p(a), p(b), q(b)},
{p(a), p(b), q(a), q(b)}.

(6)

In this paper we propose a new deﬁnition of a stable model,
which covers many constructs used in ASP (including dis-
junctive rules, choice rules, cardinality constraints and condi-
tional literals) and refers neither to grounding nor to ﬁxpoints.
Rather, like the deﬁnition of program completion, the new
deﬁnition of a stable model is based on a transformation that
turns the given logic program into a formula of classical logic.
To be precise, the result of this transformation is a second-
order formula, which looks similar to the formula famil-
iar from the deﬁnition of circumscription [McCarthy, 1980;
1986] in the form adopted in [Lifschitz, 1994].

IJCAI-07

372

The new deﬁnition and examples of its use are discussed
in Section 2 below.
In Section 3 we relate our deﬁnition
to a theorem from [Lin, 1991], to the encoding of proposi-
tional logic programs by quantiﬁed Boolean formulas due to
Pearce, Tompits and Woltran [2001],1 and to recent research
on ﬁrst-order equilibrium logic [Pearce and Valverde, 2004;
2005]. A theorem about strong equivalence, illustrating the
nature of the ongoing work on reformulating the theory of
stable models on the basis of the new deﬁnition, is stated in
Section 4. Finally, in Section 5 we propose a way to gener-
alize the concept of program completion that is similar to the
new deﬁnition of a stable model.

Our treatment of stable models may be of interest for three
reasons. First, it provides a new perspective on the place
of stable models within the ﬁeld of nonmonotonic reason-
ing. We can distinguish between “translational” nonmono-
tonic formalisms, such as program completion and circum-
scription, and “ﬁxpoint” formalisms—default logic [Reiter,
1980]2 and autoepistemic logic [Moore, 1985]. In the past,
stable models were seen as part of the “ﬁxpoint tradition.”
In fact, the invention of stable models was an outgrowth of
earlier work on the relationship between logic programming
and autoepistemic logic [Gelfond, 1987]; the ﬁrst journal pa-
per on answer sets [Gelfond and Lifschitz, 1991] emphasized
their relation to default logic. The remarkable similarity be-
tween the new deﬁnition of a stable model and the deﬁnition
of circumscription is rather curious from this point of view.

Second, we expect that the new deﬁnition of stable mod-
els will provide a uniﬁed framework for useful answer set
programming constructs deﬁned and implemented by sev-
eral different research groups, such as choice rules, cardinal-
ity constraints and conditional literals (Helsinki University of
Technology), disjunctive rules and aggregates [Faber et al.,
2004] (Vienna University of Technology and University of
Calabria), and ASET-Prolog constructs [Gelfond, 2002, Sec-
tion 5.2] (Texas Tech University).

Finally, we hope that this deﬁnition of a stable model will
serve as a basis for a new approach to proving program cor-
rectness in ASP, which will be more straightforward than
the one based on grounding and ﬁxpoint deﬁnitions [Ferraris
and Lifschitz, 2005a, Sections 3.3–3.5, 3.7]. These correct-
ness proofs will use equivalent transformations of formulas
of classical logic as the main tool.

2 Deﬁnition and Examples

2.1 Logic Programs as First-Order Formulas

The concept of a stable model will be deﬁned here for ﬁrst-
order sentences (formulas without free variables); logic pro-
grams are viewed in this paper as alternative notation for ﬁrst-

1The fact that circumscription is related to program completion
has been known for a long time [Reiter, 1982; Lifschitz, 1985].
The relationship between circumscription and the Pearce-Tompits-
Woltran transformation is discussed in [Ferraris et al., 2006, Ap-
pendix B].

2The translational deﬁnition of default logic, proposed in [Lif-

schitz, 1990], is rather complicated: it uses third-order variables.

order sentences of special kinds.3

To rewrite a “traditional” program, such as (1), as a ﬁrst-

order sentence, we

• replace every comma by ∧ and every not by ¬ ,
• turn every rule Head ← Body into a formula by rewrit-

ing it as the implication Body → Head, and

• form the conjunction of the universal closures of these

formulas.

For instance, we think of (1) as alternative notation for the
sentence

p(a) ∧ q(b) ∧ ∀x((p(x) ∧ ¬q(x)) → r(x)).

(7)
We are going to treat ¬F as shorthand for F → ⊥, so that the
last conjunctive term can be further expanded into

∀x((p(x) ∧ (q(x) → ⊥)) → r(x)).

In the spirit of [Ferraris and Lifschitz, 2005b], (5) is under-

stood as

p(a) ∧ p(b) ∧ ∀x(p(x) → (q(x) ∨ ¬q(x))).

(8)

Since the last conjunctive term is logically valid, the class
of models of formula (8) would not change if we dropped
that term; but the class of its stable models, as deﬁned below,
would be affected. In this sense, the last conjunctive term is
essential.

Finally, here is an example of turning a cardinality con-
straint [Simons et al., 2002] into a ﬁrst-order formula. The
rule

p ← 10 {q(x) : r(x)} 20

corresponds to the sentence

(∃10x(q(x) ∧ r(x)) ∧ ¬∃21x(q(x) ∧ r(x))) → p,

(9)

where ∃nxF (x) is understood as an abbreviation for
⎞
⎠ .

⎛
⎝ (cid:4)

(cid:4)

xi (cid:7)= xj

∃x1 · · · xn

F (xi) ∧

1≤i≤n

1≤i<j≤n

2.2 Review of Circumscription
Since the new deﬁnition of a stable model looks similar to
the deﬁnition of circumscription, we will begin with a brief
review of the latter, for the special case when all predicate
constants occurring in the formula are circumscribed in par-
allel [Lifschitz, 1994, Section 7.1].

Both deﬁnitions use the following notation. If p and q are
predicate constants of the same arity then p = q stands for
the formula

∀x(p(x) ↔ q(x)),

3In the propositional case, this approach to the syntax of ASP is
not new. The possibility of interpreting choice rules and weight con-
straints in terms of nested conjunctions, disjunctions and negations
was demonstrated in [Ferraris and Lifschitz, 2005b, Section 4.1].
General aggregates can be described in terms of nested implications
[Ferraris, 2005, Section 4]. Including second (“strong,” “classical,”
or “true”) negation without introducing an additional connective is
discussed in [Ferraris and Lifschitz, 2005a, Section 3.9].

IJCAI-07

373

and p ≤ q stands for

∀x(p(x) → q(x)),

where x is a tuple of distinct object variables. If p and q are
tuples p1, . . . , pn and q1, . . . , qn of predicate constants then
p = q stands for the conjunction

and p ≤ q for

p1 = q1 ∧ · · · ∧ pn = qn,

p1 ≤ q1 ∧ · · · ∧ pn ≤ qn.

Finally, p < q is an abbreviation for p ≤ q ∧ ¬(p = q).

In second-order logic, we will apply the same notation to

tuples of predicate variables.

Given a ﬁrst-order sentence F , by CIRC[F ] we denote the

second-order sentence

F ∧ ¬∃u((u < p) ∧ F (u)),

where p stands for the list of all predicate constants occur-
ring in F , u is a list of distinct predicate variables of the same
length, and F (u) is the formula obtained from F by substitut-
ing the variables u for the constants p. Intuitively, the second
conjunctive term of CIRC[F ] expresses that the extents of the
predicates p are minimal subject to condition F .

For example, if F is

p(a) ∧ ∀x(p(x) → q(x))

(10)

then CIRC[F ] is
p(a) ∧ ∀x(p(x) → q(x))

∧¬∃uv(((u, v) < (p, q)) ∧ u(a) ∧ ∀x(u(x) → v(x))).
(11)
Using methods for eliminating second-order quantiﬁers dis-
cussed in [Lifschitz, 1994] and [Doherty et al., 1997], we can
simplify (11) and convert it into

∀x(p(x) ↔ x = a) ∧ ∀x(q(x) ↔ x = a).

(12)
There are cases when CIRC[F ] is not equivalent to any

ﬁrst-order formula, as, for instance, when F is
p(a) ∧ ∀x(p(x) → p(f (x))).

(13)
In this example, a model of CIRC[F ] is any interpreta-
tion that represents p as the set of the values of the terms
a, f (a), f (f (a)), . . ..

• (F → G)∗ = (F ∗ → G∗) ∧ (F → G);
• (QxF )∗ = QxF ∗
, where Q ∈ {∀, ∃}.

Note that the operator F (cid:15)→ F ∗(u) replaces each predicate
constant with the corresponding predicate variable, and that
it commutes with all propositional connectives except impli-
cation and with both quantiﬁers. If, in the deﬁnition of this
operator, we drop the second conjunctive term in the clause
for implication, then F ∗(u) will turn into the formula F (u)
referred to in the deﬁnition of circumscription. That con-
junctive term is the only difference between the deﬁnitions
of CIRC and SM.

A model of F is stable if it satisﬁes SM[F ].

Example 1 If F is (10) then F ∗(u, v) is

u(a) ∧ ∀x((u(x) → v(x)) ∧ (p(x) → q(x)))

and SM[F ] is

p(a) ∧ ∀x(p(x) → q(x))

∧¬∃uv(((u, v) < (p, q)) ∧ u(a) ∧ ∀x((u(x) → v(x))

∧(p(x) → q(x)))).

It is clear that this formula is equivalent to (11), and conse-
quently to (12).

In logic programming notation, (10) can be written as

p(a),
q(x) ← p(x).

The completion of this program

∀x(p(x) ↔ x = a) ∧ ∀x(q(x) ↔ p(x))

is equivalent to (12) as well.
In this example, all three
transformations—SM, CIRC and completion—produce es-
sentially the same result.

Example 2 If F is (13) then, as in the previous example, it is
clear that SM[F ] is equivalent to CIRC[F ]. Consequently, the
stable models of (13) can be characterized by the condition
stated at the end of the previous section: p is represented by
the set of the values of the terms a, f (a), f (f (a)), . . ..

In logic programming notation, (13) can be written as

p(a),
p(f (x)) ← p(x).

(14)

2.3 Stable Models
Given a ﬁrst-order sentence F , by SM[F ] we denote the
second-order sentence

F ∧ ¬∃u((u < p) ∧ F ∗(u)),

The completion of this program

∀x(p(x) ↔ (x = a ∨ ∃y(x = f (y) ∧ p(y)))

is weaker than SM[F ]: some (non-Herbrand4) models of the
completion of (14) are not stable.

where p stands for
the list of all predicate constants
p1, . . . , pn occurring in F , u is a list of n distinct predicate
variables u1, . . . , un, and F ∗(u) is deﬁned recursively:

It is easy to see that the operator SM produces essentially
the same result as CIRC whenever it is applied to a for-
mula corresponding to a set of Horn rules, as in the examples

• pi(t1, . . . , tm)∗ = ui(t1, . . . , tm);
• (t1 = t2)∗ = (t1 = t2);
• ⊥∗ = ⊥;
• (F (cid:13) G)∗ = F ∗ (cid:13) G∗

, where (cid:13) ∈ {∧, ∨};

4An Herbrand interpretation of a signature σ containing at least
one object constant is an interpretation such that (i) its universe is the
set of all ground terms of σ, and (ii) every ground term represents
itself. Clearly, an Herbrand interpretation can be characterized by
the set of ground atoms to which it assigns the value true.

IJCAI-07

374

above.5 But if negation in the bodies of rules is allowed then
this may be no longer the case, as we will see Section 2.4.

What we can say, on the other hand, about this more gen-
eral case is that stable Herbrand models of the corresponding
formula exactly correspond to the stable models of the pro-
gram in the sense of the original deﬁnition from [Gelfond and
Lifschitz, 1988]:
Proposition 1 Let σ be a signature containing at least one
object constant, and Π a ﬁnite set of rules of the form
A0 ← A1, . . . , Am, not Am+1, . . . , not An,

(15)

where A0, . . . , An are atomic formulas of σ not containing
equality. For any set X of ground terms of σ, the following
conditions are equivalent:

• X is a stable model of Π in the sense of the 1988 deﬁni-

tion;

• the Herbrand interpretation of σ that makes the elements
of X true and all other ground atoms false is a stable
model of the formula corresponding to Π.

This theorem shows that the new deﬁnition of a stable
model, restricted to the “traditional” syntax, is a generaliza-
tion of the 1988 deﬁnition to non-Herbrand models. In Sec-
tion 3.1 we will see that our deﬁnition generalizes also the
deﬁnition proposed in [Ferraris, 2005] and used in [Ferraris
and Lifschitz, 2005a; Ferraris et al., 2006].

2.4 Further Examples
Proposition 2 below allows us to simplify the application of
the operator SM to formulas containing negation. In its state-
ment, p is the list of predicate constants occurring in F , and u
is a list of distinct predicate variables of the same length as p.
Proposition 2 If a formula F begins with ¬ then the formula

u ≤ p → (F ∗(u) ↔ F )

is logically valid.

Example 3 Let F be formula (7), corresponding to logic
program (1). Then SM[F ] is

p(a) ∧ q(b) ∧ ∀x((p(x) ∧ ¬q(x)) → r(x))

∧¬∃uvw(((u, v, w) < (p, q, r)) ∧ u(a) ∧ v(b)
∧∀x(((u(x) ∧ (¬q(x))∗) → w(x))
∧((p(x) ∧ ¬q(x)) → r(x)))).

It is clear that the implication in the last line can be dropped.
Furthermore, since the subformula (u, v, w) < (p, q, r) con-
tains the conjunctive term v ≤ q, from Proposition 2 we can
conclude that (¬q(x))∗
can be equivalently replaced here by
¬q(x). Consequently, SM[F ] can be rewritten as
p(a) ∧ q(b) ∧ ∀x((p(x) ∧ ¬q(x)) → r(x))

∧¬∃uvw(((u, v, w) < (p, q, r)) ∧ u(a) ∧ v(b)

∧∀x((u(x) ∧ ¬q(x)) → w(x))).

Using the methods for eliminating second-order quantiﬁers
described at the end of [Lifschitz, 1994, Section 3.3], we can

5This assertion remains true if we allow the heads of rules to be

disjunctions of atomic formulas.

convert this formula into the completion (2) of program (1).
We conclude that in this case the stable models of the program
are identical to the models of its completion.

We can further conclude that there is a unique Herbrand
stable model in this case, and that it corresponds to the set (4)
of ground atoms. This fact follows also from Proposition 1.
Example 4 If F is formula (8), corresponding to logic pro-
gram (5), then a similar calculation converts SM[F ] into

p(a) ∧ p(b) ∧ ∀x(p(x) → (q(x) ∨ ¬q(x)))
∧¬∃uv(((u, v) < (p, q)) ∧ u(a) ∧ u(b)

∧∀x(u(x) → (v(x) ∨ ¬q(x)))).

After the elimination of second-order quantiﬁers, this formula
becomes

∀x(p(x) ↔ (x = a ∨ x = b))
∧∀x(q(x) → (x = a ∨ x = b)).

The stable models of (5) can be characterized as the interpre-
tations that (i) represent p by the set of values of a and b, and
(ii) represent q by a subset of that set. Consequently, (8) has 4
Herbrand stable models, and they correspond to sets (6).

We call a formula negative if every occurrence of every
predicate constant in this formula belongs to the antecedent
of an implication. Clearly any formula of the form ¬F is
negative, because this expression is shorthand for F → ⊥
(Section 2.1). Proposition 2 can be generalized to arbitrary
negative formulas.

3 Relation to Earlier Work

3.1 Propositional Case

In the propositional case, the operator SM turns into the
encoding of formulas of equilibrium logic by quantiﬁed
Boolean formulas proposed in [Pearce et al., 2001] and re-
viewed in [Ferraris et al., 2006, Appendix B]. In view of the
Pearce-Tompits-Woltran theorem, as restated in that review, it
follows that in the propositional case our deﬁnition of a stable
model is equivalent to the deﬁnition of a stable model (answer
set) proposed in [Ferraris, 2005] and reviewed in [Ferraris et
al., 2006, Appendix A].

3.2 Lin’s Transformation
Theorem 5 from [Lin, 1991] relates stable models of “tradi-
tional programs” (as in Proposition 1 above) to circumscrip-
tion. It involves a syntactic transformation that can be de-
scribed as a sequence of three steps. First, each rule is turned
into a formula that may contain new predicate constants—
“doubles” p(cid:4)
of the predicate constants p occurring in the rule.
Second, the new predicate constants are circumscribed in par-
allel. Third, the result is conjoined with the equivalences
p(cid:4) = p. We will show that this idea is applicable to arbitrary
ﬁrst-order sentences, and that the result of this transformation
is closely related to the operator SM.

To do this, we need parallel circumscription of a slightly
more general kind than deﬁned in Section 2.2. In the deﬁ-
nition of circumscription, there is no need to assume that p
stands for the list of all predicate constants occurring in F ;
p may include only some of these constants. The result of

IJCAI-07

375

circumscribing the predicate constants p in a ﬁrst-order sen-
tence F will be denoted by CIRC[F ; p]. For instance, if F
is (10) then CIRC[F ; q] is

p(a) ∧ ∀x(p(x) → q(x))

∧¬∃v((v < q) ∧ p(a) ∧ ∀x(p(x) → v(x))),

which is equivalent to

p(a) ∧ ∀x(p(x) ↔ q(x)).

Let F be a ﬁrst-order sentence, and let p be the list of all
(cid:4)
predicate constants occurring in F . Take a list p
of distinct
predicate constants that do not occur in F , of the same length
as p. By L[F ; p(cid:4)] we denote the formula

CIRC[F ∗(p(cid:4)); p(cid:4)] ∧ (p(cid:4) = p).

This formula turns out to be equivalent to SM[F ] conjoined
with explicit deﬁnitions of the new predicate constants p(cid:4)
:
Proposition 3 L[F ; p(cid:4)] is equivalent to SM[F ] ∧ (p(cid:4) = p).
This is immediate from the deﬁnitions of L and SM, using the
fact that F ∗(p) is equivalent to F .

It follows that SM[F ] is equivalent to L[F ; p(cid:4)] with the
replaced by existentially quantiﬁed

predicate constants p(cid:4)
predicate variables:
Corollary 1 SM[F ] is equivalent to ∃u L[F ; u].

3.3 Equilibrium Logic
The deﬁnition of ﬁrst-order equilibrium logic below is similar
to the one proposed in [Pearce and Valverde, 2005, Section 7],
except that ground terms are not identiﬁed here with their val-
ues; as a result, different ground terms are allowed to have the
same value. Our deﬁnition describes essentially Kripke mod-
els with two worlds (“here” and “there”) that have the same
universe, interpret all function constants in the same way, and
satisfy the minimality condition introduced in [Pearce, 1997].
If I is an interpretation of a signature σ (in the sense of
classical logic) then by σI
we denote the extension of σ ob-
tained by adding pairwise distinct symbols ξ∗
, called names,
for all elements ξ of the universe of I as object constants. We
deﬁned by I(ξ∗) = ξ.
will identify I with its extension to σI
The value that I assigns to a ground term t of signature σI
will be denoted by tI

By σf we denote the part of σ consisting of its function
constants (including object constants, which are viewed as
function constants of arity 0). We will represent an inter-
pretation I of σ as the pair (cid:16)I|σf , I (cid:4)(cid:17), where I (cid:4)
is the set of
all atomic formulas, formed using predicate constants from σ
and names ξ∗

, which are satisﬁed by I.

.

An HT-interpretation of σ is a triple (cid:16)I f , I h, I t(cid:17), where
• I f

is an interpretation of σf , and
, I t

• I h

1 = tI f
2 ;

• I |= t1 = t2 if tI f
• I (cid:7)|= ⊥;
• I |= F ∧ G if I |= F and I |= G; similarly for ∨;
• I |= F → G if

(i) I (cid:7)|= F or I |= G, and
(ii) (cid:16)I, I t(cid:17) |= F → G;

• I |= ∀xF (x) if, for each ξ from the universe of I f

I |= F (ξ∗); similarly for ∃.

,

(In (ii) we understand satisfaction as in classical logic.)

An HT-interpretation of the form (cid:16)I, J, J(cid:17) is an equilibrium

model of F if

• (cid:16)I, J, J(cid:17) |= F , and
• for any proper subset J (cid:4)
This deﬁnition provides a precise model-theoretic counter-

of J , (cid:16)I, J (cid:4), J(cid:17) (cid:7)|= F .

part of the operator SM:
Proposition 4 An interpretation (cid:16)I, J(cid:17) is a stable model of a
sentence F iff (cid:16)I, J, J(cid:17) is an equilibrium model of F .

4 Strong Equivalence

To turn the deﬁnition of a stable model proposed in this pa-
per into a tool that can help us in the design of provably
correct ASP programs, we need to ﬁnd appropriate counter-
parts of the theorems that are used in correctness proofs to-
day.6 The “traditional” theorems about stable models will
roughly correspond to the special cases of these new theo-
rems in which the formulas involved are propositional combi-
nations of ground atoms, perhaps of a special syntactic form,
and our attention is restricted to Herbrand models.

To give an example illustrating this general point, we state
here a counterpart of the characterization of strong equiva-
lence [Lifschitz et al., 2001] due to Fangzhen Lin [2002].

About ﬁrst-order sentences F and G we say that F is
strongly equivalent to G if, for every sentence H (possibly
of a larger signature), F ∧ H has the same stable models
as G ∧ H (or, to put it differently, if, for every H, SM[F ∧ H]
is equivalent to SM[G ∧ H]). In the following theorem, p
is the list of predicate constants occurring in at least one of
the sentences F , G, and p(cid:4)
is a list of new, distinct predicate
constants of the same length as p.
Proposition 5 F is strongly equivalent to G iff the formula

p(cid:4) ≤ p → (F ∗(p(cid:4)) ↔ G∗(p(cid:4)))

is logically valid.

Using this theorem we can show,

that
¬∀xF (x) is strongly equivalent to ∃x¬F (x). (This is a pred-
icate logic counterpart of the fact that ¬(F ∧ G) is strongly
equivalent to ¬F ∨ ¬G.) Indeed, in view of Proposition 2, the
implications

for instance,

p(cid:4) ≤ p → ((¬∀xF (x))∗ ↔ ¬∀xF (x)),
p(cid:4) ≤ p → ((∃x¬F (x))∗ ↔ ∃x¬F (x));

6See, for instance, [Ferraris and Lifschitz, 2005a, Sections 2.1–

cate constants from σ and object constants ξ∗
trary elements ξ of the universe of I f

are sets of atomic formulas formed using predi-
for arbi-
, such that I h ⊆ I t
.
The satisfaction relation between an HT-interpretation
I = (cid:16)I f , I h, I t(cid:17) and a sentence F of the signature σ(cid:5)I f ,I h(cid:6)
is deﬁned recursively:

• I |= p(t1, . . . , tn) if p((tI f

1 )∗, . . . , (tI f

n )∗) ∈ I h

;

2.4, 2.6–3.1].

IJCAI-07

376

are logically valid; the right-hand sides of the two equiva-
lences are classically equivalent to each other.

For our proof of the “only if” part of Proposition 5 it is not
essential that the deﬁnition of strong equivalence allows the
signature of H to be larger than the signature of F and G. It
follows that F is strongly equivalent to G whenever F ∧ H
has the same stable models as G ∧ H for all sentences H of
the same signature as F and G.

Relations between logic programs with variables, some-
what similar to strong equivalence as deﬁned above but more
limited in scope, are discussed in [Pearce and Valverde, 2005,
Section 7] and [Eiter et al., 2006].

5 A New Perspective on Program Completion
5.1 Pointwise Stable Models
As observed in [Lee and Lin, 2006], program comple-
tion is similar in some ways to the concept of pointwise
circumscription—the modiﬁcation of McCarthy’s original
deﬁnition that was proposed in [Lifschitz, 1987]. Accord-
ing to either deﬁnition, circumscribing a predicate constant p
makes the extent of p “minimal,” but minimality is under-
stood in different versions differently. According to the origi-
nal deﬁnition of circumscription, to make the extent of a pred-
icate smaller means to replace it by a proper subset. In the
pointwise version, to make the extent of a predicate smaller
means to decrement it by a single point. The pointwise min-
imality condition is, generally, weaker than minimality ac-
cording to McCarthy; similarly, program completion is gen-
erally weaker than the stability condition.

In this section, we deﬁne a weakened, “pointwise” version
of the operator SM that can be viewed as a generalization of
program completion to arbitrary ﬁrst-order formulas.

If p and q are predicate constants of the same arity k then
< q stands for the formula

1

p

∃x(q(x) ∧ ∀y(p(y) ↔ (q(y) ∧ x (cid:7)= y))),

where x, y are disjoint tuples of distinct object variables
x1, . . . , xk, y1, . . . , yk, and x (cid:7)= y is shorthand for

¬(x1 = y1 ∧ · · · ∧ xk = yk).

This formula expresses that the extent of p can be obtained
from the extent of q by removing one element. If p and q are
tuples p1, . . . , pn and q1, . . . , qn of predicate constants then
p

< q stands for the disjunction

1

(cid:4)

1

< qi) ∧

(pj = qj)

(cid:7)

⎛
⎝(pi

⎞
⎠ ,

1≤i≤n

1≤j≤n, j(cid:7)=i

and similarly for tuples of predicate variables.

Given a ﬁrst-order sentence F , by PSM[F ] we denote the

second-order sentence

F ∧ ¬∃u((u

1

< p) ∧ F ∗(u)),

where p, u and F ∗(u) are as in the deﬁnition of SM (Sec-
tion 2.3). A model of F is pointwise stable if it satisﬁes
PSM[F ]. Clearly, every stable model is pointwise stable.

Unlike SM[F ], the weaker formula PSM[F ] can be always

Proposition 6 Formula PSM[F ] is equivalent to
¬∃xi(pi(xi) ∧ Gi(xi)),

F ∧

(cid:4)

1≤i≤n
where Gi(xi) stands for

F ∗(p1, . . . , pi−1, λyi(pi(yi) ∧ yi (cid:7)= xi), pi+1, . . . , pn)

and xi

, yi

are disjoint tuples of distinct variables.7

For instance, if F is p(a) ∧ p(b) then F ∗(u) is u(a) ∧ u(b),

so that F ∗(λy(p(y) ∧ y (cid:7)= x)) is

p(a) ∧ a (cid:7)= x ∧ p(b) ∧ b (cid:7)= x,

and PSM[F ] is
p(a) ∧ p(b) ∧ ¬∃x(p(x) ∧ p(a) ∧ a (cid:7)= x ∧ p(b) ∧ b (cid:7)= x).

This formula can be simpliﬁed:

p(a) ∧ p(b) ∧ ¬∃x(p(x) ∧ a (cid:7)= x ∧ b (cid:7)= x).

In this example, PSM[F ] is obviously equivalent to the

completion of F :

∀x(p(x) ↔ (x = a ∨ x = b)).

This fact is an instance of the general theorem stated below.

5.2 Relation to Program Completion
Lloyd and Topor [1984] noted that the process of completing
a program can be extended in an obvious way to rules of a
more general form than allowed in [Clark, 1978]. It is essen-
tial that the head of a rule be an atom, but the body can be an
arbitrary ﬁrst-order formula.

Proposition 7 below refers to completion in this more gen-
eral sense, but it does introduce a restriction on the syntactic
form of the bodies of rules. The rules we consider in this
section have the form

p0(t0) ← p1(t1) ∧ · · · ∧ pm(tm) ∧ N,

(16)
where ti
are tuples of terms and N is a negative formula (see
Section 2.4). For instance, every rule of form (15) has also
form (16): take N to be ¬Am+1 ∧ · · · ∧ ¬An.

A rule of form (16) is acyclic if for each i = 1, . . . , m such

that pi is p0, the formula

N → t0 (cid:7)= ti

is logically valid. For instance, each of the rules (1) is obvi-
ously acyclic—its body doesn’t contain the predicate constant
occurring in the head. Any rule of form (16) can be made
acyclic by a strongly equivalent transformation: conjoin the
body with the formulas t0 (cid:7)= ti
for all i = 1, . . . , m such that
pi is p0. For instance, the second rule of (14) can be rewritten
as the acyclic rule

p(f (x)) ← p(x), f (x) (cid:7)= x.

For this reason, the requirement in the statement of the the-
orem below that each of the given rules be acyclic is not an
essential limitation.
Proposition 7 For any ﬁnite set F of acyclic rules, the com-
pletion of F is equivalent to PSM[F ].

In view of this fact, PSM[F ] can be viewed as an extension
of the concept of program completion to arbitrary ﬁrst-order
formulas.

7On the use of λ-notation in ﬁrst-order logic, see [Lifschitz,

rewritten without second-order quantiﬁers:

1994, Section 3.1].

IJCAI-07

377

5.3 Tight Formulas

Franc¸ois Fages [1991] showed that if a logic program satisﬁes
a certain syntactic condition, which is now called “tightness,”
then its stable models can be characterized as the models of
its completion. This theorem and its generalizations (see [Er-
dem and Lifschitz, 2003]) play an important role in answer
set programming.

Consider, for instance, logic programs consisting of rules
of form (16). According to the deﬁnition of a tight program,
to decide whether such a program is tight we should look at
its “predicate dependency graph.” The vertices of this graph
are the predicate constants occurring in the program, and its
edges lead from p0 to p1, . . . , pm for the rules (16) that the
program consists of. The program is called tight if its predi-
cate dependency graph is acyclic.

Proposition 8 below extends Fages’s theorem to the general
framework introduced in this note. To deﬁne the predicate de-
pendency graph for an arbitrary ﬁrst-order sentence, we need
a few auxiliary deﬁnitions.

Recall that an occurrence of a subformula or a predicate
constant in a formula F is positive if the number of impli-
cations in F containing that occurrence in the antecedent is
even; it is strictly positive if that number is 0.8 In (7), for in-
stance, both occurrences of q are positive, but only the ﬁrst is
strictly positive. The key idea of our deﬁnition of the predi-
cate dependency graph for an arbitrary formula F is to con-
centrate on the implications G → H that have strictly positive
occurrences in F ; such implications generalize the concept of
a rule in traditional logic programs.

We say that a predicate constant p depends on a predicate

constant q in an implication G → H if

• p has a strictly positive occurrence in H, and
• q has a positive occurrence in G that does not belong to

any occurrence of a negative formula in G.

The predicate dependency graph of a formula F is the di-
rected graph such that

• its vertices are the predicate constants occurring in F ,

and

• it has an edge from a vertex p to a vertex q if p depends
on q in an implication that has a strictly positive occur-
rence in F .

For instance, the predicate dependency graph of formula (7)
has three vertices p, q, r and one edge, from r to q. This is
the same graph as the one given by the more special deﬁnition
reviewed above applied to the “logic programming represen-
tation” (1) of formula (7).

Just as in the special case above, we say that a formula F
is tight if its predicate dependency graph is acyclic. For in-
stance, formulas (7)–(10) are tight; formula (13) is not tight,
because its predicate dependency graph is a self-loop.
Proposition 8 For any tight sentence F , PSM[F ] is equiva-
lent to SM[F ].

8Note that we apply the term “negative” to formulas, and the
terms “positive” and “strictly positive” to occurrences of subformu-
las and predicate constants in a formula.

6 Conclusion
The deﬁnition of a stable model proposed in this paper is ap-
plicable both to rules covered by the original 1988 deﬁnition
and to rules of several more general kinds used in answer set
programming. Instead of grounding and ﬁxpoints, it refers to
a translation into classical logic, and is in this sense close to
the deﬁnitions of program completion and circumscription.

The relationship between the original deﬁnition of a stable
model and the deﬁnition proposed here can be compared with
the relationship between two deﬁnitions of a causal theory—
the original deﬁnition introduced in [McCain and Turner,
1997] and its generalization proposed in [Lifschitz, 1997].
The original deﬁnition uses a ﬁxpoint construction; the gen-
eralization is based on a translation into classical logic.

Another deﬁnition of a stable model for ﬁrst-order order
sentences is given independently by Lin and Zhou [2007]. It
refers to grounding, but in other ways it is similar to ours.

Extending main results of the theory of stable models to the
general framework described above is a topic of future work.

Acknowledgements
We are grateful to Pedro Cabalar, Martin Gebser and Hudson
Turner for useful comments on this paper.

References
[Clark, 1978] Keith Clark. Negation as failure.

In Herve
Gallaire and Jack Minker, editors, Logic and Data Bases,
pages 293–322. Plenum Press, New York, 1978.

[Doherty et al., 1997] Patrick Doherty, Witold Łukaszewicz,
and Andrzey Szałas. Computing circumscription revisited:
A reduction algorithm. Journal of Automated Reasoning,
18(3):297–336, 1997.

[Eiter et al., 2006] Thomas Eiter, Michael Fink, Hans Tom-
pits, Patrick Traxler, and Stefan Woltran. Replacements
in non-ground answer-set programming. In Proceedings
of International Conference on Principles of Knowledge
Representation and Reasoning (KR), 2006.

[Erdem and Lifschitz, 2003] Esra Erdem and Vladimir Lif-
schitz. Tight logic programs. Theory and Practice of Logic
Programming, 3:499–518, 2003.

[Faber et al., 2004] Wolfgang Faber, Nicola Leone, and
Recursive aggregates in disjunctive
Gerard Pfeifer.
logic programs: Semantics and complexity.
In Pro-
ceedings of European Conference on Logics in Arti-
ﬁcial Intelligence (JELIA), 2004.
Revised version:
http://www.wfaber.com/research/papers/
jelia2004.pdf.

[Fages, 1991] Franc¸ois Fages. A ﬁxpoint semantics for gen-
eral logic programs compared with the well–supported
and stable model semantics. New Generation Computing,
9:425–443, 1991.

[Ferraris and Lifschitz, 2005a] Paolo Ferraris and Vladimir
Lifschitz. Mathematical foundations of answer set pro-
gramming. In We Will Show Them! Essays in Honour of
Dov Gabbay, pages 615–664. King’s College Publications,
2005.

IJCAI-07

378

[Ferraris and Lifschitz, 2005b] Paolo Ferraris and Vladimir
Lifschitz. Weight constraints as nested expressions. The-
ory and Practice of Logic Programming, 5:45–74, 2005.

[Ferraris et al., 2006] Paolo Ferraris, Joohyung Lee, and
Vladimir Lifschitz. A generalization of the Lin-Zhao the-
orem. Annals of Mathematics and Artiﬁcial Intelligence,
2006. To appear.

[Ferraris, 2005] Paolo Ferraris. Answer sets for proposi-
tional theories.
In Proceedings of International Confer-
ence on Logic Programming and Nonmonotonic Reason-
ing (LPNMR), pages 119–131, 2005.
[Gelfond and Lifschitz, 1988] Michael

and
The stable model semantics for
Vladimir Lifschitz.
logic programming.
In Robert Kowalski and Kenneth
Bowen, editors, Proceedings of International Logic Pro-
gramming Conference and Symposium, pages 1070–1080,
1988.

Gelfond

[Gelfond and Lifschitz, 1991] Michael

Vladimir Lifschitz.
grams and disjunctive databases.
Computing, 9:365–385, 1991.

and
Classical negation in logic pro-
New Generation

Gelfond

[Gelfond, 1987] Michael Gelfond. On stratiﬁed autoepis-
temic theories. In Proceedings of National Conference on
Artiﬁcial Intelligence (AAAI), pages 207–211, 1987.

[Gelfond, 2002] Michael Gelfond.

Representing knowl-
edge in A-Prolog. Lecture Notes in Computer Science,
2408:413–451, 2002.

[Lee and Lin, 2006] Joohyung Lee and Fangzhen Lin. Loop
Artiﬁcial Intelligence,

formulas for circumscription.
170(2):160–185, 2006.

[Lifschitz et al., 2001] Vladimir Lifschitz, David Pearce,
and Agustin Valverde. Strongly equivalent logic programs.
ACM Transactions on Computational Logic, 2:526–541,
2001.

[Lifschitz, 1985] Vladimir Lifschitz. Computing circum-
scription.
In Proceedings of International Joint Confer-
ence on Artiﬁcial Intelligence (IJCAI), pages 121–127,
1985.

[Lifschitz, 1987] Vladimir Lifschitz. Pointwise circumscrip-
tion. In Matthew Ginsberg, editor, Readings in nonmono-
tonic reasoning, pages 179–193. Morgan Kaufmann, San
Mateo, CA, 1987.

[Lifschitz, 1990] Vladimir Lifschitz. On open defaults. In
John Lloyd, editor, Computational Logic: Symposium
Proceedings, pages 80–95. Springer, 1990.

[Lifschitz, 1994] Vladimir Lifschitz. Circumscription.

In
D.M. Gabbay, C.J. Hogger, and J.A. Robinson, editors,
The Handbook of Logic in AI and Logic Programming,
volume 3, pages 298–352. Oxford University Press, 1994.
[Lifschitz, 1997] Vladimir Lifschitz. On the logic of causal

explanation. Artiﬁcial Intelligence, 96:451–465, 1997.

[Lin and Zhou, 2007] Fangzhen Lin and Yi Zhou. From an-
swer set logic programming to circumscription via logic of
GK. In Proceedings of International Joint Conference on
Artiﬁcial Intelligence (IJCAI), 2007. This volume.

[Lin, 1991] Fangzhen Lin. A Study of Nonmonotonic Rea-

soning. PhD thesis, Stanford University, 1991.

[Lin, 2002] Fangzhen Lin. Reducing strong equivalence of
logic programs to entailment in classical propositional
logic. In Proceedings of International Conference on Prin-
ciples of Knowledge Representation and Reasoning (KR),
pages 170–176, 2002.

[Lloyd, 1984] John Lloyd. Foundations of Logic Program-

ming. Springer-Verlag, 1984.

[McCain and Turner, 1997] Norman McCain and Hudson
Turner. Causal theories of action and change.
In Pro-
ceedings of National Conference on Artiﬁcial Intelligence
(AAAI), pages 460–465, 1997.

[McCarthy, 1980] John McCarthy. Circumscription—a form
Artiﬁcial Intelligence,

of non-monotonic reasoning.
13:27–39,171–172, 1980.

[McCarthy, 1986] John McCarthy. Applications of circum-
scription to formalizing common sense knowledge. Artiﬁ-
cial Intelligence, 26(3):89–116, 1986.

[Moore, 1985] Robert Moore. Semantical considerations on
nonmonotonic logic. Artiﬁcial Intelligence, 25(1):75–94,
1985.

[Pearce and Valverde, 2004] David Pearce

and Agustin
Valverde. Towards a ﬁrst order equilibrium logic for
nonmonotonic reasoning.
In Proceedings of European
Conference on Logics in Artiﬁcial Intelligence (JELIA),
pages 147–160, 2004.

[Pearce and Valverde, 2005] David Pearce

and Agustin
A ﬁrst order nonmonotonic extension of

Valverde.
constructive logic. Studia Logica, 80:323–348, 2005.

[Pearce et al., 2001] David Pearce, Hans Tompits, and Ste-
fan Woltran. Encodings for equilibrium logic and logic
programs with nested expressions.
In Proceedings of
Portuguese Conference on Artiﬁcial Intelligence (EPIA),
pages 306–320, 2001.

[Pearce, 1997] David Pearce. A new logical characteri-
zation of stable models and answer sets.
In J¨urgen
Dix, Luis Pereira, and Teodor Przymusinski, editors,
Non-Monotonic Extensions of Logic Programming (Lec-
ture Notes in Artiﬁcial Intelligence 1216), pages 57–70.
Springer-Verlag, 1997.

[Reiter, 1980] Raymond Reiter. A logic for default reason-

ing. Artiﬁcial Intelligence, 13:81–132, 1980.

[Reiter, 1982] Raymond Reiter. Circumscription implies
predicate completion (sometimes).
In Proceedings of
International Joint Conference on Artiﬁcial Intelligence
(IJCAI), pages 418–420, 1982.

[Simons et al., 2002] Patrik Simons,

Ilkka Niemel¨a, and
Timo Soininen. Extending and implementing the stable
model semantics. Artiﬁcial Intelligence, 138:181–234,
2002.

IJCAI-07

379

