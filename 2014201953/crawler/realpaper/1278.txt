Session  5  Applications  and 
Implications  of  A r t i f i c i al 
Intelligence 

Abstract 

ARTIFICIAL  INTELLIGENCE  AND  AUTOMATIC  PROGRAMMING  IN  CAI 

E l l i ot  B.  Koffman 
Computer  Science  Group 
E l e c t r i c al  Engineering  Dept 
University  of  Connecticut 
Storrs,  Conn.  06268 

Sumner  E.  Blount 
Software  Development  Group 
D i g i t al  Equipment  Corp. 
Maynard,  Mass.  01754 

This  paper  discusses  generative  computer-assisted 

instruction  (CAI)  and 
i ts  relationship  to  A r t i f i c i al 
Intelligence  Research.  Systems  which  have  a  limited 
capability  f or  natural 
described. 
A r t i f i c i al  Intelligence  could  be  applied  are  outlined. 
These  include  i n d i v i d u a l i z a t i on  of  i n s t r u c t i o n,  deter(cid:173)
mining  the  degree  of"  accuracy  of  a  student  response, 
and  problem-solving, 

language  communication  are 
In  a d d i t i o n,  p o t e n t i al  areas  in  which 

A  CAI  system  which  is  capable  of  w r i t i ng  computer 
programs  is  described  in  d e t a i l.  Techniques  are  given 
f or  generating  meaningful  programming  problems. 
These 
problems  are  represented  as  a  sequence  of  p r i m i t i ve 
tasks  each  of  which  can  be  coded  in  several  ways.  The 
manner  in  which  the  system  designs 
program  and  monitors  the  student  solution  is 
described. 

i ts  own  solution 
also 

I.  AI  in  CAT 

There 

is  currently  s i g n i f i c a nt 

interest 

in 

for  computer-assisted 

generative  systems 
(CAI).  A  generative  system  has  the  capability  to  both 
generate  and  solve  meaningful  problems. 
It  must  also 
be  able  to  monitor  a  student's  s o l u t i o n,  determine  to 
what  extent  the  student  is  c o r r e c t,  and  provide  p e r t i(cid:173)
nent  remedial  feedback. 

i n s t r u c t i on 

Generative  CAI  systems  free  the  course  author 
from  having  to  develop  several  alternative  presenta(cid:173)
tions  of  the  same  or  similar  material. 
In  a d d i t i o n, 
the  course  author  does  not  have 
to  specify  correct 
and  incorrect  answers  and  t h e ir  consequences  as  the 
system  can  determine  a ll  of  these  on  i ts  own.  These 
systems  often  have  the  capability  to  reply  to  student 
questions  and  allow  him  to  divert  the 
instruction  to 
areas  that 

interest  him. 

Data-Base  Systems 

There  have  been  a  few  CAI  systems  designed  which 

are  oriented  around  a  structured  network  of  f a c t s. 
Wexler  describes  a  system  which  combines  generative 
CAI  with  frame-oriented  CAI  in  that  the  course-author 
must  specify  certain  question  formats.  The  system 
generates  parameters  for  these  formats  and  searches 
the  data  base  to  determine  the  correct  answer. 
generates  remedial 
if 
student's  solution  is 
either  be  in  the  form  of  a  correct  statement  based  on 
the  student's  response  or  a  trace  of  the  steps  required 
to  r e t r i e ve  the  correct  answer.  On  command  from  the 
student, 
base  which  conform  to  prespecified  patterns. 

It 
the 
incorrect.  This  feedback  can 

it  w i ll  generate  statements  from  i ts  data(cid:173)

i ts  network 

feedback 

from 

This  research  has  been  supported  by  the  National 
The 
I n s t i t u te  of  Education,  Grant  #0EG-0-72-0895. 
University  of  Connecticut  Computer  Center  Provided 
computational 

f a c i l i t i e s. 

Carbonell  describes  a  system,  SCHOLAR,  in  which 

the  generation  of  several  types  of  questions  is  done 
e n t i r e ly  by  the  system  from  the  semantic  network.  Also, 
the  system  has 
of  student  questions  and  generate  appropriate  responses. 
As  in  the  Wexler  system,  the  semantic  network  must 
be  constructed  by  the  course-author. 

the  capability  to  i n t e r p r et  a  variety 

Recent  research  with  SCHOLAR  (Carbonell3)  has 

information  along 
attempted  to  incorporate  graphical 
with  symbolic  information  in  a  semantic  network. 
In 
a d d i t i o n,  emphasis  is  being  placed  on  improving  the 
a b i l i ty  of  the  system  to  make  inferences  based  upon 
the  information  contained  in  i ts  semantic  network  and 
to  take 
associated  with  an 

i n to  account  the  fuzzyness  or  uncertainty 

inference. 

(Carhonell  and  C o l l i n s4). 

Simmons5  describes  a  system  in  which  the  semantic 
network  is  automatically  produced  from  a  page  of  t e x t. 
The  student  can  request  paraphases  of  d i f f i c u lt  passa(cid:173)
ges  and  word  d e f i n i t i o n s. 
can  generate  " f i l l - i n"  and  " t r u e - f a l s e"  questions  from 
i ts  semantic  network. 

In  a d d i t i o n,  the  system 

This  system  r e l i es  heavily  on  the  use  of  an 

augmented  t r a n s i t i on  network  grammar  (Woods6)  both 
for  the  construction  of  the  semantic  network  and  for 
the  generation  of  statements  from  t h is  network.  More 
recent  research  has  focused  on  the  use  of  a  STRIPS  l i ke 
model  (Fikes  and  Nilsson')  to  allow  modifications  to 
the  semantic  network  which  r e f l e ct  a  time  sequence  of 
events. 

Research  in  a  CAI  system  for  meteorology  (Brown, 

f i n i te  automata  structure  for  storing 

Burton  and  Zdybel8)  has  investigated  the  use  of  a 
semantic  network  to  store  s t a t ic  information  and  an 
augmented 
information  concerning  the  dynamics  of  a  process. 
This  l a t t er  structure  shows, 
t r a n s i t i o n s,  the  external  and  i n t e r n al  conditions  which 
must  be  met  before  the  t r a n s i t i on  can  occur.  Conse(cid:173)
quently,  when  a  student  poses  a  question,  he  excites 
the  model  and  causes  the  generation  of  a  tree  of 
intermediate  states  u n t il  equilibrium  is  reached. 
Answering  the  student's  question  is  accomplished  by 
i n t e r p r e t i ng  t h is  tree  of  states 
in  the  appropriate 
manner. 

for  a ll  possible  state 

As  research  continues, 

improvements  due  to  A r t i(cid:173)
future  ver(cid:173)

Intelligence  Research  w i ll  enable 

f i c i al 
sions  of  data-base  oriented  systems  to  accept  an 
unstructured  or  essay-type  response  from  a  student. 
These  systems  provide  an  impressive  demonstration  of 
the  p o t e n t i al  application  of  research 
language  communications  and  question-answering  to  CAI. 
However, 
in 
generative  CAI  which  t ie  in  very  closely  with  A r t i(cid:173)
f i c i al 

there  are  s t i ll  several  problem  areas 

I n t e l l i g e n c e. 

in  natural 

I n d i v i d u a l i z i ng  I n s t r u c t i on  and  Remedial  Aid 

The  f i r st  problem  is 

i n d i v i d u a l i z i ng  the 

86 

is  best  for  a  student  to  study  based  on  his 

i n s t r u c t i on  received  by  each  student  or  determining 
what 
previous  interactions  with  the  system.  This  is  a 
problem  in  pattern  r e c o g n i t i o n.  The  student  must  be 
c l a s s i f i ed  as  a  p a r t i c u l ar  type  of  learner.  Based  on 
t h is  categorization  and  his  past  h i s t o r y,  an  appro(cid:173)
p r i a te  concept  should  be  selected  f or  study. 

This  problem  is  being  studied  by  Shea  and  Sleeaan  . 

is  s t r i c t ly  concerned  with  student 

They  propose  a  three  l e v el  teaching  system  in  which 
l e v el  one 
i n t e r(cid:173)
a c t i o n,  record  c o l l e c t i o n,  and  generation  of  problems 
to  s u it  the  c r i t e r ia  imposed  by  l e v el  2. 
responsible 
strategy. 
used  and  evaluates  the  performance  of  the  lower  levels 
to  determine  whether  performance  is  satisfactory  or 
whether  a  d i f f e r e nt  strategy  should  be  t r i e d. 

for  implementing  a  specific  teaching 
Level  3  decides  which  strategy  should  be 

Level  2  is 

Other  studies  in  the  design  of  an  i n t e l l i g e nt 

have  centered  around  the  use  of  a 

monitor  f or  CAI 
student  model  (summary  of  a  student's  past  performance) 
and  a  concept  t r e e,  which  indicates  the  p r e - r e q u i s i te 
structure  of  the  course.  As  the  syster.  gains  exper(cid:173)
ience  with  a  p a r t i c u l ar  student, 
it  updates  his  model 
and  establishes  to  what  extent  he  prefers  to  advance 
quickly  to  new  material  or  b u i ld  a  solid  foundation 
before  going  on.  Based  on  i ts  knowledge  of  the  s t u(cid:173)
dent  and  his  past  performance, 
it  decides  at  which 
plateau  of  the  concept 
working.  A ll  concepts  on  t h is  plateau  are  then 
evaluated  with  respect 
to  factors  such  as  recency  of 
use,  change  in  state  of  knowledge  during  last  i n t e r(cid:173)
a c t i o n,  current  state  of  knowledge, 
increase  or  decrease  his  state  of  knowledge,  and 
relevance 
to  other  course  concepts.  The  highest 
scoring  concept  is  selected,  a  problem  suitable  for 
his  experience 
monitored. 

is  generated,  and  i ts  s o l u t i on  is 

tree  the  student  should  be 

tendency  to 

l e v el 

it 

Their 

to  determine 

is  r e l a t i v e ly  easy 

In  mathematics,  resolu(cid:173)

If  a  simple  number  or  phrase 

In  order  to  generate  pertiment  remedial  feedback, 
a  CAI  system  must  determine  the  degree  of  correctness 
of  a  student  response. 
is  expected, 
whether  a  student  is  c o r r e c t. 
tion-based  theorem  provers  have  been  used  to  v e r i fy 
l o g i c al  proof  procedures1 1. 
i n i t i al  application 
has  been  successful  in  assisting  a  student  in  constr(cid:173)
ucting  a  proof  by  applying  the  r u le  of  inference 
designated  by  him  to  e a r l i er  lines 
uence. 
is  given  remedial 
a  l i ne  typed  in  by  a  student  is  a  v a l id  inference  from 
his  previous  work  have  been  "moderately  successful". 
A  more  ambitious  goal  now  under  study  is  to  have  the 
theorem  prover  suggest  ways  of  completing  a  proof 
taking  i n to  account  a  student's 
work. 

in  the  proof  seq(cid:173)
If  the  student's  rule  cannot  be  applied,  he 
feedback.  E f f o r ts  to  v e r i fy  that 

incomplete  or  erroneous 

Often  it 

is  not  s u f f i c i e nt  to  t e ll  a  student  he 

is 
wrong  and  indicate  the  correct  solution  method.  An 
i n t e l l i g e nt  CAI  system  should  be  able  to  make  hypo(cid:173)
theses  based  on  a  student's  error  h i s t o ry  as  to 
where  the  r e al  source  of  his  d i f f i c u l ty  l i e s. 
example,  a  student  may  be  having  trouble  with 
d i v i s i on  because  he  does  not  know  how  to  multiply 
and/or  s u b t r a c t.  The  CAI  monitor  must  recognize 
t h is  and  r e d i r e ct  the  student's  e f f o r ts  or  he  w i ll 
never  master  the  d i v i s i on  algorithm. 

For 

This  problem,  of  course, 

is  even  harder  to  r e(cid:173)
language  systems.  None  of  these 

solve  in  natural 
systems  currently  have  an  e f f e c t i ve  way  of  adapting 
the  t u t o r i al  dialogue  to  e x p l o it  the  information 
present 

in  an  incorrect  student  response. 

87 

Problem-Solving  in  CAI 

A  f i n al  probleiti  area  is  pertinent  to  researchers 
in  a  problem-solving 

attempting  to  use  generative  CAI 
environment. 
solver  i t s e l f.  Perhaps  current  research  in  problem-
solving  and  planning  techniques  such  as  are  evidenced 
in  STRIPS  and  in  languages  such  as  PLANNER12  and 
QA413  w i ll 

is  the  design  of  the  problem-

f i nd  application 

in  t h is  area. 

This 

A  generative  CAI  system  has  been  designed  around 

Two-thirds  of 

an  introductory  course  in  computer  science  at  the 
University  of  Connecticut. 
is  concerned  with  an  introduction  to  d i g i t al  logic 
design; 
the  remainder  of  the  course  teaches  machine-
language  programming.  An  algorithmic  approach  has 
been  used  to  teach  the  concepts 
design  through  CAI.  The  s p e c i f ic  approach  taken  has 
been  described  elsewhere1  . 

in  d i g i t al 

t h is  course 

logic 

The  software  portion  of  the  course  Is  concerned 
language 
to  the 

with  teaching  students  how  to  w r i te  machine 
programs  for  a  small  computer,  very  s i m i l ar 
D i g i t al  Equipment  Corporation  PDP-8. 
set  and  organization  are 
i d e n t i c a l; 
the  only  difference 
is  that  student  programs  are  r e s t r i c t ed  to  pages  0  and 
1  of  memory. 
core  which  is  s u f f i c i e nt 
to 
learn  to  program  (and  also  to  learn  p r i n c i p l es  of 
memory  conservatIyn). 

This  consists  of  377  ( o c t a l)  words  of 

for  beginning  students 

The  i n s t r u c t i on 

The  CAI  system  Its  not  used  to  replace  the  classes 

It 

Is 

intended  to  provide  practice  and 

or  textbook. 
t u t o r i ng  in  problem  solving  similar  to  what  one  would 
obtain 
course, 
and  remedial  feedback  when  he  goes  astray. 

through  homework  problems.  The  advantage, of 
is  that  the  student  gets  some  guided  d i r e c t i on 

it 

i ts  own  solution  programs. 

Since  the  system  is  generative  and  problems  are 
is  necessary  that 

constructed  in  a  random  fashion, 
it  also  be  able  to  write 
There  has  been  s i g n i f i c a nt  e f f o rt  expended  in  the 
development  of  programs  with  t h is  c a p a b i l i t y. 
work  by  Simon14  has  been  reported.  Recent  e f f o r ts 
by  Manna  and  Waldinger15  emphasise  a  theorem  proving 
approach  to  w r i t i ng  programs. 
f e lt  that  t h is 
general  approach  would  not  allow  programs  which 
emphasize 
programming  to  be  designed. 

the  r e q u i s i te  techniques  of  machine-language 

It  was 

Early 

The  remainder  of  the  paper  w i ll 

h e u r i s t ic  approach  to  automatic  programming. 
system  so  designed  w i ll  be  referred  to  as  MALT 
(MAchine  Language  Tutor). 

focus  on  our 
The 

I I.  System  Overview 

Prior  to  describing 

the  system  i t s e l f, 

it  would 

It  was 

important  that  t h is  system  function 

be  worthwhile  to  o u t l i ne  some  of  i ts  goals  and  con(cid:173)
s t r a i n t s. 
e f f e c t i v e ly  as  a  t u t or  in  machine  language  programming 
f or  approximately  t h i r ty  students  per  semester,  rather 
than  just  serve  as  a  demonstration  of  what  might  be 
accomplished 
if  a d d i t i o n al  computer  resources  were 
a v a i l a b l e.  This  meant  that  MALT  had  to  be  implemented 
on  the  time-sharing  system  currently  available  on  the 
U n i v e r s i t y 's  IBM  360/65  which  is  CPS  (Conversational 
Programming  System-IBM16),  a  d i a l e ct  of  P L - I. 
also  meant  that  response  times 
normally  be  on  the  order  of  5  to  10  seconds  or  less. 
An  a d d i t i o n al  r e s t r i c t i on  imposed  by  CPE  i t s e lf  was 
that  no  more  than  twelve  pages  (U8K  bytes)  of  core 
memory  be  active  at  any  user  terminal. 

It 
to  students  should 

A  second  goal  of  t h is  system  was  that 

it  be 

easily  expandable. 

This  means 

it  should  be  possible 

to  add  new  problem  types  without  having  to  increase 
the  system's  problem  solving  c a p a b i l i t y, 
This  f a c t o r, 
and  the  requirement  f or  a  compact  or  modular  structure 
in  order  to  meet  the  twelve  page  core  l i m i t,  resulted 
in  the  use  of  p r i m i t i ve  tasks  to  serve  as  b u i l d i ng 
blocks 

in  the  design  of  s o l u t i on  programs, 

A  t h i rd  goal  was  t h at  the  system  be  capable  of  a 
high  degree  of  i n d i v i d u a l i z a t i on  of  i n s t r u c t i o n. 
The 
form  of  the  problem  posed  for  each  student  should  be 
influenced  by  his  previous  experience  with  the  system. 
The  degree  of  monitoring  should  decrease  as  the  s t u(cid:173)
dent's 
system  should  assist  the  student  by  programming 
previously  mastered  sub-tasks 

l e v el  of  competence  increased; 

in  f a c t,  the 

for  him. 

I I I.  General  Approach 

A  generative  CAI  system  has  the  minimum  compo(cid:173)

The  problem  generator-

nents  i l l u s t r a t ed  in  Figure  1. 
is  capable  of  providing  an  unlimited  variety  of 
meaningful  problems.  A  v i t al  information  l i nk 
exists  between  the  problem  generator  and  problem 
Solver. 
structure  of  the  problem,  and  allows  the  problem 
solver  to  concentrate  on  the  s o l u t i on  of  the  problem 
rather  than  i ts  d e f i n i t i o n. 

This  l i nk  provides  the  system  with 

the  exact 

The  structure  of  each  problem  is 

i l l u s t r a t ed 

input  of  i n f o r m a t i o n,  processing 

(I 
the  set  of  input  sub-problems  where 

There  are  several  a l t e r n a t i v es  for  each 
I  } 

by  the  AND-OR  goal  tree 
in  Figure  2.  A  complex 
programming  problem  is  represented  as  three  sub-
problems  dealing  with 
of  core-resident  information,  and  program  output 
respectively. 
of  the  sub-problems. 
is 
in  t u r n,  is  decomposed 
sub-problem.  Each  sub-problem, 
i n to  a  sequence  of 
l o g i c al  tasks.  Some  of  these  tasks 
are  p r i m i t i ve  tasks  which  the  system  can  solve  d i r e c t ly 
in  one  or  more  ways  (1 
tasks  consist 
tasks  (i  , ). 

themselves  of  a  sequence  of  p r i m i t i ve 

and  I-,-).  Other  l o g i c al 

, 
the  n u ll 

For  example, 

,  I 
I , is 

. . ., 

ID 
There  are  t h i r t y - f i ve  p r i m i t i ve 

tasks  program(cid:173)

system  feels  that  the  student  might  benefit 
observing  his  program  in  operation, 
c a p a b i l i ty  to  simulate  statement  by  statement  program 
execution. 

it  also  has 

from 

the 

The  system  is  constantly  evaluating  the  student's 

performance  and  updating  his  permanent  f i l e. 
This  is 
necessary  because  his  achievement  determines  not  only 
the  d i f f i c u l ty  of  the  problems  given  him,  but  also  the 
amount  of  i n t e r a c t i on  which  he  receives  during  the 
design  of  his  program. 

It  should  be  stressed  at  t h is  point 

that  the 

system  can  only  solve  the  p r i m i t i ve  tasks.  Complex 
problems  can  be  constructed  using 
ing  blocks. 
tasks  and  t h e ir  r e l a t i o n s h i ps 
the  s o l u t i on  f or  the  complete  programming  problem. 

The  system's  knowledge  of  the  p r i m i t i ve 
to  generate 

enables 

tasks  as  b u i l d(cid:173)

these 

it 

As  is 

indicated  by  the  above  discussion,  the  l o g ic 

sequence  which  the  system  w i ll  use  to  code  the  problem 
is  p r e t ty  w e ll  determined  by 
i ts 
The  only  freedom  that  exists  is 
code 

implied  s t r u c t u r e. 
in  the  selection  of  the 

to  implement  each  p r i m i t i ve  task. 

This 
function 

is  p e r f e c t ly  satisfactory 

for  a  system  whose 

sole 
is  to  produce  the  machine-language  code 
which  accomplishes  a  p a r t i c u l ar  programming  problem. 
However,  t h is  approach  should  be  j u s t i f i ed  in  a  CAI 
environment. 

in 

i ts  e n t i r e t y,  derive 

There  are  normally  many  ways  to  flowchart  and 
code  a  programming  problem.  The  system  could  accept 
the  student's  s o l u t i on 
own  s o l u t i on  program,  execute  both  programs,  and  com(cid:173)
pare  t h e ir  r e s u l t s.  Such  an  approach,  although  it 
would  give  the  student  complete  freedom  and  v e r i fy  his 
program,  would  be  worthless  as  a  teacher.  E s s e n t i a l l y, 
it  would  say  to  the  student  who  has  made  a  mistake: 
"Your  answer  is  wrong,  but  I  have  no  idea  why.  Here 
is  my  s o l u t i o n;  perhaps  you  can  f i g u re  out  what  is 
wrong  y o u r s e l f ."  A  student  who  can  do  t h is  does  not 
r e a l ly  need  a  CAI  t u t o r. 

i ts 

i n i t i a l i z a t i on  of  pointers 

med  in  MALT.  They  would  be  used  repeatedly  in  the 
design  of  a  complete  program.  Sample  tasks  might  be: 
the 
i n i t i a l i z a t i on 
of  counters 
a t i o n s; 
t r a n s f e r r i ng  data  i n to  and  out  of  memory.  A  large 
v a r i e ty  of  problems  can  be  constructed  using  only 
t h is  set  of  p r i m i t i ve  tasks. 

track  of  the  number  of  loop  i t e r(cid:173)
reading  or  p r i n t i ng  an  ASC-II  character;  and 

to  data, 

to  keep 

Figure  3  is  a  block  diagram  f or  the  MALT 

system.  The  previous  student  performance  determines 
what  type  of  problem  w i ll  be  generated.  This  problem 
is  presented  to  the  student 
in  n a t u r al  language  and 
also  passed  on  to  the  system  as  an  ordered  t r i p le  of 
sub-problems.  Next,  a  l i st  of  l o g i c al  tasks 
of  the  sub-problems 
system  representation  of  t h is  " f l o w - c h a r t" 
uence  of  c a l ls  to  problem-solver  routines. 
problem-solver  routines  solve  the  programming  problem 
and 
i n t e r a ct  with  the  student  to  monitor  his  s o l u t i o n. 

is  presented  to  the  student. 

is  a  seq(cid:173)
These 

for  each 
The 

As  the  student  undertakes  each  task  in  the 

programming  process,  a  corresponding  problem-solver 
routine  is  entered  by  the  CAI  system,  which  guides 
the  student  through  the  construction  of  that  part  of 
his  program.  During  t h is  phase,  the  student 
constantly  being  given  feedback  as  to  the  correctness 
of  his  program. 
e r r o r s,  the  system  w i ll  point  these  out  and  o f f er 
If  the 
h e l p f ul  suggestions 

introduces  l o g i c al 

t h e ir  c o r r e c t i o n. 

If  his  program 

for 

is 

The  approach  we  have  taken  is  to  say: 

"You  are 
j u st  learning  how  to  code  in  machine  language.  Your 
problem  can  be  flowcharted  in  t h is  way. 
If  you  w i ll 
follow  my  f l o w c h a r t,  I  can  teach  you  something  about 
machine-language  coding,"  We  f e el  (and  so  do  our 
student  guinea  pigs)  t h at  the  beginning  student  gains 
more  from  a 
l i t t le  guidance  at  t h is  stage  and  learns 
quite  a  b it  about  flowcharting  through  observation. 

Perhaps,  current  research  in  program  synthesis 

and  v e r i f i c a t i on  w i ll  soon  remove  t h is  r e s t r i c t i o n. 
It  would  then  be  preferable  to  allow  the  student 
to 
design  his  own  program  to  the  extent  he  is  able.  The 
system  could  v e r i fy  t h at  the  portion  of  the  program 
constructed  so  f ar  does, 
student  intended.  At  t h is  p o i n t, 
take  over  and  synthesize  the  remainder  of  the  s o l u t i o n. 
If  the  student's  p o r t i on  of  the  s o l u t i on  were  only 
p a r t i a l ly  c o r r e c t,  the  point  at  which  his  program  went 
astray  could,  perhaps,  be  located  and  the  correct 
s o l u t i on  continued  from  there. 

in  f a c t,  accomplish  what  the 

the  system  would 

IV.  Problem  Generator 

As  has  been  mentioned,  each  problem  may  be 

thought  of  as  consisting  of  three  (or  less)  d i s t i n ct 
phases.  When  students  f i r st  s t a rt  o ff  using  the 
system,  they  w i ll  normally  be  presented  w i th  a  problem 
that  consists  of  j u st  a  single  phase.  As  they  gain 
competence  and  experience,  more  d i f f i c u lt  problems  w i ll 
be  generated  for  them. 

88 

Problem  generation  consists  of  selecting  a 

pa"Uh  through  a  tree  of  depth  three  as  shown  in  Figure 
4.  Branches  A1  through  A7  consist  of  the  seven  strings 
(including  the  n u ll  s t r i n g)  describing  the  input  sub-
problems.  B 
processing  steps 
can  be  performed  on  the  input  format  described  by 
A,. 
the  output 
sub-problem  (out  of  a  t o t al  of  10)  for  a  problem 
beginning  with  A  and  B 

(out  of  a  t o t al  of  t h i r t e e n)  which 

are  the  three  meaningful 

t l ie  possible 

forms  of 

c^i2  are 

Cj i ji 

,  B 

,  B 

. 

is  a 

The  p r o b a b i l i ty  of  a  p a r t i c u l ar  branch  being 
selected 
function  of  each  student's  competence. 
These  p r o b a b i l i t i es  change  as  the  student  progresses 
through  the  course  m a t e r i a l.  There  are  more  than  HO 
d i f f e r e nt  paths 
t h is  tree  which  represent 
meaningful  problems.  Before  presenting  a  problem 
format  (or  path)  which  has  been  .selected,  the  system 
checks 
viously  worked  by  t h is  student. 

is  " d i f f e r e n t"  from  one  pre(cid:173)

to  see  that 

through 

it 

In  a d d i t i o n,  once  the  format  has  been  selected, 
various  parameters  must  be  randomly  generated.  These 
parameters  might  represent  specific  memory  registers 
or  character's  to  be  searched  f o r.  The  complete 
problem  is  described 
i n t e r n a l ly  a?,  a  vector  consist(cid:173)
ing  of  the  three  selected  brandies  from  the  problem 
tree  followed  by  a ll  required  parameters.  Sample 
problems  are  shown  in  Table  1. 

TABLE  1 

Sample  Problems 

Note:  A ll  Randomly  Generated  Parameters  Are 

Underlined. 

1.  Add  the  contents  of  register  150  to  the  cunten U; 

of  r e g i s t er  167. 

2.  Print  out 

the  message  " H e l l o ". 

3.  Read  in  a  series  of  ASCJ-.I1  character's  ending  w i th 

a  *  and  store  them  starting,  in  location  11?_Q_. 

4.  Read  in  31  A'SC-Il  characters  and  store  them 

s t a r t i ng  at  i o c a t i on  300.  Search  register  3Q0_ 
through  330  for  the  largest  number. 

b.  Read  in  a  series  of  3-digit  numbers  and  store 
them  s t a r t i ng  at  location  25Q.  The  input  w i ll 
end  when  the 

f i r st  character  of  a  number1  is  a  "X". 

6.  Read  in  24 

( o c t a l) 

four  d i g it  numbers  and  store 
iocation  242.  Search  registers 

them  s t a r t i ng  at 
242  t h ru  265  for  the  1st  number  which  begins 
with  the  ocTal  d i g i ts  "7£". 

(Example  7QXX) 

7.  Multiply  the  contents  of  r e g i s t er  211  by  the  con(cid:173)

tents  of  r e g i s t er  310. 
4 - d i g it  contents  of 

F i n a l ly  p r i nt  out 

the 

the  Accumulator. 

8.  Search  registers  160  thru  20^5  for  the  octal 

number  7215.  For  r e g i s t e rs  16_0  t h ru  205^  p r i nt 
out  the  r e g i s t er  number,  4_  spaces,  and  the  octal 
contents  of 

that  r e g i s t e r. 

9.  Assume  that  a  table  has  been  set  up  s t a r t i ng  at 
l o c a t i on  120  consisting  of  a  2-character  symbol 
followed  by  a  number-,  there  are  W_  of  these 
e n t r i e s. 
Search  the  table  f or  the  symbol  "AN"  and  r e t r i e ve 
the  corresponding  number. 
If 
t a b l e,  then  h a lt  the  program. 
the  4 - d i g it  contents  of  the  Accumulator. 

it 
F i n a l l y,  p r i nt  out 

in  the 

is  not 

The  next  step  is  to  generate  the  corresponding 

l i st  of  l o g i c al  sub-tasks.  These  are  generated 
separately  for  each  of  the  three  major  phases  of  the 
problem.  An  example  is  shown  in  Table  2.  As  mentioned 
above,  the  student  solution  would  be  monitored  after 
the  generation  of  a ll  the  sub-tasks  associated  with 
each  phase  of  the  problem. 

TABLE  2 

EXAMPLE  Or  PROGRAM  SUB-TASK  GENERATION 

YOUR  PROBLEM  IS  To  WRITE  A  PROGRAM  WHICH  WILL; 

a)  Read  in  20  ( o c t a l)  ASCII  characters  and  store  them 

in  registers  240  t h ru  ?f>0. 

b)  Form  the  absolute  value  of  the  contents  of  register 

24 0  in  the  Accumulator. 

cl 

F i n a l l y,  p r i nt  out 
Accumulator. 

the  4 - d i g it  contents  of  the 

Here-  are  the  subt.asks  for  a. 

I n i t i a l i ze  a  ptr  to  r e g i s t er  240. 
I n i t i a l i ze  a  c tr  with  the  value  of  -20  ( o c t a l ). 

1) 
2) 
3)  Read  a  character, 
4)  Store 
5)  Update 
0)  Update 

it  away  using  the  ptr-. 
the  p t r. 
the  c tr  and  if  i t 's  not 

;;,cro, 

jump  back 

to 

s t a rt  of 

loop, 

here  are 

the  sub-tasks 

for  b. 

J)  Bring  the  number 
2)  Check  the  sign  of  the  ACC  and 
i t 's  2's  complement. 

in  r e g i s t er  240 

then  form 

I."  the  Accumulator. 

if  i t 's  negative, 

Here  are  the  sub-tasks  f or  c. 

1)  Store  the  contents  of 
2)  Set  up  a  subroutine  which  w i ll  p r i nt  a  character, 
the  number  to  be  printed  and  rotate  it  so  the 
3)  Get 

the  Aecumul.-it.ur 

temporarily. 

1st  (or  leftmost)  octal  digit" 

is  on  the  r i g h t. 

4)  Mask  out  the 

l e fr  q  b i t s,  add  260,  and  c a ll  the 

p r i nt  subroutine, 

5)  Do  the  same  f or  the  2nd  d i g i t, 
b)  Do  the  same  for  the  3rd  d i g i t. 
7)  F.et  the  number,  mask 

i t,  add  260,  and  p r i nt  i t. 

t h i r t y - f i ve  p r i m i ' i ve 

The  system  representation  of  these  sub-tasks  con(cid:173)
This  sequence 

s i s ts  of  a  s t r i ng  of  two  d i g it  numbers. 
indicates  which  of  the 
TtiHchine  language  programming  muct  be  performed,  and  in 
what  order,  to  program  each  sub-problem  c o r r e c t l y. 
I n t e r p r e t a t i on  of  t h is  s t r i ng  by  the  control  routine 
results 
the  i n d i v i d u al  prob-
lem-soxver  routines.  The  manner  in  which  the  problem-
t.olvers  monitor  the  machine  code  being  entered  by  the 
student  w i ll  be  described  next. 

in  a  sequence  of  calls 

tasks  of 

to 

V.  Problem  Solver  and  Monitor 

Each  of  the 

l o g i c al  sub-tasks  is  broken  down 

f u r t h er  i n to  a  sequence  of  p r i m i t i ve  tasks  (35  t o t a l) 
which  the  system  can  solve.  The  student  builds  his 
solution  by  coding  one  task  at  a  time  as  Implied  by 
Figure  2. 

The  system  provides  the  student  with  varying 

degrees  of  i n t e r a c t i on  depending  on  his  past  performance. 

89 

A  beginning  student  w i ll  be  led  by  the  hand  and  each 
program  statement  w i ll  be  requested  and  checked 
i n d i v i d u a l l y.  An  intermediate  student  receives  fewer 
hints  and  w i ll  normally  enter  a  group  of  statements 
at  a  time;  an  advanced  student  benefits  from  the 
system's  a b i l i ty  to  code  i ts  own  programs  and  w i ll  be 
provided  with  the  code  for  the  simpler  sub-tasks. 
This 
is  important  as  it  frees  him  to  concentrate  on 
more  d i f f i c u lt  areas  and  prevents  the  boredom  which 
would  r e s u lt 

from  constant  r e p e t i t i on  of 

t r i v i al  tasks. 

Table  3  provides  an  example  of  the  problem 

solver/monitor  i n t e r a c t i on  with  a  student. 
square-bracketed  comments  have  been  added  for  c l a r i t y. 
Each  underscore  indicates  the  s t a rt  of  a  student 
response.  M377  stands  for  memory  r e g i s t er  377.  The 
system  is  operating  at  a  moderate  degree  of  i n t e r(cid:173)
a c t i o n. 

The 

TABLE  3 

EXAMPLE  OF  STUDENT  INTERACTION 

Your  problem  is  to  w r i te  a  program  which  w i l l: 
Read  in  10  ( o c t a l ),  1-digit  numbers  and  store  t h e ir 
value  s t a r t i ng 

in  r e g i s t er  205. 

Is  t h is  problem  OK? 
yes 

for  the  1st  l i n e: 
I n i t i a l i ze  a  pointer  to  r e g i s t er  205, 
I n i t i a l i ze  a  counter  w i th  the  value  of  -10  ( o c t a l ). 

Here  are  the  sub-tasks 
1) 
2) 
3)  Read  a  d i g it  and  mask  out  the  l e ft  9  b i t s. 
4)  Store 
5)  Update 
S)  Update 

it  away  using  the  p o i n t e r. 
the  pointer 
the  counter  and  if  i ts  not  zero, 

jump 

back 

to  s t a rt  of  loop. 

SUB-TASK  1: 
Use  M377  to  store  the  pointer  value,  and  M376  as  the 
pointer. 
M377: 
105 
Wrong! 

"0205"  is  the  correct  p tr  value. 

[user  program  s t a r ts  in  r e g i s t er  1] 

[ c l e ar  the  ACC] 

M001: 
7200 
M002: 
1377  [get  the  value  of  the  pointer] 
M003: 
3376 

i n to  p o i n t e r] 

[deposit 

SUB-TASK  2: 
Use  H375  to  store  the  counter  value  and  M374  as  the 
counter. 
M375: 
0012 
"0012"  can't  be  used  as  the  counter  value. 
be  either  "0010"  or  "7770".  Try  again! 
M375: 
7770 
Now  set  the  counter  value  i n to  the  counter. 
M004: 
7200  [clear  the  ACC] 
You  don't  need  a  "CLA"  here  but  i t 's  ok. 
M005: 
1375 
M006: 
3374 

[set  up  the  c t r] 

It  should 

SUB-TASK  3: 
Y o u ' ll  need  3  i n s t r u c t i on  to  read  a  character. 
M007: 
6031  [check 

the  keyboard  f l a g] 

90 

M010: 
5_007  [Jump  to  M007] 
M011: 
6036  [Read  a  keyboard  Char.] 

Let's  store  the  mask  in  M373 
What  number  should  we  use  as  a  mask? 
M373: 
£077 
Wrong!  "0007" 
contain  a  " 1"  corresponding  to  every  b it  of  the 
Accumulator  we  would  l i ke  to  Keep. 

is  the  correct  mask  because 

it  should 

Now,  "AND"  the  ACC  with  the  mask. 
M012: 
£373  ["AND"  the  ACC] 

SUB-TASK  4: 
M013: 
task] 

3776  [system  generates  code  f or  easy  sub-

SUB-TASK  5: 
M014: 
2377 
Wrong! 
2376. 

[increment 

the  p o i n t e r] 

The  p tr  is 

in  M376  so  "ISZ  PTR"  should  be: 

[increment  the  counter!] 

SUB-TASK  6: 
M015: 
2374 
M016: 
5005  [Jump  to  MOOS] 
Wrong! 
should  be: 

"5007". 

the  body  of  the  loop  begins 

in  M007  so  it 

Now  we  should  halt  the  program 
M017:  7402 

Several  conventions  have  been  established  to 
f a c i l i t a te  the  generation  of  program  segments  and 
monitoring  of  student  programs.  A ll  user  programs 
begin  in  location  001  and  a ll  program  constants  are 
placed  at  the  top  of  memory  beginning  with  location 
377  and  preceeding  downwards.  The  middle  areas  of 
memory,  locations  120  through  350,  are  reserved  f or 
l i s ts  and  tables  to  be  used  by  the  student's  program. 

The  existence  of  a  program  loop  is  assumed  by  the 

is 

i n i t i a l i z e d. 

is  the  f i r st  memory 

i n i t i a l i z a t i on  process. 

system  whenever  a  pointer  or  counter 
The  physical  s t a rt  of  the  loop 
r e g i s t er  a f t er  the 
monitoring  the  beginning  of  a  loop  in  t h is  manner, 
the  system  can  easily  determine 
the  student  has 
c o r r e c t ly  designed  his  end-of-loop  decision  sequence. 
The  most  common  programming  mistake  of  t h is  kind 
occurs  when  the  student  attempts  to  jump  back  to  the 
i n i t i a l i z a t i on  sequence  instead  of  the  main  body  of 
the  loop. 

By 

if 

Another  program  parameter  which  must  be  kept 

The  simulated 

track  of  is  the  accumulator  s t a t u s. 
computer  has  neither  a  non-destructive  deposit  nor  a 
destructive  load  i n s t r u c t i o n.  Hence,  the  accumulator 
must  be  cleared  p r i or  to  loading  it  with  a  given 
number  and  must  be  reloaded  a f t er  a  number  has  been 
deposited  in  memory  if  the  number  is  s t i ll  needed. 
The  status  of  the  accumulator  is  going  to  determine 
which  of  several  a l t e r n a t i v es  is  to  be  pursued  by 
c e r t a in  of  the  problem-solver  routines 
and  checking  of  a  program  segment. 

in  the  design 

A  complicating  f a c t or  in  determining  accumulator 

status 
program  jumps.  The  accumulator  status  may  d i f f er 

is  the  existence  of  l o g i c al  branching  or 

depending  on  whether  a  sub-task  was  entered  sequenti(cid:173)
a l ly  or  through  a  program  jump. 

Forward  jumps  to  yet  unprogrammed  sub-tasks  also 

present  a  problem,  as  the  memory  location  in  which 
the  new  sub-task  s t a r ts  is  not  yet  known.  Conseq(cid:173)
uently,  HALT  keeps  track  of  the  f i r st  memory  location 
of  each  sub-task. 
If  a  jump  is  made  to  a  previously 
programmed  sub-task, 
instruction  is  pro(cid:173)
vided  immediately. 
note  is  made  of  the  memory 
i n s t r u c t i on  belongs  and  the  sub-task  to  be  reached. 
When  t h is  sub-task  is  f i n a l ly  programmed,  HALT  com(cid:173)
pletes  a ll  p r i or 
i t. 

In  the  case  of  forward  jumps,  a 

instructions  which  reference 

location  in  which  the  jump 

the  required 

jump 

There  are  two  important  techniques  used  by  the 
MALT  system  to  judge  the  correctness  of  a  student's 
program.  The  most  common  method  is  to  analyze  in 
is  typed  i n, 
d e t a il  each  segment  of  the  program  as  it 
to  determine 
functions. 
the  required 
This  is  done  on  an  i n s t r u c t i o n - b y - i n s f r u c t i on  basis 
so 
feedback  to  the  student. 

that  there  is 

it  performs 

immediate 

if 

implies  that 

Immediate  v e r i f i c a t i on 

the  system 
must  have  a  detailed  knowledge  of  the  status  of  the 
user's  program  at  a ll  times.  As  the  student  formu(cid:173)
lates  each  response, 
the  system  also  generates  what 
it  considers  to  be  an  appropriate  answer. 
do  not  match,  the  system  must  determine  if  other 
responses  are  possible. 
If  so,  the  student's  answer 
is  compared  w i th  all  such  reasonable  p o s s i b i l i t i e s. 
When  the  system  f i n a l ly  decides  that  the  response 
supplied  by  the  student 
as 
the  best  program  a l t e r n a t i v e. 

it  informs  him 
to  the  reason  for  t h is  determination  and  supplies 

in  error', 

is 

If  the  two 

If  the  student's  response  matches  any  of  those 
which  the  system  generated,  then  it  is  accepted  by 
the  system  as  a  v a l id  a l t e r n a t i ve  to  i ts  own  s o l u t i o n. 
Since  t h is  was  not  the  expected  r e s u l t,  however, 
the  system  must  adjust 
i ts  representation  of  the 
users  program  status 

to  r e f l e ct  the  new  conditions. 

In  the  rare  event  that  there  are  too  many  accep(cid:173)

the 

is  simulated 

i ts  correctness.  To  v e r i fy  the  user's 

table  ways  to  program  a  p a r t i c u l ar  sub-task, 
program  segment  supplied  by  the  student 
to  determine 
program  through  s i m u l a t i o n,  a ll  conditions  of  the 
machine  which  might  possibly  affect 
f i n al  program 
r e s u l ts  are  determined.  For  example, 
is 
ing  upon 
then  only  two  i n i t i al  states  are  necessary; 
the  pro(cid:173)
gram  is  tested  with  a  zero  Link  and  again  l a t er  with 
a  non-zero  Link, 

if  the  program 
intended  to  perform  a  p a r t i c u l ar  operation  depend(cid:173)

the  status  of  the  overflow  l i nk  r e g i s t e r, 

Once  the  various 

i n i t i al  states  have  been  deter(cid:173)

mined,  the  program  segment  can  be  simulated  under 
each  c o n d i t i o n.  The  system  decides,  following  each 
s i m u l a t i o n, 
if  normal  program  termination  occurred. 
Conditions  which  might  cause  abnormal  termination 
are  such  things  as  i n f i n i te  loops,  undefined  instruc(cid:173)
t i o n s,  or  program  branches  which  are  directed  outside 
the  user's  program  segment.  Any  such  conditions  are 
corrected  immediately  by  the  student,  the  current  set 
of 
t i on  is  attempted  again. 

is  r e - e s t a b l i s h e d,  and  simula(cid:173)

i n i t i al  conditions 

If  any  p a r t i c u l ar 

terminal  condition 

indicates 

t h at  the  user's  program  did  not  perform  i ts 
c o r r e c t l y,  MALT  attempts  remedial  a c t i o n.  Since 
it 
been  obtained, 

is  aware  of  the  exact  r e s u l ts  which  should  have 

it  can  provide  a  concise  description 

function 

i s o l a te  the 

It  cannot,  however, 

of  the  e r r o r. 
location  of  the  error  in  the  user's  program. 
This 
determination  must  be  l e ft  up  to  the  student.  How(cid:173)
ever,  the  problem  has  been  greatly  s i m p l i f i ed  due  to 
the  system's  diagnostics  and  the  user's  a b i l i ty 
observe  his  program  in  execution. 
is  unable  to  correct  his  program  segment,  MALT  w i ll 
generate  a  correct  program  segment  f or  him. 

to 
If  the  student 

V I.  Conclusions 

The  system  has  been  implemented  in  the  CPE  (16) 

language  on.  the  IBM  360/65  at  the  University  of 
Connecticut  Computer  Center.  Students  can  use  t h is 
system  whenever'  they  desire.  There 
is  also  a  batch-
mode  simulator  of  t h is  computer  which  they  use  f or 
class  projects  of  a  more  ambitious  nature. 

Student  reaction  to  MALT  has  been  very  favorable. 

f e el  t h is  system  helps  to  bridge  the  gap 

They 
between  what  they  have  learned  in  class,  of 
textbook,  and  what  they  need  to  know  to  program 
independently 

in  batch-mode. 

from  the 

This  past  semester,  students  spent 

two  weeks  using 

HALT  and  were  then  given  a  week  to  get  a  rather  size(cid:173)
able  problem  coded  and  running  in  batch-mode.  All 
but  one  student  managed  to  accomplish  t h i s. 

It  appears 

tabulated 
f e el  that 

A  questionnaire  was  d i s t r i b u t ed  to  the  class. 
in 

The  results  of  t h is  questionnaire  are 
Table  4. 
that  the  students 
t h is  experience  was  b e n e f i c i al  and  good  preparation 
for  learning  to  program  independently.  On  the  whole, 
students  were  not  bothered  by  the  fact  that  MALT 
requires 
As 
improvements  must 
be  made  to  the  algorithm  which  determines  that  a 
generated  problem 
from 
previous  problems  presented  to 

them  to  adhere  to  a  p a r t i c u l ar  "flowchart". 

Indicated  by  question  seven, 

is  s u f f i c i e n t ly  d i f f e r e nt 

that  student. 

TABLL'  4 

Student  Evaluation 

for  questions  1-9  the  numbers  of  students  giving  the 
following  responses  are  tubulated. 

Strongly 
Disagree 

disagree  Uncertain  Agree 

strongly 
Agree 

1.  The  system  was  useful  in  introducing  me  to 

machine  language  programming. 
18 

2 

1 

12 

2. 

It  was  r e l a t i v e ly  easy  to  learn  to  Use  the  batch 
version  of  the  assembler  since  I  had  been  i n t r o(cid:173)
duced  to  programming  concepts  through  MALT. 
0 

15 

5 

4 

7 

3.  since 

the  sub-tasks  were  always  laid  out  for  me, 

1  felt  very  constrained  using  MALT. 
0 

19 

9 

5 

0 

4.  Because 

the  sub-tasks  were  l a id  out, 

I  only 

learned  the  mechanics  of  programming  and  d i d n 't 
r e a l ly  understand  what  was  going  on. 
1 

16 

5 

2 

8 

5.  The  approach 

taken  in  p r i n t i ng  out  the  sub-tasks 

was  good  as  it  taught  me  how  to  organize  a 
machine-language  program. 
0 

20 

7 

4 

2 

91 

10.  Koffman,  E.  B.,  "A  Generative  CAI  Tutor  f or 

Computer  Science  Concepts,"  Proceedings  of  the 
AFIPS  1972  Spring  Joint  Computer  Conference. 

1 1.  Goldberg,  A,  and  Suppes,  P.,  "A  Computer-

Assisted 
r i n d i ng  Axioms," 
U n i v e r s i t y, 
In  the  Social  Sciences,  June,  1972. 

I n s t r u c t i on  Program  for  Exercises  on 
Tech.  Report  #186,  Stanford 
for  Mathematical  Studies 

I n s t i t u te 

12.  Hewitt,  C.,  "Planner; 

ft  Language  f or  Proving 
Theorems  in  Robots,"  Proceedings  of  the  1369 
International  Joint  Conference  on  A r t i f i c i al 
I n t e l l i g e n c e,  Ed,  D.  E.  Walker  and  L.  M.  Norton, 
1969,  pp.  295-302. 

13.  Rulifsan,  J.  F,  Derksen, 

J.  A.  and  Waldinger, 

R.  J .,  "QA4:  A  Procedural  Calculus  f or 
Inductive  Reasoning,"  SRI  Technical  Note 
#73,  1972. 

14.  Simon,  H.  A.,  "Experiments  with  a  Heuristic 

Compiler,"  1963,  JACM,  V o l.  10,  No.  4, 
October  1963. 

15.  Manna,  Z .,  Waldringer,  R.  J .,  "Toward  Automatic 

Program  Synthesis,"  CACM,  V o l.  14,  No.  3, 
March,  1971. 

16. 

IBM  Corporation,  Conversational  Programming 
System,  (CPS)  Terminal  User's  Manual,  IBM  Report 
GH20-0758-0  1970. 

6.  The  problem  became  more  d i f f i c u lt  as  my  l e v el 

increased, 
1 

3 

7 

19 

3 

7.  There  was  a  good  variety  in  the  problems  I 

received  in  MALT. 
1 

12 

6 

13 

S. 

9. 

In  general, 
0 

I  enjoyed  the  i n t e r a c t i on  with  MALT. 
3 

21 

6 

3 

I  preferred  the  use  of  CAI 

In  general, 
course  to  conventional  homework. 
0 

2 

4 

11 

16 

in  t h is 

Overall  .  we  feel  that  MALT  is  an  e f f e c t i ve 

It  should  be 

demonstration  of  what  can  be  accomplished  in  CAI 
with  the  l i m i t ed  use  of  AI  techniques. 
stressed  t h at  MALT's  design  has  been  influenced  by 
AI  research,  but  c e r t a i n ly  much  more  could  be  done 
in  the  way  of  incorporating  AI  Research  in  problem 
solving  and  program  synthesis.  The  desire  to 
produce  a  working  system  with  reasonable  response 
time  on  an  e x i s t i ng  time-sharing  system  precluded 
t h is  p o s s i b i l i t y.  Hopefully,  MALT  w i ll  challenge 
others  w i th  an  i n t e r e st  in  CAI  and  AI  to  pursue  t h is 
goal 

f u r t h e r. 

REFERENCES 

1.  Wexler,  J.  D.,  "Information  Networks  in  Generative 

Computer-Assisted  I n s t r u c t i o n ," 
IEEE  Trans. 
on  Man-Machine  Systems,  V o l.  MMG-11,  No.  4, 
December  1970,  pp.  181-190. 

2.  Carbonell,  J.  R.,  "AI  in  CAT:  An  A r t i f i c i al 
Intelligence  Approach  to  Computer-Assisted 
IEEE  Transactions  on  Man-Machine 
I n s t r u c t i o n ," 
Systems,  V o l.  MMS-11,  No.  4,  Dec.  1970,  pp.  190-
202. 

3.  Carbonell,  J.  R.,  " A r t i f i c i al 

Intelligence  and 

Interactive  Man  Computer  Systems,"  Proc. 

Large 
of  the  1971  Joint  National  Conference  on  Major 
Systems. 

4.  Carbonell,  J.  R.,  and  C o l l i n s,  A.  M.,  "Natural 
Semantics  in  A r t i f i c i al  I n t e l l i g e n c e,  "  Bolt 
Beranek  and  Newman  Working  Paper,  March,  1973. 

5.  Simmons,  R.  F.,  "Natural  Language  For  I n s t r u c t i o n al 

Communication," 
Heuristic  Programming,  Edinburgh  Univ.  Press  1971, 
pp.  191-198. 

In  A r t i f i c i al  I n t e l l i g e n ce  and 

6.  Woods,  W.,  "Transition  Network  Grammars 

for 

Natural  Language  A n a l y s i s ,"  Comm,  Assoc, 
Comput.  Mach.  V o l.  13,  Oct.  1970,  pp.  591-606. 

7.  Fikes,  R.  E.,  and  N i l s s o n,  N.  J .,  "STRIPS:  A 

New  Approach  to  the  Application  of  Theorem  Proving 
to  Problem  S o l v i n g ,"  A r t i f i c i al 
1971,  pp.  189-208. 

I n t e l l i g e n c e, 

I I, 

8.  Brown,  J.  S .,  Burton,  R.  R.,  and  Zdybel,"A  Model-

Driven  Question-Answering  System  for  M i x e d - I n i t i a(cid:173)
t i ve  Computer-Assisted  I n s t r u c t i o n ", 
IEEE  Trans, 
on  Systems,  Man,  and  Cybernetics,  SMC-3,  No.  3, 
pp.  248-257. 

9.  Shea,  T.  0 .,  and  Sleeman,  D.  H.,  1972,  "A  Design 

for  Adaptive  Self-Improving  Teaching  System," 
Working  paper,  Department  of  Computational  Science, 
University  of  Leeds,  England. 

93 

