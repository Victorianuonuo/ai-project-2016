Session  17  Psychology  and 
A r t i f i c i al 

I n t e l l i g e n ce 

PAS-I1:  AN  INTERACTIVE  TASK-FREE  VERSION  OF 

AN  AUTOMATIC  PROTOCOL  ANALYSIS  SYSTEM 

D.  A.  Waterman  and  A.  Newell 

Departments  of  Psychology  and  Computer  Science 

C a r n e g i e-  M e l l on  U n i v e r s i ty 
P i t t s b u r g h,  Pennsylvania 

A b s t r a ct 

is  a 

P A S - II 

t a s k - f r e e, 

is  d e s c r i b e d. 

i n f o r m a t i on  processes  used  by  a  human 

P A S - I I,  a  computer  program  which  r e p r e s e n ts  a 
g e n e r a l i z ed  v e r s i on  of  an  automatic  p r o t o c ol  system 
(PAS-I) 
i n t e r­
a c t i v e,  modular  data  a n a l y s is  system 
the 
v e r b al  b e h a v i or  w h i le  s o l v i ng  a  p r o b l e m. 
of 
t i on  of 
problem  s o l v i n g.  As  an  example  of  system  o p e r a t i on 
the  P A S - II  a n a l y s is  of  a  s h o rt  c r y p t a r i t h m e t ic  p r o­
t o c ol 

the  s u b j e c t 's  changing  knowledge  s t a te  d u r i ng 

i n f e r r i ng 
from  h is 
The  o u t p ut 

is  a  Problem  Behavior  Graph: 

is  p r e s e n t e d. 

t he  program 

f or 

a  d e s c r i p­

1. 

I n t r o d u c t i on 

to 

to 

is  a 

j o i nt  e f f o rt 

A u t o m a t ic  p r o t o c ol  a n a l y s is 
from 

i n f er 

the 

in  by 

to 
f u ll 

t h i nk  out 

the  r e c o rd  of 

i n s t r u c t i o ns 
the 

the  u n d e r l y i ng 
( 5 ), 
it  u s u a l ly 

t he  v e r b a l i z a t i o ns  of  a  s u b j e ct  s o l v i ng 
l o u d. 

by  man  and  machine 
t i me  course  of  a  s u b j e c t 's  b e h a v i o r, 
i n f o r m a t i on  p r o c e s s e s. 
As  developed 
r e f e rs 
some  problem  under 
P r o t o c ol  a n a l y s is  d e s i g n a t es 
i t i es  engaged 
the  s u b j e c t 's 
w i th  p r o t o c o l s: 
b e h a v i or  a c c o r d i ng 
to  an  h y p o t h e s i z ed  m o d e l, 
t i on  of  new  r u l e s,  d e r i v a t i on  of  consequences 
a  model 
ment  of  adequacy  of  a  m o d e l. 
our  work  has  been  b e h a v i or  d e s c r i p t i on 
i n f o r m a t i on  p r o c e s s e s,  g i v en  an  h y p o t h e s i z ed  g e n e r al 
model 
s u b j e ct  o p e r a t e s ). 

the  context  of  s p e c i f ic  data,  and  measure­

the  p s y c h o l o g i st  when  w o r k i ng 

( t he  s o - c a l l ed  p r o b l em  space 

focus  of 
terras  of 

range  of  a c t i v­

d e s c r i p t i on  of 

i n i t i al 
in 

i n d u c­
from 

in  w h i ch 

The 

the 

in 

The  PAS-I  system 

( 1 4,  15)  was  our 

f i r st  a t t e m pt 

T h is 

is  a 

f u l ly 

the  s u b j e c t 's  search 

d e­
to  analyze  c r y p t a r i t h m e t ic  p r o t o c o ls  and  p r o­

at  a u t o m a t ic  p r o t o c ol  a n a l y s i s. 
a u t o m a t i c,  n o n - i n t e r a c t i v e,  s p e c i a l i z ed  system 
signed 
duce  as  o u t p ut  a  problem  b e h a v i or  graph 
i ng 
space. 
The  p r o t o c ol  a n a l y s is 
sequence  of  p r o c e s s i ng  stages 
form 
At  each  stage  r u l es  a re  a p p l i ed  which  e f f e ct  a 
f o r m a t i on  of 
shown 

t r a n s­
i n to  a  problem  b e h a v i or  g r a p h. 
t r a n s­
is 

t h r o u gh  a  p o s i t ed  problem 
is  r e p r e s e n t ed  as  a 
t h at  e v e n t u a l ly 

The  o r g a n i z a t i on  of  PAS-I 

the  raw  p r o t o c ol 

in  F i g u re  1. 

the  d a t a. 

( P B G ) d e s c r i b­

PAS-1  has  s u c c e s s f u l ly  analyzed  p r o t o c o ls 

from 

DONAUH-GERALDtROBERT  and  CROSS+ROADS=DANGER  c r y p t­
a r i t h m e t ic  problems. 
DONALD+GERALD=ROBERT 
have  been  d i s c u s s ed 
t h at 
b o th 

t he 
two  of 
the  s u b j e c ts 
(15)  and  demonstrate 

t h is  approach 
f e a s i b le  and  r e w a r d i n g. 

The  r e s u l ts  o b t a i n ed 
t a sk 

to  a u t o m a t ic  p r o t o c ol  a n a l y s is 

f or 
in  d e t a il 

in 

is 

Encouraged  by 

t he  success  of  PAS-I  we  have 

it 

improved  v e r s i on  c a l l ed  P A S - I I. 
to 

two  major  goals 

in  m i n d: 

t a sk 

i n t e r a c t i ve  and 
t h at 

designed  and  b u i lt  an 
P A S - II  was  designed  w i th 
make 
we  mean 
p a rt 
problems 
e s s i ng  e r r o r s,  and  even  m a i n t a in  c o n t r ol  over 
p r o c e s s i ng  sequence. 
of 

f r e e. 
is  p e r m i t t ed 
he  can  p r o v i de  answers 

the  system  a  more  p o w e r f ul 

t he  a n a l y s i s: 
the  syetem 

t h is  s o rt  makes 

r e a l - t i me 

is  unable 

C l e a r l y, 

t he  user 

By 
to 

take  an  a c t i ve 
to  sub-
to  s o l v e,  c o r r e ct  p r o c­

i n t e r a c t i on 

i n t e r a c t i ve 

t o ol 

the 

in 

f r ee  we  mean 

t h at 

independent  of  any  p a r t i c u l ar  problem 
the 

f r ee  we  p a r t i t i o n ed 

task 
the  problem  dependent  p a rt 

the  p r o c e s s i ng  r u l es  or  h e u r i s t i cs  used 

is 

By 

t a sk 

two  - p a r t s: 

To  make  P A S - II 

f or  p r o t o c ol  a n a l y s i s. 
the  system 
domain. 
system  i n to 
c o n s i s t i ng  of 
at  each  stage  of 
independent  p a rt  c o n s i s t i ng  of 
s t r u c t u re  and  command 
system  to  a  p r o t o c ol 
must 
f or 
f o ur  subgoals: 
m o d i f i a b l e,  e x t e n d a b l e,  and  open 

f i r st  supply 
t h at  d o m a i n .* 

language. 

to  make 

the  a n a l y s i s,  and 

the  problem 

the  g e n e r al  c o n t r ol 

in  a  new  problem  area 

Thus, 

to  a p p ly 

the 
the  user 

the  system  w i th  p r o c e s s i ng  r u l es 
The  d e s i gn  of  P A S - II  a l so 

i n c l u d ed 

the  system  t r a n s p a r e n t, 
(see  F i g u re  2 ). 

t u n i n g" 

T h is 
I n d u c t i ve 

i m p l e m e n t a t i on 

the  d e d u c t i ve  and 

in  c r y p t a r i t h m e t i c. 

the  processing,  h e u r i s t i cs 

important 
in  the  d e s i gn  of  P A S - I I. 

Two 
addressed 
performance 
expanding 
c a p a b i l i t i e s,  and  " f i ne 
o p t i m i z i ng 
b e st  p o s s i b le  a n a l y s is  w i t h in 
the  a n a l y s i s. 
2).  Extend 
extend 
to  handle 
n i t i on  and  segmentation  problems 
a 
system 
space 
system  model 

t r a n s c r i p t i on 
to  handle 
from 

the  scope  of 
the  system  back 

from  the  audio 
the  problem  of 

the  p r o t o c ol  or 

from 

issues  were  n ot 
1).  Improve  system 

i n c l u d es 
i n f e r e n ce 

the  system  by 

the  g i v en 

to  produce 

the 

framework. 
For  example, 

the  speech  r e c o g­
i n h e r e nt 

in  p r o d u c i ng 

t a p e.  Or  extend 

the 

i n d u c i ng 

the  problem 

i n d u c i ng  a  p r o d u c t i on 

the  problem  b e h a v i or  g r a p h. 

It  was  decided 

to  make  P A S - II 

i n t e r a c t i ve  and 

the  problems  of 
t a sk  or  broadening 

i n c r e a s i ng 

the  scope 

T h is  d e c i s i on  was 

I n f l u e n c ed  by 
f or  p r o t o c ol 
t h at  c o u ld  be  used  by  p a r t i c i p a n ts  at  a 

to  p r o v i de  a  w o r k i ng 

t o ol 

the  a n a l y s i s. 

f r e e,  p o s t p o n i ng 
in  a  p a r t i c u l ar 

t a sk 
power 
of 
the  d e B i re 
a n a l y s is 
workshop  on  New  Techniques 
at  CMU 
c u r r e n t ly  r u n n i ng 
a v a i l a b le 

the  CMU  (and 

the  summer  of  1972 

to 

in 

in  C o g n i t i ve  Research  h e ld 

( 7 ). 

The  P A S - II  system  is 

in  LISP  at  CMU  on  a  PDP-10  and 

is 

the  ARPA  Network)  community. 

f o l l o w s. 

The 

t a sk  of 

in  S e c t i on  2. 

T h is 

is 

is  o r g a n i z ed  as 
is  d i s c u s s ed 

T h is  paper 
p r o t o c ol  a n a l y s is 
f o l l o w ed 
s t r u c t u re  of 
example  of 
p r o t o c o l. 
the  g e n e r al  e x e c u t i ve  s t r u c t u re  of 
i ts 

i m p l i c a t i on 

in  S e c t i on  3  by  a  b r i ef  d e s c r i p t i on  of 
in  S e c t i on  4  by  an 

the  program  and 

the 

i ts  use 
S e c t i on  5  concludes  w i th  a  d i s c u s s i on  of 

in  a n a l y z i ng  a  c r y p t a r i t h m e t ic 

f or  AI  d a ta  a n a l y s is  programs. 

the  system  and 

2. 

Task  of  P r o t o c ol  A n a l y s is 

P r o t o c ol  a n a l y s is 

is  based  on  a  p a r t i c u l ar 

t a sk  r e q u i r i ng  b o th  d e d u c t i ve  and 
c a p a b i l i t i e s.  Our  c u r r e nt  approach 
s is 
s o l v i n g. 
i n t r o d u c t i on  to 
Newell  and  Simon  ( 5 ). 

For  a  d e s c r i p t i on  of 

the 

is  a  complex  data  p r o c e s s i ng 
i n f e r e n ce 
to  p r o t o c ol  a n a l y­

I n d u c t i ve 

t h e o ry  of  human  problem 

t h e o ry  and  an 
t a sk  of  p r o t o c ol  a n a l y s is  see 

t h is 

U l t i m a t e l y,  a 
l i b r a ry  c o n t a i n i ng  p r o c e s s i ng  r u l es 
f or  a  number  of  d i f f e r e nt  problem  domains  w i ll  be 
a v a i l a b le 

the  u s e r. 

to 

431 

432 

Theoretical  Substructure 

Problem  Space.  We  assume  human  problem  solving 

takes  place  by  search  in  a  problem  space.  The  e l e­
ments  of  t h is  space  are  the  possible  states  of  knowl-
e_d£e  the  subject  can  have  about  the  task,  where  a 
state  of  knowledge  is  simply  an  expression  of  what  the 
in  the  space. 
subject  knows  at  some  particular  point 
Besides  knowledge  states, 
the  problem  space  also  i n­
cludes  a  set  of  operators.  These  define  operations 
the  subject  can  perform  on  knowledge  at  a  particular 
state  to  y i e ld  new  knowledge  --  hence  to  move  to  a 
new  knowledge  state.  The  operators  are  incremental, 
that  i a, 
t o t al  knowledge  state  (a  small  set  of  knowledge  e l e­
ments)  and  produce  as  output  new  knowledge  elements, 

they  take  as  input  a  small  portion  of  the 

incrementally  changing  knowledge  states. 

Problem  Behavior  Graph.  The  subject's  search 
through  the  problem  space  for  a  solution  can  be  des­
cribed  as  a  sequence  of  operator  applications  that  cre­
ate  a  s t r i ng  of 
The  plot  of  this  search  is  called  the  problem  behavior 
graph 
(FBG).  Figure  8  (also  used  to  i l l u s t r a te  the 
output  of  the  analysis  given  in  Section  4)  shows  a 
problem  behavior  graph  for  cryptarithmetic.  The  nodes 
represent  operator  applications: 
the  knowledge  e l e­
ments  at  the  lower  l e ft  of  each  node  are  the  inputs, 
those  at  the  lower  r i g ht  are  the  outputs.  PBG 
branching  results  from  the  subject  abandoning  i n f o r­
mation  and  returning  to  a  prior  knowledge  state 
(usually  because  of  a  discovered  contradiction).  For 
example, 
c o n f l i c t: 
leads  to  the  abandonment  of  nodes  4,  5  and  6,  Note 
that  the  knowledge  state  at  any  point  in  the  graph  is 
the  conjunction  of  a ll  output  elements  on  the  path 
the  given  point  back  to  the  beginning  of  the  graph. 
A ll  nodes  on  the  path  from  the  last  node  back  to  the 
beginning  of  the  graph  are  called  currently  active 
nodes.  Their  output  elements  define  the  current 
knowledge  state. 

in  Figure  8  the  outputs  of  nodes  4  and  6 
"R  is  4"  c o n f l i c ts  with  "R  is  odd,"  and 

from 

Data  Analysis 

The  data  being  analyzed  is 

the  transcribed  text 
of  a  subject's  verbal  protocol.  As  the  text  is  trans­
formed  into  a  PBG  it  is  subjected  to 
four  major  types 
of  processing: 
l i n g u i s t i c,  semantic,  group,  and  PBG. 
Figure  1  t y p i f i es  such  a  processing  sequence. 

The  text  is 

f i r st 

Linguistic  Processing. 

segmented  i n to  shorter  strings  called  topic  segments,' 
each  of  which  is  expected  to  ultimately  y i e ld  approxi­
mately  one  problem  space  element.  Each  segment  is 
then  parsed  using  a  grammar  sensitive  to  the  problem 
domain  under  consideration.  The  result  of  parsing  is 
a  set  of  semantic  elements  which  represent  the  meaning 
of  the  segment.  For  example, 
the  segment  "D  is  not 
equal  to  6"  might  y i e ld  the  elements  (NEC)(EQ  D  6) 
the  cryptarithmetic  task.  Here  (NEG) 
an  indicator  element,  (EQ  D  6)  a  knowledge  element. 

is  called 

in 

Semantic  Processing.  The  semantic  elements 

i . e .,  (NEG) 

produced  through  parsing  are  f i r st  combined  in  very 
elementary  ways  to  produce  new  elements, 
and  (EQ  D  6)  become  (NEQ  D  6 ).  Next,  new  elements 
r e f l e c t i ng  relationships  between  elements 
from 
adjacent  segments  are  produced.  Thus,  (EQ  D  5) 
one  segment  and  (THEREFORE)(EQ  T  0) 
from  the  next 
segment  become  (BECAUSEOF  (EQ  D  5)(EQ  T  0 ) ),  e . g ., 
"because  D  is  5,  T  is  0."  F i n a l l y, 
arranged  i n to 
each  containing  an  operator  element  and  the  surround­
ing  knowledge  and  indicator  elements.  An  operator 

these  elements  are 
i n i t i al  approximations of  operator  groups, 

from 

433 

group  is  defined  to  be  an  operator  together  w i th  i ts 
input  and  output  knowledge  elements. 

Group  Processing.  The  tentative  operator  groups 

produced  during  semantic  processing  are  now  analyzed 
to  obtain  a  complete  picture  of  what 
the  subject  knows 
at  each  moment  and  what  operators  he  applies.  F i r s t, 
variables  in  semantic  elements  are  i d e n t i f i ed  by  com­
paring  the  elements  to  the  current  context  as  defined 
by  the  PBG.  Thus  if  (EQ  D  5}  were  in  the  PBG  then 
when  given  the  element  (EQ  <L>  5 ),  where  <L>  stands 
for  a  class  of  l e t t e r s,  we  recognize  that  <L>  in  this 
case  is  the  l e t t er  D. 

The  second  part  of  group  processing  consists  of 
f i n d i n g,  or  hypothesizing, 
the  o r i g in  of  every  knowl­
edge  element  in  each  tentative  group.  The  o r i g in  of 
a  knowledge  element  is  defined  to  be  the  operator 
which  produced  i t,  plus  the  inputs 
to  that  operator, 
plus  the  operators  which  produced  those  inputs,  etc. 
Thus  the  o r i g in  can  be  represented  as  a  tree  which 
defines  a  c o l l e c t i on  of  overlapping  operator  groups. 

PBG  Processing.  The  operator  groups  produced 

In  general,  each  group  becomes  a  node  in  the 
In  the  simplest  case  the  new  node  is  just 

during  group  processing  are  now  incorporated  into  the 
PBG. 
PBG. 
attached  to  the  last  currently  active  node.  However, 
when  contradictions  occur  (the  output  of  one  node 
c o n f l i c ts  with  the  output  of  another) 
occurs  to  eliminatethe  c o n f l i ct  (see  Figure  8 ). 

restructuring 

3.  Structure  of  the  Program 

PAS-II  takes  as  input  a  transcribed  text  of  the 

verbalization  of  a  subject  solving  a  problem  and 
produces  as  output  a  PBG.  The  processing  rules  for 
the  various  stages, 
including  the  rules  defining  the 
problem  space,  are  given  to  the  system.  These  rules 
are  supplied  either  by  the  system  builder  via  a 
l i b r a ry  of  rules 
the  user  himself. 

for  various  problem  domains  or  by 

Modular  Structure 

PAS-II  is  organized  as  a  modular  data  analysis 
system.  The  basic  unit  of  organization  is  the  mode: 
a  processing  state  which  has  associated  with  it  a 
buffer  capable  of  holding  rules  or  data. 
This  buffer 
can  be  modified  by  the  editing  functions  available  in 
the  command  language.  There  are  three  types  of  modes: 
run  modes,  which  hold  the  data  being  analyzed,  rule 
modes,  which  hold  the  processing  r u l e s,  and  a u x i l i a ry 
modes,  which  hold  task-free  system-oriented  rules. 
Thus  the  information  in  the  rule  modes  constitutes 
problem  dependent  part  of  the  system. 

the 

a 

The  next  level  of  organization  ia  the  stage: 
unit  consisting  of  one  run  mode  and  any  number  of 
associated  rule  modes.  Data  processing  is  performed 
in  a  stage  by  applying  the  rules  from  the  rule  modes 
associated  with  that  stage  to  the  data  present  in  the 
run  mode  of  the  previous  stage.  The  result  of  the 
processing  is  then  put  i n to  the  run  mode  of  the  current 
stage.  Figure  3  i l l u s t r a t es  the  modular  organization 
of  PAS-II,  with  the  arrows  indicating  data  flow  and 
the  lines  indicating  mode  associations. 

The  highest  level  of  organization  is  the 

a  unit  consisting  of  consecutive  stages 

processor: 
in  the  control  cycle.  For  example, 
l i n g u i s t ic  Btages  form  the  Linguistic  processor  and 
three  semantic  stages 

form  the  Semantic  processor 

in  PAS-II  two 

434 

is 

in 

Note 

them. 

The  arrows 

in  T a b le  1. 

i l l u s t r a t ed 

implemented  in  PAS-

t h at  most  r un  modes 

The  modes  c u r r e n t ly 

the 
the  mode  at 

two  r u l es  modes  a s s o c i a t ed  w i th 

t a il  of  an  arrow  p r o v i d es 
the  head  of 

in  Table  1  and  a l so 
the  modular  c o m p o s i t i on  of 
in  P A S - I I. 
the 
l i n ks  e x i s t i ng  between  modes. 

Modes. 
II  a re 
l i s t ed 
have  one  or 
T h is  a s s o c i a t i on 
in  F i g u re  3,  which  shows 
the  v a r i o us  p r o c e s s o rs 
f i g u re  d e f i ne 
the  data 
The  mode  at 
t h at 
example,  p r o c e s s i ng 
i ng 
the  TOPIC  mode. 
mode  and 
it 
As  each 
t he  TEXT  b u f f e r.  However,  a  copy  of 
l i n es 
t r i e v ed 
arrows 
c o n t r ol  c y c l e, 
o c c u r s. 
( to  be  d i s c u s a ed 

(see 
in  F i g u re  3  do  n ot  n e c e s s a r i ly  d e f i ne 

in  TEXT  and  can  be  r e­
f u n c t i o ns 
in  T a b le  2 ). 

is  s t o r ed  elsewhere 
the  process 

the  TOPIC  mode 
t he  d a ta 

in 
the  r e s u lt 
is  p r o c e s s e d, 

t h en  p l a c i ng 
l i ne 

is  d e l e t ed 
these  d e l e t ed 

t he  SEGMENTATION  r u l es 

t he  arrow  p r o c e s s e s. 

in  which  p r o c e s s i ng 

the  o r d er 
f l ow 

For 
i n v o l v es  a p p l y­
in 

The  c o n t r ol 

in  F i g u re  4 

i l l u s t r a t ed 

t he  TEXT 

the  data 

in  TEXT 

l a t e r ). 

i . e ., 

from 

The 

the 

to 

in 

is 

Functions.  The  functions  c u r r e n t ly  implemented 
in  PAS-II  are  l i s t ed  in  Table  2.  They  c o n s t i t u te  the 
command  language  available  to  the  user,  and  are 
divided  i n to  four  categories: 
process  functions.  Note  that  a  mode  name  is  a 
function  that  puts 

basic,  e d i t,  f l a g,  and 

the  user  i n to 

that  mode. 

it 

If 

A  function  c a ll  consists  of  a  function  name 
followed  by  i ts  arguments.  Any  number  of  function 
c a l ls  may  occur  together. 
is  not  clear  which 
names  are  the  functions  and  which  are  the  arguments, 
parentheses  can  be  used  f or  disambiguation. 
ambiguous  cases  the  system  always  assumes  the  name 
is  a  function  name  rather  than  an  argument.  Thus  if 
the  user  types  HELP  TOPIC  DISPLAY  3  it  could  mean 
e i t h er  (HELP  TOPIC):  give  me  information  about  the 
display  l i ne  3  of  the 
TOPIC  mode,  and  (DISPLAY  3): 
current  b u f f e r;  or  (HELP): 
t e ll  me  how  to  get  help, 
(TOPIC):  put  me  i n to  the  TOPIC  mode,  and  (DISPLAY  3): 
display  l i ne  3.  The  system  would  make  the  l a t t er 
i n t e r p r e t a t i o n. 

In 

Comparison  w i th  F i g u re  1  shows  how  P A S - II  maps  o n to 
P A S - I.  Note 
been  extended 
d i s c u s s ed 

the  scope  of 
i n c l u de  a  T r a ce  p r o c e s s or 

the  a n a l y s is  has 
( n ot 

t h is  p a p e r ). 

in  d e t a il 

t h at 
to 

in 

435 

A u x i l i a ry  Modes. 

There  are 

f o ur  a u x i l i a ry 

f or 

i n to 

save, 

from) 

(or  r e ad 

f l ow  shown 

the  c o n t r ol 

the  system. 

( or  READ)  command  la 

c o n t r o ls  a s s o c i a t i o n,  and  i n f o r m a t i o n. 

to  be  saved  on 
the  WRITE 

t he  c o n t r ol  c y c le 
r u l eB  d e f i ne 

The  CONTROL  mode  c o n t a i ns  r u l es  w h i ch 

I n i t i a l ly 
in  F i g u r es 
The  ASSOCIATION  mode  c o n t a i ns  r u l es  w h i ch 
the  a s s o c i a t i o ns  between  r un  and  r u le  modes. 

modes: 
The  SAVE  mode  c o n t a i ns  r u l es  which  s p e c i fy  which 
mode  b u f f e rs  a re 
a  d i sk  f i le  when 
executed. 
d e f i ne 
these 
3  and  4. 
d e f i ne 
The 
shown 
t o g e t h er  w i th 
t i c a t ed  user 
a s s o c i a t i o n s,  and  r e o r g a n i ze 
the  e n t i re  system,  One  example  of 
a  r e o r g a n i z ed  PAS-II 
(problem 
from  t h at 
s u b j e ct  m i g ht  use 

to 
t e n t a t i ve  problem  space,  one 
t he  problem 

the  CREATE 
to  c r e a te  new  modes, 

( or  d e f a u l t)  a s s o c i a t i o ns  a re 

i n f er 
t h at  a 
( 2 ). 

f u n c t i o n,  p e r m it 

in  r e p r e s e n t i ng 

r e d e f i ne  mode 

t e x t) 
t e xt  a 

to  analyze  a  problem  d e s c r i p t i on 

The  CONTROL  and  ASSOCIATION  modes, 

in  F i g u re  3, 

the  c o n t r ol 

the  s o p h i s­

the  use  of 

in  n a t u r al 

language 

in  o r d er 

i n i t i al 

those 

f l ow 

t h is 

f or 

is 

The 

INFORMATION  mode 

is  unique 
the 
I n s t e a d, 
i n p u t,  which  may 

in  c o n t a i n i ng 
f u n c t i o ns 
t h at 
t h is  mode 

the  user  w i th 

language, 

in  sentence 

the  command 

to  key  words 

no  b u f f er  and  r e c o g n i z i ng  none  of 
c o n s t i t u te 
responds 
be 
g e n e r al 
z a t i o n,  p u r p o s e,  and 
to  be  c o n t r a s t ed  w i th  the  HELP 
v i d es 
about 

i n f o r m a t i on  about  P A S - I I: 

f o r m. 

is 

the  user  w i th  s p e c i f i c,  o n - t h e - s p ot 
the  mode  he 

i n. 

the  users 

in 
The  mode  p r o v i d es 

t e c h n i q u es  of  o p e r a t i o n. 

i ts  b a s ic  o r g a n i­
T h is 

is 

f u n c t i o n,  which  p r o­

i n f o r m a t i on 

C o n t r ol  S t r u c t u re 

f or  P A S - II 

is  shown 
The  s o l id  arrows 
in 

the 

in 
i n d i c a te 
the 

is  e n t e r ed  once  p r o c e s s i ng 
is 

The  b r o k en  arrows 

i n d i c a te 

to  e n t er  b e f o re  p r o c e s s i ng 
in  LINGUISTIC1,  SEMANTICS,  and  GRAPHIC2 

is  s t a r t e d. 

is 

The  c o n t r ol  c y c le 

f i n i s h e d. 

In  each  of 

f l ow  diagram  of  F i g u re  4. 
the  stage 
t h at 
c u r r e nt  stage 
which  stage 
Processing 
i n c r e m e n t a l. 
data 
T h is 
through 
of  PBG  nodes,  b e f o re 
p r e v i o us  mode 
a  semantic  c o n t e xt 
the  p r o c e s s i ng  sequence  so 
needed 

from 
i n i t i al  p o r t i on  of 

the  r e st  of 

the  p r e v i o us  mode 

is  p r o c e s s e d. 

f or 

these  modes  o n ly  p a rt  of 

is  processed  at  one 
t h en  c a r r i ed 

the 
t i m e. 

the  data 
the  system, 

the  r e st  of 

is 
l e a d i ng 

to 
the  data 
is  done 

This 

the  growth 
in  t he 
to  e s t a b l i sh 

( t he  PBG)  as  e a r ly  as  p o s s i b le 
feedback 

it  can  p r o v i de 

in 

l i n g u i s t i c,  s e m a n t i c,  and  group  p r o c e s s i n g. 

Since 
f l e x i b l e, 

the  c o n t r ol  o r g a n i z a t i on  of  P A S - II 

is 

is  under  no  c o n s t r a i n ts 

to 
in  F i g u re  4.  He 
t he  e x i s t i ng  c o n t r ol 

the  c o n t r ol  c y c le 

( v ia 

the  data 

the  o r d er  shown 

the  user 
in 

q u i te 
process 
may  s k ip  or  r e p e at  stages  w i t h in 
framework,  and  may  r e d e f i ne 
the  CONTROL  mode).  He  may  a l so  have 
him  i n to 
even  a u t o m a t i c a l ly  step  h im 
i n i t i a t i ng 
and  AUTOMATIC 

the  next  r un  mode 

the  p r o c e s s i ng  at  each  stage 

in  Table  2 ). 

through 

In 

the  c o n t r ol 

the  system  p ut 

l o o p,  or 
the  r un  modes, 
(see  NEXT 

Data  Processing 

F i g u r es  3  and  4  show  the  processors  which  com­
the  c o n t r ol  c y c le  of  P A S - I I. 

the  Topic 

In 

p r i se 
processor 
c o n t a i n i ng  o n ly  a  s i n g le 
L i n g u i s t ic  processor  an 

t r a n s c r i b ed 

t e xt 

is  segmented 

i n to  phrases 
t a sk 
Then 
i n i t i al  c o l l e c t i on  of 

in 
the 
these 

t o p i c . ** 

At  p r e s e nt 
p r o c e s s i ng  o n l y. 

the  PBG  p r o v i d es 

feedback 

f or  group 

is  a  s l i g ht  e x t e n s i o n: 

PAS-I  r e q u i r es  s e g­

This 
mented 

t e xt  as 

i n p u t. 

436 

is  parsed  y i e l d i ng  sets  of  semantic  elements. 

segments 
These  elements  are  processed  and  refined  in  the 
Semantic  processor  to  produce  groups  composed  of  one 
lts  associated  input  and  output 
operator  element  and 
knowledge  elements. 
In  the  PBG  processor  these  groups 
are  incorporated  i n to  the  PBG.  The  Trace  processor 
is  then  used  to  compare  t h is  PBG  with  the  trace 
produced  by  a  given  production  system  model  of  the 
subject. 

it  holds 

to  process. 

the  data  for  TOPIC 

Topic  Processor.  The  Topic  processor  contains 
two  run  modes:  TEXT  and  TOPIC.  TEXT  is  an  i n i t i a l i­
zation  mode; 
Thus  no  r e al  processing  takes  place  in  i t.  The 
TOPIC  mode  uses  the  SEGMENTATION  rules  to  segment  a ll 
the  text  in  the  TEXT  mode.  These  rules  have  the 
general  form: 
/  s t r i n g2  ,  where  a  s t r i ng  is 
any  sequence  of  words,  punctuation  marks,  or  word 
classes  (as  defined  in  the  GRAMMAR  mode),  including 
the  n u ll  sequence.  The  slash  (/) 
text 
of  s t r i n g, 
is  immediately  followed  by  an  occur­
rence  of  s t r i n g -.  Figure  6  show  SEGMENTATION  rules 
for  cryptarithmetic 
Section  4)  . 

i . e .,  a f t er  every  occurrence 

indicates  where  the 

in  the  example  in 

to  be  broken, 

(to  be  used 

.string, 

that 

is 

L i n g u i s t ic  Processor. 

The  Linguistic  processor 
contains  two  run  modes:  LINGUISTICl  and  LINGUISTIC2. 
In  LINGUISTICl  the  EXTRACTION  rules  are  used  to  select 
a  consecutive  set  of  segments  from  TOPIC,  representing 
an  i n i t i al  guess  as  to  the  minimum  number  of  segments 
from  which  a  group  can  be  I n f e r r e d.  Processing  con­
s i s ts  only  of  t r a n s f e r r i ng  these  segments  from  the 
TOPIC  mode  to  the  LINGUISTICl  mode.  At  present, 
EXTRACTION  rules  are  simply  a  single  integer  speci­
fying  how  many  segments  to  transfer. 

the 

(semantic-element) 

Processing  in  the  LINGUISTIC2  mode  consists  of 
applying  the  SPACE  and  GRAMMAR  rules  to  a ll  the  topic 
segments  in  LINGUISTICl.  The  parsing  operation  pro­
duces, 
for  each  segment,  a  set  of  semantic  elements 
representing  the  meaning  of  the  segment.  The  rules 
in  the  SPACE  mode  define  the  problem  space  and  have 
the  form: 
type,  where  a  semantic 
element  is  e i t h er  an  operator,  knowledge,  or  indicator 
element,  and  the  type  is  e i t h er  OP,  KN,  or  IND.  The 
GRAMMAR 
form: 
. . .) 
(denoted  by  angle  brackets)  or  a  l i t e r al  (such  as  a 
word, 
l e t t e r,  or  character).  An  asterisk  (*)  can  be 
used  between  any  two  items  to  indicate  a  match  w i th 
any  s t r i ng  of  t e x t,  and  any  GRAMMAR  rule  which  is  a 
disjunction  of  single  l i t e r a ls  can  be  w r i t t en  without 
parentheses.  Figure  6  shows  SPACE  and  GRAMMAR  rules 
for  cryptarithmetic. 

,  where  an  item  is  either  a  class 

<clas6>  =  (item11  item, 

rules  define  a  key-word  grammar  and  have  the 

. , .)  (item21 

item 

. .. 

Semantic  Processor.  The  Semantic  processor 

In  SEMANTICl  the  INTEGRATION  rules  produce 

into  single  elements  r e f l e c t i ng  the  relationships 

contains  three  run  modes:  SEMANTICl,  SEMANTIC2,  and 
SEMANTIC3. 
new  elements  by  combining  semantic  elements  generated 
from  the  same  or  adjacent  segments. 
In  SEMANTIC2  the 
NORMALIZATION  rules  map  knowledge  and  indicator  e l e­
ments 
e x i s t i ng  between  two  or  more  knowledge  elements. 
SEMANTIC3  a  tentative  operator  group  (protogroup) 
formed.  The  INTEGRATION  AND  NORMALIZATION  rules  are* 
replacement  rules  of  the  type  A  =>  B, 
A  w i th  B.  Both  A  and  B  can  be  l i s ts  of  semantic 
elements.  A  slash  (/) 
elements  of  the  l i st  occur  on  the  next  l i ne  of  the 
mode  b u f f e r.  Class  names  and  X's  are  used  as  v a r i­
ables,  and  in  the  NORMALIZATION  rules  A's  are  v a r i­
ables  which  stand  for  knowledge  elements  on  adjacent 
lines  connected  by  the  AND  i n d i c a t o r.  Typical 
INTEGRATION  and  NORMALIZATION  rules  for  c r y p t­
arithmetic  are  shown  in  Figure  6.  GROUPING  rules  are 
not  shown.*  They  define  a  protogroup  to  be  the 
largest  consecutive  sequence  of  elements  containing 
no  more  than  one  operator  element. 

indicates  that  the  next 

replace 

i.e., 

In 
is 

Group  Processor.  There  are  two  run  modes  in  the 

Group  processor:  GRAPHIC1,  and  GRAPHIC2.  GRAPHIC1 
processing  f i l ls  in  the  values  of  variables 
semantic  elements  by  comparing  the  element  containing 
variables  w i th  a ll 
the  PBG, 
found  the  appropriate  values  are  f i l l ed  i n.  Currently 
the  UNKNOWNS  rules  are  not  accessible  to  the  user. 

the  current  context.  When  a  match  is 

the  elements  c u r r e n t ly  active 

in  the 

i . e ., 

in 

I . e ., 

the  operator  and  i ts 

the  user  asking  for  possible 

Processing  in  GRAPHIC2  is  a  j o i nt  man-machine 
e f f o r t . **  The  goal  is  to  hypothesize  for  each  knowl­
edge  element  i ts  o r i g i n, 
inputs  (and  the  operators  that  produced  those  inputs, 
etc.) 
that  produced  that  knowledge  element  as  output. 
The  system  queries 
operators  and  inputs  that  could  have  produced  the 
element  whose  o r i g in  is  being  sought.  From  t h is 
information  the  system  constructs  an  o r i g in  t r e e, 
and  hypothesizes  which  path  through  the  tree  repre­
sents  the  actual  o r i g in  of  the  element.  The  path  is 
picked  on  the  basis  of  the  agreement  between  the 
hypothesized  inputs  and  the  actual  context  defined  by 
the  current  PBG.  The  ORIGIN  r u l e s,  l i ke  the  GROUPING 
and  UNKNOWNS  r u l e s,  are  c u r r e n t ly  not  accessible. 

PBG  Processor.  The  PBG  processor  contains  one 

In  the  GRAPHIC3  mode,  processing 

run  mode:  GRAPHIC3. 
consists  of  taking  the  operator  groups  produced 
GRAPHIC2  and  incorporating  them  i n to  the  problem 
behavior  graph.  The  CONFLICT  rules  are  used  to  deter­
mine  whether  or  not  any  knowledge  elements  in  the 
operator  groups  c o n f l i ct  w i th  knowledge  already 
PBG. 
used  to  restructure  the  PBG  so  the  c o n f l i ct  is 
eliminated. 

If  such  a  c o n f l i ct  occurs,  the  PBG  rules  are 

in  the 

in 

SPACE  rule  8  in  Figure  6  is  an  exception. 
defines  a  set  named  <V>  containing  two  members, 
the  class  <LETTER>  and  the  class  <EARRY>. 

It 

Two  parsers  are  a v a i l a b l e,  a  simple  top  down 
parser  and  a  more  sophisticated  parser  w r i t t en 
by  M.  Rychener. 

438 

At  the  current  stage  of  development  the  Grouping 
rules  have  not  been  made  accessible  to  the  user. 

is  the  major  place  where  we  have  not  regained 

This 
in  PAS-II  the  power  f or  automatic  processing 
available 

in  PAS-I. 

Both  the  CONFLICT  and  PBG  rules  are  ordered 

i . e ., 

in  s i t u a t i on 

production  rules  of  the  form  S  -*  A, 
S  take  action  A  (12,  13).  A  s i t u a t i on  is  defined  by 
a  l i st  of  values  of  c e r t a in  variables,  called  the 
state  vector,  SV.  The  l e ft  side  of  each  production 
rule  has  the  form  (V.  V„  V 
repre­
sents  a  permissible  value  for  the  nth  s t a tl  vector 
v a r i a b l e.  The  r i g ht  side  has  the  form  (A.  A  A 
. . . ), 
where  the  A'g  represent  actions  to  be  taken.  The  cur­
rent  values  of  the  state  vector  variables  are  compared 
w i th  the  l e ft  side  of  each  production  r u l e.  The  f i r st 
match, 
from  top  to  bottom,  determines  the  actions  to 
be  taken  (an  asterisk  is  considered  to  match  any  value). 

. ..  ),  where  V 

Figure  6  shows  CONFLICT  and  PBG  rules  for 

if  the  second  items  of  both  the 

cryptarithmetic.  The  CONFLICT  rules  determine 
whether  or  not  two  given  knowledge  elements  c o n f l i c t. 
The  example  CONFLICT  state  vector  contains: 
which  is  true  (T) 
elements  are  i d e n t i c al  and  false  (F)  otherwise; 
(ITEM  1 1 ),  which  returns  as  a  value  the  f i r st 
of  the  f i r st  element  (the  element  in  the  PBG);  and 
(ITEM  1 2 ),  which  returns  as  a  value  the  f i r st  item 
of  the  second  element  (the  element  in  the  group). 
Thus  if  the  two  elements  being  compared  were  (ODD  R) 
and  (NEQ  R  5)  CONFLICT  rule  3  would  match  the  state 
vector  and  the  decision  would  be  that  no  c o n f l i ct 
e x i s t s. 

item 

(SAME  2 ), 

The  PBG  rules  determine  the  type  of  restruc­

turing  that  occurs  once  a  c o n f l i ct  is  detected.  The 
PBG  state  vector  in  Figure  6  has  2  variables:  TYPE, 
the  value  CON  if  restructuring  is  based  on 
which  has 
c o n f l i ct  and  SIM  if  it  is  based  on  s i m i l a r i t y; 
and 
(ITEM  1  2 ),  which  is  defined  above.  The  actions  shown 
in  Figure  6  are  BLOCKREJ,  a  type  of  restructuring 
where  blocks  of  adjacent  nodes  are  abandoned,  and 
COPY,  a.  s p e c i f i c a t i on  that  the  group  causing  the 
restructuring  should  remain  in  the  active  portion  of 
the  PBG  a f t er  r e s t r u c t u r i n g.  The  state  vectors  for 
CONFLICT  and  PBG  may  contain  variables  and  actions 
other  than  the  ones  shown  in  Figure  6.  For  a  complete 
description  of  these  rules  see  the  PAS-II  reference 
manual  (16). 

Trace  Processor.  The  Topic,  L i n g u i s t i c, 

It  is 

thiB  portion  which  repre­

Semantic,  Group  and  PBG  processors  comprise  the  major 
portion  of  PAS-II. 
sents  a  generalized  version  of  PAS-I.  The  Trace 
processor  ie  a  new  extension  to  the  system  and  has  no 
analogue  in  PAS-I.  Some  parts  of  i t, 
mode,  are  s t i ll  under  development.  The  Trace  proc­
essor  enables 
the  user  to  w r i te  a  production  system 
model  of  the  subject  (6),  and  then  compare  the  trace 
obtained  by  running  the  production  system  model  w i th 
the  PBG  obtained  by  analyzing  the  protocol.  The 
details  are  described  elsewhere  (16). 

l i ke  the  MATCH 

4.  Example  of  Program  Operation 

To  i l l u s t r a te  the  use  of  PAS-II,  we  present  a 

i n t e r a c t i on  i n­

in  the  on-line  analysis  of  a  short  crypt-

l i s t i ng  of  the  actual  user-machine 
volved 
arithmetic  protocol.  The  cryptarithmetic  task  is 
given  in  Figure  5.  Both the  protocol  and  the  c r y p t­
arithmetic  rules  used  for  t h is  example  are  shown  in 
Figure  6.  The  protocol  is  stored  in  the  TEXT  mode 
and  the  cryptarithmetic  rules  in  the  eight  rules  modes 
shown.  These  rules  approximate  the  minimal  set  needed 

The  user  f i r st  entered  the  TEXT  mode  and  d i s­
played  i ts  contents.  He  then  entered  the  next  mode 
in  the  control  cycle,  TOPIC,  and  started  processing 
by  typing  GO.  This  caused  the  SEGMENTATION  rules  to 
be  applied  to  the  data  in  TEXT.  The  system  indicated 
that  the  data  in  l i ne  1  of  the  previous  mode  had  been 
transformed  i n to  the  seven  lines  shown  above,  and 
asked  if 
At  t h is  point  the  user  typed  yes, 
to  actually  put  those  seven  lines 

transformation  was  satisfactory  (OK?). 
t e l l i ng 
the  system 
into  the  next  seven 

t h is 

The  PBG  rules  are  also  used  for  restructuring  when 
s i m i l a r i t i es  ( i d e n t i c al  nodes)  are  detected,  as 
discussed  in  an  e a r l i er  paper  on  PAS-I  (15). 

At  least  four  times  as  many  rules  would  be  needed 
for  a  complete  set  (15). 

439 

Figure  6.  Cryptarithmetlc  Rules. 

440 

lines  of  the  TOPIC  b u f f e r. 
been  unsatisfactory, 
the  SEGMENTATION  mode,  changed  the  rules,  jumped 
back  to  TOPIC,  and  reprocessed  the  data  using  the  new 
rules  before  proceeding  w i th  the  next  processing  step. 

the  user  could  have  jumped  to 

If  the  processing  had 

The  user  then  entered  the  next  mode,  LINGUISTICl, 

and  started  processing.  The  EXTRACTION  rules  were 
applied  to  the  seven  lines  of  data  in  TOPIC  and  the 
system  indicated  that  the  processing  should  consist  of 
placing  these  lines  in  LINGUISTICl  unchanged.  Note 
that  the  system  indicated  that  l i ne  1  from  TOPIC  was 
transformed  i n to  a  single  l i ne  in  LINGUISTICl,  e t c ., 
as  opposed  to  the  previous  step  where  one  l i ne  in  TEXT 
was 

transformed  into  seven  lines  in  TOPIC. 

Processing  in  LINGUISTIC2  consisted  of  applying 

In  step  1  the  parse  tree  was 

the  SPACE  and  GRAMMAR  rules  to  the  data  in  LINGUISTICl 
to  produce  a  parse. 
printed  and  the  user  set  the  f l ag  BATCH  true  to 
eliminate  the  OK?  question  (the  system  then  assumes 
the  answer  is  always  yes)  and  the  f l ag  SUPPRESS  true 
to  eliminate 
Then,  before  going  to  the  next  mode  in  the  control 
cycle, 
the  user  set  the  f l ag  AUTOMATIC  true  so  the 
system  would  automatically  step  through  the  appropriate 
run  modes  executing  GO.  At  t h is  point  the  LINGUISTIC2 
buffer  held  the  seven  sets  of  semantic  elements  shown 
above. 

further  p r i n t i ng  of  the  parse 

trees. 

Processing  in  SEMANTIC1  consisted  of  applying  the 

it  pulled  a ll 

INTEGRATION  rules  to  the  semantic  elements  in 
LINGUISTIC2.  As  indicated  above  there  were  f i ve 
applications  of  the  r u l e s.  Processing  in  SEMANTIC2 
consisted  of  applying  the  NORMALIZATION  rules 
to  the 
seven  sets  of  elements  In  SEMANTIC1,  There  were  two 
applications  of  the  r u l e s,  and  f i ve  sets  of  elements 
were  l e ft  in  SEMANTIC2.  Processing  in  SEMANTIC3  con-
i s i s t ed  of  applying  the  .GROUPING  r u l e s,  which  are  not 
e x p l i c i t.  These  rules  simply  attempted  to  p u ll  from 
SEMANTIC2  one  operator  element  and  i ts  associated 
knowledge  elements.  Since  no  operator  elements  were 
present, 

from  SEMANTIC2. 

the  elements 

Processing  in  GRAPHICl  consisted  of  applying  the 
UNKNOWNS  r u l e s,  which  are  not  e x p l i c i t.  These  rules 
involve  searching  the  e x i s t i ng  PBG  for  elements 
that 
match  the  elements  containing  unknowns. 
In  t h is 
simple  example  no  matches  were  found  because  the  PBG 
had  not  yet  been  grown.  Thus,  in  step  3  when  the 
unknown  carry  <C>  was  not  found, 
the  user  t o ld  the 
system  to  replace 
(BECAUSEOF  ((  EQ  C2  1)) 
((ODD  R))  ).  This  was  put 
i n to  l i ne  3  of  the  GRAPHICl  b u f f e r,  rather  than  the 
r e s u lt  containing  <E>. 
In  effect  the  user  t o ld  the 
system  that  the  value  of  <C>  was  C2, 
that  the 
unknown  carry  was  the  carry  i n to  the  second  column 
(the  L+LsR  column). 

i ts  processing  r e s u lt  with 

i . e ., 

Processing  In  GRAPHIC2  and  GRAPHIC3  occurred  as 
follows:  GRAPHIC2  was  entered  and  the  elements  from 
l i ne  1  of  GRAPHICl  were  processed  i n t e r a c t i v e ly  to 
determine  t h e ir  operator  groups.  GRAPHIC3  was  then 
entered  and  these  groups  were  grown  as  new  nodes  in  the 
PBG,  Next  GRAPHIC2  was  reentered  and  the  elements 

441 

from  l i ne  2  of  GRAPHIC1  processed.  This  graphic2-
graphic3  loop  was  repeated  for  each  l i ne  in  GRAPHIC1. 
Below  is  shown  only  one  of  these  loops 
processing 
and  growing  the  elements  from  l i ne  3  of  GRAPHIC1. 

: 

In  GRAPHIC2  the  system  queried  the  user  to  deter­
for 

mine  possible  origins  (operators  and  t h e ir  inputs) 
the  elements 
represented  as  an  o r i g in  tree  as  shown  above.  This 
tree  is  displayed  below  in  a  more  conventional  s t y l e. 

in  question.  This  information  was 

Figure  7.  Origin  Tree 

the  top  element, 

the  path  w i th  the  operator:  assign  a  value 

The  system  analyzes  the  tree  and  decides  which  path 
represents  the  best  o r i g in  for 
in 
t h is  case  (ODD  R).  Here  there  are  only  two  a l t e r­
natives: 
to  the  carry  i n to  column  2, 
w i th  the  operator: 
system  chooses  the  l a t t e r,  based  on  i m p l i c it  ORIGIN 
rules  which 
r a t i ng  them  according  to  t h e ir 
function  currently  in  use 
i s: 

(AV  C2)  ,  and  the  path 
process  column 1,  (PC  1 ).  The 

it  to  choose  between  operators  by 

inputs.  The  decision 

t e ll 

where  an  input  is  "used" 
Thus  (AV  C2)  has  a  r a t i ng  of  0  while  (PC  1)  has  a 
r a t i ng  of  (3x2)-0  or  6.  The  format  of  the  operator 
groups  produced  in  GRAPHIC2  i s: 
l i s t)  output. 

operator  (input 

in  the  PBG. 

if  it  occurs 

In  GRAPHICS 

the  two  groups  from  GRAPHIC2  were 
incorporated  i n to  the  PBG.  The  second  group,  w i th 
(ODD  R)  as  the  output,  c o n f l i c t ed  with  an  e x i s t i ng 
group  in  the  PBG  and  led  to  r e s t r u c t u r i ng  of  the  PBG 
to  resolve  the  c o n f l i c t.  Conflicts  were  defined  by 
the  CONFLICT 
the  PBG  r u l e s. 

the  type  of  r e s t r u c t u r i ng  by 

rules, 

in  the  display  represents 

After  a ll  the  data  from  GRAPHICl  was  processed 
in  GRAPHIC2  and  GRAPHIC3  the  contents  of  GRAPHIC3 
were  displayed.  Each  l i ne 
a  node  in  the  PBG.  Node  10  contains  the  operator: 
test  to  see  if  R  can  have  the  d i g it  5  as  a  value, 
(TD  R  5 ).  Figure  8  shows  t h is  PBG  in  the  conven­
t i o n al  representation.  Note  that  the  c o n f l i ct  between 
(AEQ  R  4)  and  (ODD  R)  led  to  a  back-up  that  abandoned 
nodes  4,  5  and  6.  Thus  the  currently  active  nodes, 
the  ones 
that  define  the  current  context,  are  those 
joined  by  the  heavy  lines 

in  Figure  8. 

5.  Discussion 

The  i n i t i al  program,  PAS-I, 

is  an  a r t i f i c i al 

the 

inference 

from  verbal  behavior 
is  a  task  requiring  i n t e l­

i n t e l l i g e n ce  program  by  any  reasonable  c r i t e r i a.  The 
task  it  attempts, 
to  Problem  Behavior  Graph, 
ligence  when  done  by  humans.  The  mechanisms  used  are 
those  common  to  other  a r t i f i c i al 
programs 
grammars 
to  deal  w i th  the  surface  structure  of  natural  language, 
representation  of  knowledge,  matching,  and  h e u r i s t ic 
search 
in 
the  utterances. 

i n f er  information  not  d i r e c t ly  expressed 

that  tackle  somewhat  similar  tasks: 

i n t e l l i g e n ce 

to 

PAS-II  is  a  program  that  accomplishes  the  same 

cask  as  PAS-I.  Hence, 
it  too  Is  an  a r t i f i c i al  i n t e l­
ligence  program.  But  when  looked  at  s t r u c t u r a l ly  it 
more  closely  resembles  a  data  processing  framework 
or,  possibly,  a  language.  Something  has  happened  in 
going  from  PAS-I  to  PAS-II,  something  worth  i d e n t i­
fying  and  discussing. 

** 

Let  us  s t a rt  with  Planner  (3)  and  QA4  ( 8 ). 

These  systems  are 
perform  a  class  of  a r t i f i c i al  i n t e l l i g e n ce  tasks.  The 

for  w r i t i ng  programs  to 

languages 

Choose  to  maximise: 

(3  x  used-inputs) 
(unused-inputs) 

-

C o n f l i ct  and  PBG  rules  ere  described  in  d e t a il  in 
an  e a r l i er  paper  (15). 

Space  l i m i t a t i o ns  prevent  us 
e n t i re 

l i s t i n g. 

from  including  the 

442 

There  are  other  representatives  of 
e . g .,  POPI-ER  (1)  and  Conniver  (10,  11). 

t h is  class, 

exact  boundaries  of  these  tasks  are  obscure  but 
t h e ir 
central  core  is  clear  and  includes  a  large  f r a c t i on  of 
the  tasks  for  which  h e u r i s t ic  programshave  been  b u i lt 
--  theorem  proving,  robot  planning,  symbolic  manipu­
l a t i o n,  etc.  These  systems  were  formed,  e s s e n t i a l l y, 
by  taking  a  l i st  processing  framework  and  embedding 
w i t h in  it  some  of  the  ad  hoc  mechanisms  developed 
for  p a r t i c u l ar  h e u r i s t ic  programs.  They  include  back­
tracking,  a  generalized  matching  f a c i l i t y,  a  global 
data  base  (accessed  by  pattern  matching)  and  m u l t i­
processing  c o n t r o l.  Embedding  these  mechanisms  w i t h­
in  &  language  makes  possible  t h e ir  use  in  novel  com­
binations  (and 
nisms  available  in  higher  languages). 

in  i n t e r a c t i on  with  the  other  mecha­

This  same  embedding  of  mechanisms  into  a  language 

system  has  occurred  in  the  t r a n s i t i on  from  PAS-I  to 
FAS-II.  PAS-II  provides  a  framework  w i t h in  which  a 
class  of  Al  programs  can  be  easily  constructed.  This 
class  is  not  the  same  as  that  of  the  Planner/QA4 
type  system,  which  is  more  "mainline"  a r t i f i c i al 
i n t e l l i g e n c e.  Rather, 
as  l i n g u i s t ic  data  processing, 
being  the  processing  of  long  sequences  of  data 
(rather  than  j u st  a  sentence  at  a  time).  This  class 
includes,  of  course,  protocol  analysis. 
includes  a  number  of  other  tasks: 
content  analysis 
of  more  c l a s s i c al  v a r i e t i es  ( 9 ),  problem  space  con­
s t r u c t i on  ( 2 ), 
called  semantic 

test  grading,  and  what  is  coming  to  be 

it  appears  to  be  characterized 

the  essential  feature 

f i l t e r i n g. 

It  also 

The  embodiment  of  mechanisms  Into  a  language 

is 

The  f i r st  level 

the  e x p l i c it  control  structure 

framework  has  occurred  at  two  levels  in  PAS-II,  one 
corresponding  roughly  to  that  of  Planner/QA4  and  the 
other  more  specialized. 
is  repre­
sented  by  the  PAS-II  framework  of  run  modes,  r u le 
modes,  common  command  language,  e d i t i ng  system,  and 
control  s t r u c t u r e.  This  includes  a  set  of  mecha­
nisms  for  the  data  base  (the  run  modes),  a  matching 
f a c i l i ty  (the  common  mechanism  for  how  the  rules  work 
on  data),  and  a  backtrack  f a c i l i ty  (the  saving  of 
buffers  so  that  processing  can  be  undone).  Added  to 
this 
for  processing 
w i t h in  a  stage  and  passing  through  the  stages,  which 
corresponds  to  a  weak  method  (4) 
as  GPS1B  basic  methods  or  the  basic  methods  b u i lt  i n to 
the  goal  construct  in  Planner/QA4.  These  provide  a 
schema  of  operation  which, 
is  s t i ll  a  r a t i o n al  procedure  for  achieving  the 
overall  goal.  The  mechanisms  adopted  in  PAS-II  are 
somewhat  more  shaped  than  t h e ir  correspondents  in 
Planner/QA4,  e . g ., 
base  or  one  s t r a t i f i ed  by  a  general  context  mechanism, 
rather  the  data  is  organized  into  homogeneous  groups 
(the  modes)  along  s t r u c t u r al  l i n e s. 

there  is  not  a  single  global  data 

though  almost  content  f r e e, 

in  the  same  sense 

The  second  l e v el 

is 

the  specialization  of  the 

in 

tasks 
various  modes  to  specific  subtasks  inherent 
of  the  class: 
segmentation,  parsing,  normalization, 
etc.  The  specialized  r u le  systems  contain  the  knowl­
edge  about  the  processing.  Thus  w r i t i ng  any  sort  of 
legal  rules  w i t h in  a  given  r u le  system  generates  proc­
essing  of  the  r i g ht  sort  (though  it  may  not  do  the 
r i g ht  task)■ 
In  t h is  respect  providing  a  single  gener­
alized  r u le  system  or  scheme  for  pattern  matching  and 
pattern  evoked  actions  ( in  the  manner  of  Planner/QA4) 
would  move  more  of  the  knowledge  required  back  across 
the  boundary  from  the  language  system  (PAS-ID  to  the 
coding  w i t h in  the  system  (the  user  program  in  PAS-II, 
which  is 

the  set  of  actual  rules 

in  the  r u le  nodes). 

As  one  moves  PAS-II  in  the  d i r e c t i on  of  a 

generalized  system  for  a  wider  class  of  problems,  one 
can  expect  the  c o l l e c t i on  of  r u le  modes  to  increase, 

becoming  eventually,  a  l i b r a ry  in  the  classic  sub­
routine  l i b r a ry  sense.  The  system  designer  is  then 
faced  w i th  the  problem  of  providing  these  modes  with 
the  rules  needed  to  define  processing  in  the  various 
problem  domains.  However,  one  advantage  of  spec­
i a l i z ed  r u le  systems  is  that  when  t h e ir  structure 
is  highly  constrained  it  becomes  easy  to  predict 
the 
effect  of  modifying  rules  in  the  system  (as  compared 
to  predicting  the  effect  of  modifying  statements  in 
a  general  programming  language).  This  sets  the  stage 
for  the  development  of  self-modifying  systems  which 
rewrite 
improve  t h e ir  performance  in  some  data  processing 
task  (12,  13).  Such  a  c a p a b i l i ty  in  an  i n t e r a c t i ve 
PAS-II-like  system  would  enable  the  system  to  b u i ld 
or  modify  i ts  own  rules  for  a  p a r t i c u l ar  problem 
domain,  using  feedback  from  the  user  to  d i r e ct  the 
search  for  good  sets  of  r u l e s. 

their  own  rules  or, 

in  e f f e c t, 

learn  to 

The  evolution  from  PAS-I  to  PAS-II  in  analogy 

to  the  more  general  evolution  going  on  toward 
planner-like  language  systems  should  add  to  the 
awareness 
that  embedding  mechanisms  in  language 
remains  a  potent  scheme  f or  making  advances  in 
a r t i f i c i al 

i n t e l l i g e n c e. 

Acknowledgments 

This  paper  w i ll  appear 

in  the  preprints 

f or 

the 

t h i rd  International  Joint  Conference  on  A r t i f i c i al 
Intelligence  (IJCAI-73).  This  research  was  supported 
in  part  by  Research  Grant  MH-07732  from  the  National 
I n s t i t u t es  of  Health  and  in  part  by  the  Advanced 
Research  Projects  Agency  of  the  Office  of  the 
Secretary  of  Defense  (F44620-70-C-0107)  which  is 
monitored  by  the  Air  Force  Office  of  S c i e n t i f ic 
Research. 

References 

1.  Davies,  D.  J.  M.,  POFLER:  a  POP-2  planner.  MIP. 

School  of  University  of  Edinburgh. 

2.  Hayes,  J.  R,,  and  Waterman,  D.  A .,  Automatic 

Problem  Space  Construction,  Psychology  Department, 
Carnegie-Mellon  University,  1973. 

3.  Hewitt,  C a r l,  Description  and  t h e o r e t i c al  analysis 

of  planner:  A  language  for  proving  theorems  and 
manipulating  models  in  a  robot.  AI  report  TR-258 
(Ph.D.  t h e s i s ).  MIT  AI  Laboratory,  Cambridge, 
Massachusetts,  1972. 

4.  Newell,  A.,  Heuristic  programming: 

I l l - s t r u c t u r ed 

In  Aronofsky,  J.  S.  (ed.)  Progress  in 

problems, 
Operations  Research,  v o l.  3,  Wiley,  1969,  pp. 
362-414. 

5.  Newell,  A .,  and  Simon,  H.  A .,  Human  Problem 

Solving,  P r e n t i c e - H a l l,  Englewood  C l i f f s,  N.J. 
1972. 

6.  Newell,  A .,  A  t h e o r e t i c al  exploration  of  mechanisms 

for  coding  the  stimulus,  in  Melton,  A.  W.,  and 
Martin,  E.  (eds.)  Coding  Processes  in.  Human  Memory, 
Winston  and  Sons,  Washington,  D.C.,  1972,  pp. 
373-434. 

7.  Newell,  A .,  Simon,  H.  A .,  Hayes,  R.,  and  Gregg,  L., 
Report  on  a  workshop  in  new  techniques  in  cognitive 
research.  Computer  Science  Department,  Carnegie-
Mellon  University,  1972. 

8. 

9. 

Rulifson,  J.  F.,  Derksen,  J.  A.,  and  Waldinger, 
R.  J .,  QA4:  A  procedural  calculus  for  i n t u i t i ve 
reasoning,  Stanford  Research  I n s t i t u t e,  November 
1972. 

Stone,  P.  J .,  Dunphy,  D.  C,  Smith,  M.  S., 
O g i l v i e,  D.  M.,  The  General  Inquirer.  MIT, 
Cambridge,  Massachusetts,  1966. 

10.  Sussman,  Gerald,  and  McDermott,  Drew,  Why 

conniving  is  better  than  planning,  MIT,  Cambridge, 
Massachusetts,  A p r il  1972. 

11.  Sussman,  Gerald,  and  McDermott,  Drew,  Conniver 

Reference  Manual,  MIT,  Cambridge,  Massachusetts, 
May,  1972. 

12.  Waterman,  D.  A.,  Machine  learning  of  h e u r i s t i c s. 

Ph.D.  Thesis,  Computer  Science  Department, 
Stanford  University,  1968, 

13.  Waterman,  D.  A.,  Generalization  learning  tech­

for  automating  the  learning  of  heuristics, 

niques 
A r t i f i c i al  I n t e l l i g e n c e,  v o l.  1,  nos.  1  and  2, 
1970,  pp.  121-170. 

14.  Waterman,  D.  A.,  and  Newell,  A.,  Protocol  analy­

sis  as  a  task  for  a r t i f i c i al  i n t e l l i g e n c e. 
A r t i f i c i al  I n t e l l i g e n c e,  v o l.  2,  nos.  2  and  3, 
1971,  pp.  285-318. 

15.  Waterman,  D.  A.,  and  Newell,  A.,  Preliminary 
results  w i th  a  system  for  automatic  protocol 
analysis.  Carnegie-Melion  University,  Computer 
Science  Department,  1973. 

16.  Waterman,  D.  A.,  PAS-II  Reference  Manual, 

Psychology  Department,  Carnegie-Melion  University, 
1973. 

445 

