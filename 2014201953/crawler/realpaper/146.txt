The Complexity of Quantiﬁed Constraint Satisfaction Problems

under Structural Restrictions

∗

Georg Gottlob

Gianluigi Greco
Dip. di Matematica

Francesco Scarcello

Inst. f¨ur Informationssysteme
Technische Universit¨at Wien Universit`a della Calabria Universit`a della Calabria

DEIS

A-1040 Vienna, Austria
gottlob@dbai.tuwien.ac.at

I-87030 Rende, Italy
ggreco@mat.unical.it

I-87030 Rende, Italy

scarcello@deis.unical.it

Abstract

We give a clear picture of the tractability/intracta-
bility frontier for quantiﬁed constraint satisfaction
problems (QCSPs) under structural restrictions. On
the negative side, we prove that checking QCSP
satisﬁability remains PSPACE-hard for all known
structural properties more general than bounded
treewidth and for the incomparable hypergraph
acyclicity. Moreover, if the domain is not ﬁxed, the
problem is PSPACE-hard even for tree-shaped con-
straint scopes. On the positive side, we identify rel-
evant tractable classes, including QCSPs with pre-
ﬁx ∃∀ having bounded hypertree width, and QCSPs
with a bounded number of guards. The latter are
solvable in polynomial time without any bound on
domains or quantiﬁer alternations.

Introduction

1
Quantiﬁed constraint satisfaction problems (QCSPs) are a
generalization of constraint satisfaction problems (CSPs),
where variables may be existentially and universally quanti-
ﬁed, and nested quantiﬁcations are allowed. This framework
is clearly much more expressive than plain existential-CSP,
and may be fruitfully exploited for modeling a wide spectrum
of problems from several domains.
A QCSP instance (or quantiﬁed constraint formula) φ is
an expression of the form Q1 ¯V1 ··· Qm ¯Vm I, where I is a
constraint network (denoted by CN (φ)), Qi is a quantiﬁer in
{∃,∀} (with Qi (cid:4)= Qi+1), and ¯Vi is a set of variables, for
1 ≤ i ≤ m. The string of quantiﬁers Q1 ··· Qm is called
the preﬁx of φ. Recall that a constraint network is a triple
I = (Var , ¯U ,C), where Var is a ﬁnite set of variables, U is
the set of domains U(V ), for each variable V ∈ Var, and
C = {C1, C2, . . . , Cq} is a ﬁnite set of constraints. A con-
straint Ci = (Si, ri) consists of a list of variables Si called
constraint scope, and of a relation ri, called constraint rela-
tion, providing Ci’s allowed combinations of values for the
variables in its scope. Sometimes it is more comfortable to
denote Ci by its so called constraint atom ri(Si). Then, the

∗

This work was supported by the Austrian Science Fund (FWF)
project: Nr. P17222-N04 Complementary Approaches to Constraint
Satisfaction.

network I may be represented by the conjunction of all its
constraint atoms. For simplicity, we limit our attention here
to closed quantiﬁed constraint formulas, where all variables
occurring in I are quantiﬁed. However, all our results may be
easily extended to formulas with free variables.

consider

As an example,

the following quantiﬁed
∀S, X, Y, T, R, U, P ∃V, Z ∀W
constraint formula φe:
a(S, X, T, R) ∧ b(S, Y, U, P ) ∧ c(T, U, Z) ∧ d(W, X, Z) ∧
e(Y, Z) ∧ f(R, P, V ) ∧ g(X, Y ). This formula is a QCSP
instance, whose constraint network CN (φe) is represented by
the constraint atoms occurring in the conjunction. The quan-
tiﬁer preﬁx (short: preﬁx) of φe is the string ∀∃∀.

Not surprisingly, the increased expressive power of QCSPs
comes at a cost. Indeed, while deciding the satisﬁability of
traditional (i.e., purely existential) CSPs is NP-complete, this
problem is PSPACE-complete [Borner et al., 2003], in the
general quantiﬁed setting. Hence, much effort has been spent
to identify tractable classes of QCSPs.

These approaches can be divided into two main groups:
techniques that identify tractable classes of QCSPs by ex-
ploiting particular properties of constraint relations, and tech-
niques that identify tractable classes by exploiting the struc-
ture of constraint scopes, usually known as structural de-
composition methods. While several deep results have been
already achieved by techniques in the former group (see,
e.g., [Borner et al., 2003; Bulatov et al., 2000; Bunind et
al., 1995; Chen, 2004a; Creignou et al., 2001; Jeavons et
al., 1997]), only a few papers focused on structural de-
composition methods, though they were proven to be use-
ful in the non-quantiﬁed setting (see, e.g., [Dechter, 2003;
Gottlob et al., 2000]).
Recall that the structure of constraint network I is best rep-
resented by its associated hypergraph H(I) = (V, H), where
V = Var and H = {var(S) | C = (S, r) ∈ C}, and var(S)
denotes the set of variables in the scope S of constraint C.
Some graph-based techniques are based on the primal graph
G(H(I)) = (V, E) of H(I), where two variables are con-
nected in E if they occur together in some hyperedge (i.e., in
the scope of some constraint).

Chen recently presented an interesting result about struc-
turally tractable QCSPs [Chen, 2004b]. He describes a
polynomial-time algorithm for classes of QCSPs having (pri-
mal graphs with) bounded treewidth, ﬁxed domain, and ﬁxed
preﬁx.
In fact, the complexity of this algorithm depends

dramatically on the number of quantiﬁer alternations and on
the size of the largest variable domain. As noted in [Chen,
2004b], the same result has been independently derived by
[Feder and Kolaitis, 2004], by exploiting Courcelle’s theo-
rem about monadic second order logic on bounded treewidth
structures.

Notice that there is no indication that these results are op-
timal, and in fact several interesting questions arose, and will
be the subject of this paper:

(1) Are QCSPs having bounded treewidth tractable if do-

mains are not ﬁxed?

(2) May we extend this result to other structural notions,

possibly more general than bounded treewidth?

(3) Are there different kind of restrictions on quantiﬁed

constraint formulas that make QCSPs tractable?

The answers to these questions comprise both good news
and bad news. We prove strong hardness results, but we also
identify new tractable classes of QCSPs, having neither ﬁxed
bound on domains nor ﬁxed bound on quantiﬁer alternations.
Our main contributions, shown in Figure 1, are the following:
(cid:1) We prove that, without the ﬁxed domain restriction, even
QCSP instances whose structure is a tree and whose preﬁx
is ∀∃ are co-NP-hard. Moreover, adding further alternations
we get complete problems for all levels of the polynomial
hierarchy. It follows that this problem is PSPACE-complete
if there are no bounds on the quantiﬁer preﬁx.
(cid:1) On the positive side, we prove that, if the preﬁx is ∃∀ (or
some substring of it), then solving acyclic QCSPs is fea-
sible in LOGCFL and hence in polynomial time. More-
over, this tractability extends to all known generalizations
of acyclicity, and in particular to bounded hypertree-width
QCSPs [Gottlob et al., 2000].
(cid:1) We prove that, for ﬁxed domains, the tractability result
for bounded treewidth is almost optimal. Indeed, solving
QCSPs over the binary domain {0, 1} remains PSPACE-
complete even if the structure is an acyclic hypergraph,
whose incidence graph has bounded treewidth, and whose
primal graph has small (i.e., logarithmic) treewidth.
(cid:1) All these results show that traditional structural techniques
do not help very much, but for some simple cases and with
limited quantiﬁcation.
Indeed, our hardness proofs show
that the presence of quantiﬁers radically alters the structural
properties of the constraint scopes. We thus realize that it is
worthwhile taking into account how they interact with the
scope structure, and in fact considering quantiﬁers as part
of the scope structure itself. Following this idea, we iden-
tify a different kind of restriction on quantiﬁed constraint
formulas that ensure tractability and that is incomparable
with the other structural classes. In particular, for any ﬁxed
k, we deﬁne the class k-GQCSP of k-guarded QCSPs, that
are solvable in polynomial time, without any restriction on
domains or quantiﬁer alternations.
2 Quantiﬁed CSPs
Let I = (Var ,U,C) be a constraint network. An assignment
σ for a set of variables ¯V ⊆ Var is a function mapping each
variable V ∈ ¯V onto its domain U(V ) ∈ U. If ¯V = Var, σ
is said complete, otherwise it is a partial assignment. We say
that a complete assignment σ satisﬁes I, denoted by σ |= I,

(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)(cid:1)

(cid:1)(cid:1)
(cid:2)(cid:2)
(cid:1)(cid:1)
(cid:2)(cid:2)

(cid:1)

.

(cid:1)

(cid:1)

(cid:1)

for ¯V

(cid:1) ⊃ ¯V is an assignment σ

Figure 1: Structural restrictions and (in)tractable QCSPs.
if for each constraint (Si, ri) ∈ C, σ(Si) ∈ ri. An extension
of σ to a set ¯V
such that
(cid:1)(V ) = σ(V ) for each V ∈ ¯V . We denote by ext(σ, ¯V
(cid:1)) the
σ
set of all the extensions of σ to ¯V
. For the trivial assignment
(cid:1)) is clearly the
σ∅ for the empty set of variables, ext(σ∅, ¯V
set of all assignments for ¯V
Let φ : Q1 ¯V1Q2 ¯V2Q3 ¯V3 . . . Qm ¯Vm I be a QCSP instance,
and let σ0 be the trivial assignment σ∅. A strategy for φ is
any function s such that, for each pair Qi, σi−1, with 1 ≤ i ≤
m, s(Qi, σi−1) is either one assignment in ext(σi−1, ¯Vi), if
Qi = ∃, or the whole set of possible extensions ext(σi−1, ¯Vi),
if Qi = ∀. A complete assignment σm is derivable from a
strategy s if there are m − 1 assignments σ1, . . . , σm−1 such
that σi ∈ s(Qi, σi−1), for any 1 ≤ i ≤ m. Then, s is a
solution for φ if all derivable assignments satisfy I. A QCSP
instance is satisﬁable iff it has a solution.

It is worthwhile noting that, in the deﬁnition of QCSPs,
different variables have different domains, in general. This is
especially useful in the quantiﬁed setting. However, in the
literature, QCSPs are sometimes deﬁned over a unique do-
main U or, equivalently, with the same domain U(V ) for each
variable V . We say that such QCSPs are untyped, in contrast
to the general ones, called typed. The following proposition
shows that the two formalisms are in fact logically equivalent.
Proposition 2.1 For any QCSP instance φ, there exists an
(cid:1)
. Moreover, if CN (φ) is a bi-
untyped equivalent instance φ
(cid:1)
nary network, φ

can be computed in polynomial time.

Notice that going from typed to untyped instances may be
exponential for non-binary networks, as the former setting
allows more succinct and efﬁcient representations.

We remark that all complexity results in this paper hold
for both settings. Indeed, we prove membership results and
provide algorithms for the general typed setting, and prove
hardness results by using either binary networks, or a unique
binary domain for all variables.

We say that a class S of hypergraphs has the bounded hy-
pertree width property, denoted by BHTW, if there is a k > 0
such that every hypergraph in S has hypertree width at most
k [Gottlob et al., 2000]. Similarly, we deﬁne the property
BTW, meaning bounded treewidth [Robertson and Seymous,
1986] of the primal graph (of the constraint hypergraph), and
the property BITW, meaning bounded treewidth of the inci-

dence graph. Moreover, we say that a class S of hypergraphs
has the small hypertree width property, denoted by SHTW, if
the hypertree width of every hypergraph H ∈ S is at most
log |H|. The small treewidth property STW of primal graphs
is deﬁned similarly. We also consider the property ACYCLIC
(resp., TREES) of any class of acyclic hypergraphs (resp., pri-
mal graphs).

Moreover,

We study how the complexity of QCSPs change as a func-
tion of quantiﬁer alternations and of constraint structures.
Moreover, we distinguish the case of arbitrary domains, de-
noted by ANY, and of binary domains, denoted by {0, 1}.
Let ¯Q be a string of quantiﬁer alternations, S a hyper-
graphs property, and D a domain property in {ANY,{0, 1}}.
Then, QCSP( ¯Q,S,D) is the problem of deciding whether
an instance φ ∈ class( ¯Q,S,D) is satisﬁable, where
class( ¯Q,S,D) is any class of QCSP instances over domains
of kind D, with alternation preﬁx ¯Q, and whose associated
hypergraphs have property S.
3 Structural methods do not help very much
3.1 Some tractable instances
From [Gottlob et al., 2000], we already know that
QCSP(∃, BHTW, ANY) is in polynomial time, and the same
holds for any structural restriction stronger than bounded
hypertree-width.
is easy to see that
it
QCSP(∀, BHTW, ANY) is even easier. We next show that also
QCSP(∃∀, BHTW, ANY) is tractable.
Let φ be a QCSP instance, I = (Var ,U,C) the constraint
network of φ, and ¯Y be a set of universally quantiﬁed vari-
(cid:1)) a constraint of I over variable sets ¯X
ables. Let r( ¯X, ¯Y
(cid:1)
and ¯Y
is the set of ¯Y variables occurring in the
, where ¯Y
(cid:1)) the relation containing all
scope of r. Denote by cart( ¯Y
(cid:1)
combination of values from the domains of variables in ¯Y
,
(cid:1)) = ×Y ∈ ¯Y (cid:1)U(Y ).
i.e., cart( ¯Y

of values for variables ¯Y

Then, deﬁne ¯Y-red(r) as the relation containing all and
only those tuples t of relation r such that, for any combi-
(cid:1) ∈ r. Note that,
(cid:1)
nation t
(cid:1) = ∅, we get ¯Y-red(r) = r; for the
for the special case ¯Y
(cid:1) = ∅, we simply require all combinations of
special case ¯X
(cid:1)),
values for ¯Y
, that is, ¯Y-red(r) = r, if r is precisely cart( ¯Y
otherwise it is the empty relation.
Denote by ¯Y-red(φ) the QCSP obtained from φ by replac-
ing each constraint relation r by ¯Y-red(r).
Lemma 3.1 For any QCSP φ and set of universally quanti-
ﬁed variables ¯Y , ¯Y-red(φ) can be computed in logspace.

, t[ ¯X] · t

(cid:1)

(cid:1)

(cid:1)

After the above lemma and exploiting the fact that no use-
ful assignment is lost with this transformation, we can show
the following.
Theorem 3.2 QCSP(∃∀, BHTW, ANY) is in polynomial time.
Moreover, it is LOGCFL-complete, and hence tractable and
parallelizable.

3.2 Encoding Boolean formulas as acyclic QCSPs
To any CNF formula Φ = c1∧. . .∧cm over Boolean variables
¯V = {V1, . . . , Vn}, we associate a binary acyclic constraint
network I(Φ) = (Var ,U,C) . This constraint network will
be used hereafter for characterizing the complexity of acyclic
and quasi-acyclic quantiﬁed CSPs.

Figure 2: Constraint network I(¯Φ) in Theorem 3.4. In the
right-bottom box, encodings of constraints in Theorem 3.7.

j

j

i ,¬v

j ,| 1 ≤ j ≤ m − 1} and ¯Sv = {Sv

Consider the following CNF formula, that we use as a run-
ning example: ¯Φ = (V1 ∨ V2 ∨ V3)∧ (V1 ∨¬V4)∧ (V1 ∨ V6 ∨
V4) ∧ (V2 ∨ V6). Then, Figure 2 shows the constraint struc-
ture (i.e. the constraint hypergraph) of I(¯Φ). Note that in this
case hypergraph and primal graph representations coincide,
as CN (¯Φ) contains only binary constraints.
The set of variables Var is the union of a set of clause
variables ¯C = {Cj | 1 ≤ j ≤ m} corresponding to the m
clauses of Φ, of a set ¯B = {Bi | Vi ∈ ¯V }, corresponding
to the n Boolean variables occurring in Φ, and of two sets
¯Sc = {Sc
i ,| 1 ≤ i ≤ n −
1} of special variables, called clause selectors and variable
selectors, respectively.
For a variable Vi of Φ, the domain of I(Φ) contains literal
constants vi and ¬vi associated with its truth-values. More-
over, for any clause cj in which Vi occurs, the domain of I(Φ)
i } encoding the truth
contains a literal constant in {v
j
value for Vi that makes cj true. We denote by li (resp., l
i )
any of these (positive or negative) literals, and by ¬li (resp.,
¬l
i ) its complement. Moreover, we denote by satLit(cj) the
set of literals that make cj true. E.g., for c2 = (V1 ∨ ¬V4) in
¯Φ, satLit(c2) = {v2
In more detail, the domains of I(Φ) variables are the fol-
lowing: for any variable Cj (corresponding to clause cj of
Φ), U(Cj) = satLit(cj); for any Boolean variable Bi,
U(Bi) = {vi,¬vi}; for any clause-selector Sc
j ) =
(cid:1)
j(cid:1)≥j U(Cj(cid:1)); ﬁnally, for any variable-selector Sv
i ) =
(cid:1)
i(cid:1)≥i U(Bi(cid:1)).
Intuitively, Boolean variables encode a truth-value assign-
ment to Φ, whereas any clause variable Cj chooses some
literal in satLit(cj) that satisﬁes it. Any selector variable
may take a value coming from either variable connected to it.
Thus, any choice of all variable selectors corresponds to the
propagation of a literal value li coming from some Boolean
variable Bi in the left branch. Similarly, any choice of clause
selectors corresponds to the propagation in the right branch
j
of some literal l
k satisfying some clause cj. If for all possible
propagations from both branches, no pair li,¬l
j
i of comple-

j , U(Sc
i , U(Sv

1,¬v2

}.

4

j

(cid:1)

j(cid:1)
h , l

(cid:1)

j
i )

j
k, l

j

j

(cid:1)

j

j

|

j

l

1 , Sc

> i}.

j(cid:1)
k , l

j

h) | l

> j}.

are values in [1 . . . m].

j+1) and for the constraint (Sc
> j} ∪ {(l
(cid:1)
> j}.

mentary literals meets at the topmost constraint of the net-
work, then the values of Boolean variables encode a satisfy-
ing truth-value assignment for Φ. We next describe the con-
straints in C that implement the above idea, where the indices
(cid:1)
actually are values in the interval [1 . . . n] and where
i and i
the indices j, j
• The topmost constraint (Sv
1), called evaluate, has
a constraint relation consisting of {(li,¬l
i ∈
satLit(cj)}. Note that evaluate is satisﬁed only by assign-
ments where its variables take complementary literals.
• For any constraint (Sv
i , Bi) between a variable-selector Sv
i
and a Boolean variable Bi, its constraint relation consists of
the tuples: {(li, li)} ∪ {(li(cid:1) , li) | i
(cid:1)
• For any constraint between a pair of adjacent variable-
i , Sv
i+1) and for the constraint (Sv
selectors (Sv
i , Bn) with
i = n − 1, the constraint relation is {(li(cid:1) , li(cid:1)) | i
(cid:1)
>
i} ∪ {(li, li(cid:1)) | i
> i}.
(cid:1)
• For any constraint (Sc
j , Cj) between a clause-selector Sc
j
and a clause variable Cj, its constraint relation consists of
h) | l
h ∈ satLit(cj)} ∪ {(l
h ∈
the tuples: {(l
j
h, l
k ∈ satLit(cj(cid:1)), j
j(cid:1)
satLit(cj), l
• For any constraint between a pair of adjacent clause-
j , Sc
selectors (Sc
j , Cm) with
j = m − 1, the constraint relation consists of the tuples:
{(l
h ∈ satLit(cj(cid:1)), j
k ∈
h ) | l
h ) | l
j(cid:1)
j(cid:1)
j(cid:1)
h ∈ satLit(cj(cid:1)), j
j(cid:1)
(cid:1)
satLit(cj), l
If µ is a truth-value assignment for all variables ¯V of Φ,
then, σµ, denotes the assignment such that σµ(Bi) = vi if
µ(Vi) = true, and σµ(Bi) = ¬vi if µ(Vi) = f alse.
Lemma 3.3 Let µ be a truth-value assignment for all vari-
ables ¯V of Φ and σµ the corresponding assignment for ¯B.
Then, µ is a satisfying assignment for Φ if and only if there
(cid:1) ∈ ext(σµ, ¯C) such that, for every
exists an assignment σ
(cid:1)(cid:1) (cid:4)|= I(Φ) holds.
(cid:1)(cid:1) ∈ ext(σ
, ¯Sv ∪ ¯Sc), σ
σ
After this lemma, we immediately get that, even for acyclic
binary constraint networks with just two quantiﬁer alterna-
tions, solving a quantiﬁed CSP is intractable.
Theorem 3.4 QCSP(∀∃, TREES, ANY) is co-NP-hard.
Proof. From a CNF Boolean formula Φ, we build in poly-
nomial time QC(Φ) = ∀ ¯B, ¯C ∃ ¯S I(Φ), where I(Φ) is
the acyclic constraint network associated with Φ. From
Lemma 3.3, satisfying assignments for Φ are in one-to-one
correspondence with assignments to the variables in ¯B and
¯C such that all their complete extensions do not satisfy I(Φ).
Thus, Φ is not satisﬁable iff QC(Φ) is satisﬁable.
2
3.3 Intractable acyclic instances
After having shown in the previous section the tractability for
∃∀ and the intractability for ∀∃, we now settle the complexity
of acyclic QCSPs with arbitrary quantiﬁer preﬁxes.
Theorem 3.5 For any natural number m ≥ 1,
1. QCSP((∀∃)m∀, BHTW, ANY) is ΠP
2. QCSP((∃∀)m∃∀, BHTW, ANY) is ΣP

hardness holds for QCSP((∀∃)m, TREES, ANY), too;
2m-complete, and
hardness holds for QCSP((∃∀)m∃, TREES, ANY), too.

2m−1-complete, and

is satisﬁable iff QC(Ψ(cid:1)) is satisﬁable.

Proof.
For space limitations we only prove Hardness for
Point 2, here. For any m ≥ 1, consider the ΣP
2m-complete
problem of deciding whether a quantiﬁed Boolean formula
Ψ(cid:1) = ∃V1∀V2 ···∀V2m¬Φ is satisﬁable, where Φ is in CNF.
From this formula, we build in polynomial time the follow-
ing instance of QCSP((∃∀)m∃, TREES, ANY): QC(Ψ(cid:1)) =
∃B1∀B2 ···∀B2m, ¯C ∃ ¯S I(Φ). From Lemma 3.3, it can be
seen easily that Ψ(cid:1)
Membership. The proof is by induction. First observe that,
given any instance Q = ∃ ¯V1∀ ¯V2φ of QCSP(∃∀, BHTW, ANY),
its complementary problem Qc (deciding whether for all as-
signment σ to ¯V1 there exists an extension to ¯V2 that does
not satisfy φ) is in LOGCFL and hence in polynomial time,
by Theorem 3.2 and the fact that LOGCFL is closed under
complementation. Then, we prove the basis of the induc-
tion, m = 1. The problem QCSP(∀∃∀, BHTW, ANY) is in
Indeed, let Q = ∀ ¯V1∃ ¯V2∀ ¯V3φ be any in-
ΠP
1 = co-NP.
stance of this problem. Then, its complement can be de-
cided in NP: guess an assignment σ to ¯V1 and check that
(cid:1) ∈ ext(σ, ¯V2) there is a complete as-
for all assignment σ
(cid:1)(cid:1) ∈ ext(σ
(cid:1)
, ¯V3) that does not satisfy all the con-
signment σ
straints in φ. From the observation above, this check is feasi-
ble in polynomial time. Moreover, QCSP(∃∀∃∀, BHTW, ANY)
is in ΣP
2 , as any instance of this problem may be solved
by a non-deterministic Turing machine with an oracle for
QCSP(∀∃∀, BHTW, ANY). The induction step is a simple adap-
tation of the above reasoning for any m > 1.
2
Corollary 3.6 The quantiﬁed constraint satisfaction problem
(on arbitrary domain) is PSPACE-complete, even if restricted
on constraint networks whose structure is a tree.
3.4 Fixed domain helps only with ﬁxed arity
We now show that hypergraph acyclicity does not help in
making easy the QCSP problem, even if we consider Boolean
domains only. The same holds even in case we additionally
require that the incidence graph has bounded treewidth, and
the primal graph has small (logarithmic) treewidth. This en-
tails that the problem remains intractable as long as we have
non-ﬁxed arities, even for very simple constraint interactions.
Theorem 3.7 For any natural number m ≥ 1,
• QCSP((∀∃)m, ACYCLIC ∩ BITW ∩ STW,{0, 1}) is ΠP
complete;
• QCSP((∃∀)m∃, ACYCLIC ∩ BITW ∩ STW,{0, 1}) is ΣP
2m-
complete.
Proof. Let Φ be a Boolean formula, and I(Φ) = (Var ,U,C)
its associated acyclic constraint network. We consider the
,{0, 1},C(cid:1)), deﬁned as follows. For
network I
each variable X ∈ Var, Var(cid:1)
contains |U(X)| distinct vari-
(cid:1)(Xi) = {0, 1} for
ables X1, ..., Xlog |U (X)|, with domain U
each Xi. For each constraint r(X, Y ) in C, C(cid:1)
contains a con-
(cid:1)(X1, ..., Xlog |U (X)|, Y1, ..., Ylog |U (Y )|), whose con-
straint r
(cid:1)
straint relation is such that, for each tuple (xi, yj) in r, r
contains the tuple (enc(xi), enc(yj)), where the string of bits
enc(xi) (resp. enc(yj)) is the binary encoding of domain
value xi (resp. xj). The right-bottom box in Figure 2 shows
(cid:1)(¯Φ) associated to the
a portion of the constraint network I
formula ¯Φ of our running example. Observe that the con-
(cid:1)(Φ) is in ACYCLIC ∩ BITW ∩ STW. Indeed,
straint network I

(cid:1)(Φ) = (Var(cid:1)

2m−1-

2

(cid:1)(Φ) is acyclic, and the number
the hypergraph associated to I
of variables in each hyperedge is bounded by 2 log c, where
c is the size of largest domain over all the variables in Var.
Therefore, the treewidth of the primal graph is at most 2 log c.
Moreover, it is easy to check that the treewidth of the inci-
(cid:1)(Φ) is 3. Finally, observe that there exists a
dence graph of I
one-to-one correspondence between assignments to variables
(cid:1)(Φ), and thus the result immediately follows
in I(Φ) and in I
from Theorem 3.5.
Corollary 3.8 The quantiﬁed constraint satisfaction problem
is PSPACE-complete, even if restricted on Boolean constraint
networks whose structure is in ACYCLIC ∩ BITW ∩ STW.
4 Guarded formulas and tractable CSPs
In this section, we describe a wide class of quantiﬁed con-
straint formulas that are tractable, even if there is no constant
bound on domain sizes or quantiﬁer alternations. Recall that
any QCSP instance φ may be represented by a logical expres-
sion, as shown in Section 1 for QCSP φe. Technically, let us
denote the pure logical formula of φ (without the encoding of
relations, domains, etc.) by form(φ).

Following [Kolaitis et al., 2000], we denote by FO∧,+ the
fragment of ﬁrst order sentences where arbitrary quantiﬁca-
tions and conjunctions are allowed, but where negations and
disjunctions are forbidden. They observed that the existential
fragment ∃FO∧,+ of FO∧,+ has the same expressive power
as the constraint satisfaction problems. By allowing any kind
of quantiﬁers, this observation may be clearly extended to the
connection between general FO∧,+ formulas and quantiﬁed
constraint formulas. Notice that, in this more general set-
ting, there are different equivalent logical representation of
the same instance. For example, one may use parentheses for
distinguishing subformulas and delimiting quantiﬁer scopes.
In this section, we represent QCSPs by FO∧,+ formulas that
are not necessarily in the traditional prenex form. Notice,
however, that each FO∧,+ formula can be easily transformed
into an equivalent prenex formula.
4.1 The fragment k-GQCSP of k-guarded QCSPs
We show that, for each constant k, a simple and appealing
fragment of FO∧,+ is decidable in polynomial time. Since
we have no bound on the number of variables in a formula,
we assume w.l.o.g. that each variable is quantiﬁed over only
once, i.e., quantiﬁed variables are not reused. In the follow-
ing, we denote by free(ψ) the free variables of a logical for-
mula ψ.
Deﬁnition 4.1 The class k-GQCSP of k-guarded QCSPs
consists of those QCSPs instances φ whose formula form(φ)
∗
∗
k of FO∧,+ deﬁned as follows. G
belongs to the fragment G
k
is the smallest subset of FO∧,+ such that:
• every atom belongs to G
∗
k;
• if φ1 and φ2 ∈ G
k, then φ1 ∧ φ2 ∈ G
∗
∗
k;
• let α1, . . . , αi be atoms, where i ≤ k, and let ψ be a for-
k. If the free variables free(ψ) ⊆ var(α1) ∪ ··· ∪
∗
mula in G
var(αi), then, for each tuple of variables ¯y and each quanti-
ﬁer Q ∈ {∃,∀}, the formula ψ
(cid:1) : Q¯y(α1 ∧ ··· ∧ αi ∧ ψ)
k. The set of atoms {α1, . . . , αi} is referred to
∗
belongs to G
as the guard of ψ

and is denoted by guard(ψ

(cid:1)).

(cid:1)

2

Example 4.2 Consider again QCSP instance φe presented in
the Introduction, and the following equivalent instance, where
form(φe) is rewritten as
ψ = ∀S, X, Y, T, R, U, P ( a(S, X, T, R) ∧ b(S, Y, U, P ) ∧

∃V f(R, P, V ) ∧ ∃Z ( g(X, Y ) ∧ c(T, U, Z) ∧
∀W d(W, X, Z) ∧ e(Y, Z) ) )
i.e., ψ ∈ G
∗
This is a 2-guarded constraint formula,
2.
The guard of formula ψ is guard(ψ) = {a(S, X, T, R),
b(S, Y, U, P )}. For the formulas ψ1 = ∃V f(R, P, V ),
ψ2 = ∃Z ( g(X, Y ) ∧ c(T, U, Z) ∧ ∀W d(W, X, Z) ∧
e(Y, Z) ) and ψ3 = ∀W d(W, X, Z), we have the fol-
lowing guards: guard(ψ1) = {f(R, P, V )}, guard(ψ2) =
{g(X, Y ), c(T, U, Z)}, and guard(ψ3) = {d(W, X, Z)}. 2
Note that the above deﬁnition of k-guardedness is con-
genial to the speciﬁc syntax of quantiﬁed CSPs and differs
from that of k-guarded ﬁrst order logic [Andreka et al., 1998;
Gr¨adel, 1999].
In the standard formalisms of the guarded
fragment GF of ﬁrst order logic or of the k-guarded fragment
GFk of ﬁrst order logic [Gottlob et al., 2003], the guards
of an existentially quantiﬁed subformula ψ are added con-
junctively to ψ (guard(ψ) ∧ ψ), just as for G
∗
k. However,
the guards of a universal formula ψ are added in form of an
implication: guard(ψ) → ψ. This is much more natural,
since these logics have negation and guardedness needs to be
correctly preserved under negations. For example, the nega-
tion of a guarded formula ¬∃ ¯Y (g( ¯Y ) ∧ ψ( ¯Y )) is logically
equivalent to ∀ ¯Y (g( ¯Y ) → ¬ψ( ¯Y )). Since the logic FO∧,+
of constraint formulas has conjunction (∧) as unique binary
connective, it is syntactically impossible to express an im-
plication guard(ψ) → ψ in FO∧,+ (in fact, this is also se-
mantically impossible). On the other hand, since negation
is missing in FO∧,+, no problems involving “wrong guards”
can arise through negation when using the natural (but non-
standard) guards introduced for the above deﬁned fragments
∗
k of FO∧,+.
G
For the k-guarded fragment GFk of ﬁrst order logic (i.e.,
for the standard k-guarded fragment) the following tractabil-
ity result was shown in [Gottlob et al., 2003]:
Proposition 4.3 The
evaluat-
ing a GFk formula φ over a set of ﬁnite relations D is in
O(|φ| × |D|k).

combined complexity of

∗

Let us now show that also the class k-GQCSP of k-
guarded QCSPs is tractable, notwithstanding the “nonstan-
dard” guards for universally quantiﬁed subformulas.
Lemma 4.4 There is an algorithm TRANSFORM which for
each QCSP φ ∈ k-GQCSP computes a pair (D, φ
∗) where
∗ ∈ GFk, such that φ is satisﬁed
D is a ﬁnite database and φ
iff D |= φ
. The TRANSFORM algorithm runs in logspace.
Proof. Let φ ∈ k-GQCSP, and let R be the set of con-
(cid:1) =
straint relations of CN (φ). Consider a subformula ψ
∀ ¯Y (guard(ψ)∧ ψ) of form(φ), where ∀ ¯Y is a maximal pre-
ﬁx of universally quantiﬁed variables, and where guard(ψ)
is a conjunction of m atoms ri( ¯Yi, ¯Xi), with 1 ≤ i ≤ m ≤ k,
where ¯Yi are the variables in its scope included in ¯Y , and ¯Xi
its other variables, hence ¯Xi ∩ ¯Y = ∅. For 1 ≤ i ≤ m, we
denote by ri↓ the relation obtained from the constraint rela-
tion ri by keeping all ¯Yi-columns and projecting out all ¯Xi
columns, i.e., ri↓ :=

(cid:2)

¯Yi ri.

Assume that for some 1 ≤ i ≤ m, ri↓ is not equal to the
Cartesian product cart( ¯Yi) of ¯Yi domains. That is, ri↓ does
not consist of precisely all possible combinations of constants
for all ¯Y variables occurring in ri. Then one tuple ¯a of such
constants is not in ri↓ and thus the atom ri( ¯Yi, ¯Xi) cannot
be satisﬁed for the substitution ¯Yi = ¯a. Since ri occurs posi-
tively in φ, φ cannot be satisﬁed. The key observation is thus
that, whenever φ is satisﬁed, for 1 ≤ i ≤ m, ri↓ must be
equal to cart( ¯Yi). Algorithm TRANSFORM starts by check-
ing whether this is true. From Lemma 3.1, this check can be
implemented to run in logspace: just compute ¯Y-red(ri ↓),
and check that it is not empty. If this test fails for at least
one guard relation ri, then TRANSFORM outputs the for-
mula false. Otherwise, let gψ be a new constraint atom with
constraint scope ¯Y , whose relation is the join of the ri↓ rela-
(cid:1)).
tions. Now, consider the set of free variables ¯X = free(ψ
If ¯X (cid:4)= ∅, since φ is a k-guarded formula, there are at most
k atoms in φ that cover ¯X. Let gψ(cid:1) be a new constraint atom
with constraint scope ¯X, whose relation is the projection over
¯X of the join of these guard atoms. Moreover, let g be a new
constraint atom with constraint scope ¯X ∪ ¯Y , whose relation
is the join of gψ and gψ(cid:1) (or just gψ, if ¯X is empty). Note
that, since k is ﬁxed, TRANSFORM may compute g from
its input φ in logspace. Then, TRANSFORM replaces our
(cid:1) = ∀ ¯Y (guard(ψ)∧ ψ) by the equivalent sub-
subformula ψ
(cid:1)(cid:1) = ∀ ¯Y (g → guard(ψ) ∧ ψ). Note that this
formula ψ
transformation does not change the set of free variables, as
(cid:1)(cid:1)). Thus, the set of atoms that cover these
free(ψ
in form(φ) will be the
variables and acts as the guard of ψ
guard of ψ

in the new formula.

(cid:1)) = free(ψ

(cid:1)(cid:1)

(cid:1)

After having done this for all universal guarded subformu-
∗ ∈ GFk. Let
las, TRANSFORM has generated a formula φ
D the database consisting of all constraint relations of CN (φ)
plus all relations like g computed for modifying the universal
quantiﬁcations. It can be seen that φ is satisﬁable iff D |= φ
∗
.
Moreover, the entire algorithm runs in logspace.
2

Theorem 4.5 For each ﬁxed k, the satisﬁability of any QCSP
in the class k-GQCSP can be checked in polynomial time.
Proof. Follows from Lemma 4.4 and Proposition 4.3.

2

4.2 Extending the k-GQCSP fragment
When looking at the fragment k-GQCSP, and even more
generally, at QCSPs in which universal quantiﬁers appear,
we observe that the expressive power of universal quantiﬁ-
cation is rather poor.
In fact, as already observed in the
proof of Lemma 4.4, a subformula ∀ ¯Y r( ¯Y , ¯X) can only
be true if the projection over ¯Y of r is equal to the carte-
sian product cart( ¯Y ) representing the set of all tuples that
can be composed from all possible domain elements from
the respective domains. This is a rather stringent condi-
tion. On the other hand, by standard k-guards of the form
(r1 ∧ r2 ∧ ··· ∧ rm) → ψ, we can express some other in-
teresting properties. For example by standard guards, one
may express an inclusion dependency stating that part of one
constraint relation must be contained in another constraint re-
lation. To add expressive power, we thus suggest to allow
the use of standard guards together with conjunctively speci-
ﬁed guards (for universally quantiﬁed subformulas). We thus

(cid:1)

deﬁne the fragment k-GQCSP+ just as k-GQCSP in Def-
inition 4.1 with the following addition: If the free variables
free(ψ) ⊆ var(α1) ∪ ··· ∪ var(αi), then, for each tuple of
: ∀¯y(((α1 ∧ ··· ∧ αi) → ψ)
variables ¯y the formula ψ
∗
belongs to G
k.
After the results in Section 4.1, it is easy to see that,
for each ﬁxed k, the satisﬁability of any QCSP in the class
k-GQCSP+ can be checked in polynomial time. Moreover,
we are able to show that k-GQCSP+ is strictly more expres-
sive than k-GQCSP (for space reasons, we defer the proof to
the full paper).
References
[Andreka et al., 1998] H. Andreka, J. van Benthem, and I. Nemeti.
Modal languages and bounded fragments of predicate logic.
Journal of Philosophical Logic, 27(3):217–274, 1998.

[Borner et al., 2003] F. Borner, A. Bulatov, A. Krokhin, and P.
Jeavons. Quantiﬁed Constraints: Algorithms and Complexity. In
Proc. of CSL’03, pp. 58–70, 2003.

[Bulatov et al., 2000] A. Bulatov, A. Krokhin, and P. Jeavons. Con-
straint satisfaction problems and ﬁnite algebras. In Proc. of
ICALP’00, pp. 272–282.

[Bunind et al., 1995] H.K. Buning, M. Karpinski, and A. Flogel.
Resolution for Quantiﬁed Boolean Formulas. Information and
Computation 117(1):12–18, 1995.

[Chen, 2004a] H. Chen. Collapsibility and Consistency in Quanti-
ﬁed Constraint Satisfaction. In Proc. of AAAI’04, pp. 155–160,
2004.

[Chen, 2004b] H. Chen. Quantiﬁed Constraint Satisfaction and

Bounded Treewidth. In Proc. of ECAI’04, pp. 161–165, 2004.

[Creignou et al., 2001] N. Creignou, S. Khanna, and M. Sudan.
Complexity Classiﬁcations of Boolean Constraint Satisfaction
Problems. SIAM Monographs on Discrete Mathematics and Ap-
plications, 7, 2001.

[Dechter, 2003] R. Dechter. Constraint Processing. Morgan Kauf-

man, 2003.

[Feder and Kolaitis, 2004] T. Feder and P.G. Kolaitis. Closures and

dichotomies for quantiﬁed constraints. Manuscript, 2004.

[Gottlob et al., 2000] G. Gottlob, N. Leone, and F. Scarcello. A
Comparison of Structural CSP Decomposition Methods. Artiﬁ-
cial Intelligence, 124(2): 243–282, 2000.

[Gottlob et al., 2001] G. Gottlob, N. Leone, and F. Scarcello. The
complexity of acyclic conjunctive queries. JACM, 48(3):431–
498, 2001.

[Gottlob et al., 2003] G. Gottlob, N. Leone, and F. Scarcello. Rob-
bers, marshals, and guards: game theoretic and logical character-
izations of hypertree width. JCSS, 66(4):775–808, 2003.

[Gr¨adel, 1999] E. Gr¨adel. On the restraining power of guards. Jour-

nal of Symbolic Logic, 64:1719–1742, 1999.

[Jeavons et al., 1997] P. Jeavons, D. Cohen, and M. Gyssens. Clo-

sure Properties of Constraints. JACM, 44(4):527–548, 1997.

[Kolaitis et al., 2000] Ph. G. Kolaitis and M. Y. Vardi. Conjunctive-
JCSS,

and Constraint Satisfaction.

Query Containment
61(2):302–332, 2000.

[Mamoulis and Stergiou, 2004] N. Mamoulis and K. Stergiou. Al-
gorithms for Quantiﬁed Constraint Satisfaction Problems. In
Proc. of CP’04, pp. 752–756.

[Robertson and Seymous, 1986] N. Robertson and P.D. Seymour.
Graph Minors II. Algorithmic aspects of tree width. Journal of
Algorithms, 7:309–322, 1986.

[Schaefer, 1978] T.J. Schaefer. The Complexity of Satisﬁability

Problems In Proc of. STOC’78, pp. 216–226, 1978.

