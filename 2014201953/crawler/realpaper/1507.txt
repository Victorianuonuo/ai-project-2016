A  DEDUCTIVE  QUESTION  ANSWERING  SYSTEM  ON  RELATIONAL  DATA  BASES 

Computer  Science  D i v i s i o n,  E l e c t r o t e c h n i c al  L a b o r a t o ry 

K o i c hi  F'urukawa 

Tokyo,  J apan 

ABSTRACT 

a 

of 

on 

f or 

new 

paper 

The  search  s t r a t e gy 

a n s w e r i ng 
u s i ng 
a 
p r o v i ng 

base 
theorem 
is 
on 

f o r m a l i z a t i on  of  a 
a 

s u b s t i t u t i o ns 
t he  b r e a d th 
is 

system 
theorem  p r o v i ng 
p r o c e d u re 

d e s c r i b es 
q u e s t i on 
d a ta 
A 
domain 

T h is 
d e d u c t i ve 
r e l a t i o n al 
t e c h n i q u e. 
f i n i te 
p r o c e d u re  based 
f o r m u l as  w h i ch  employs 
i n t o r u d c e d. 
to  s et  o p e r a t i o ns  of 
a re 
to 
V i r t u al 
i n t r o d u c i ng 
d e d u c t i ve 
F u r t h e r m o r e,  a  c o n d i t i o n al  domain 
one 
r e l a t i o n al  v i ew 
w h i ch 
1i  nk 

a 
i n v e s t i g a t ed  and  a  d i r e ct  p r o of 
e q u i v a l e nt 
f i r st  search 
is 
t h en  expanded 
which 
in  o r d er 
e f f i c i e n c y. 
means 
of 
t he 
u t i l i z i ng 
system. 
i n t r o d u c ed  as 
to  g i ve  a 
base 
r e p r e s e nt  e x c e p t i o n al  cases  u s i ng  some 

i n c o r p o r a t ed 
t he 
i n c r e a se 
r e l a t i o ns 

t he  v i r t u al  domains  and 

to  a  pseudo  r e l a t i o n al 

s e v e r al 
c a p a b i l i ty 

t he  p r o of  p r o c e d u re 

r e l a t i o n al  a l g e b ra 

base 
r e a l i z ed 

axioms 
of 
the 

search 
by 

d a ta 
a rc 

is  used 

l o g i c al 

d a ta 

i n to 

and 

can 

t he 

is, 

of 

(Data  Base  Access 
f e a t u r es 

implemented 

is 

in  QJJSP. 

t r a n s f o r m a t i on 

system 

P l a n n e r)  which  embodies 

c a l l ed  DBAP 
t h o se 

i  n f o r m at i o n. 
A  query 

1. 

I n t r o d u c t i on 

in 

the 

Many 

l o g i c al 

i n f e r e n ce 

groups 
have  been  c o n c e n t r a t i ng 

r e s e a r ch 
f i e ld 
to  r e p r e s e nt  knowledge1  and 

a r t i f i c i al 
t h e ir 
to 
sense 
The  knowledge  d a ta  bases  a re  o r g a n i z ed 
those 
in  o r d er 
and 
These 
have  been  p r e v e n t i ng  us 
l a r ge 
d a ta 

i n t e l l i g e n ce 
e f f o r ts  on  how 
p e r f o rm 
r e a s o n i n g. 
in  very  c o m p l i c a t ed  ways 
v e ry  h i gh 
o p e r a t i o n al 
from  e x p a n d i ng 
bases. 

f u n c t i o n s. 
c o m p l e x i t i es 

to 
r e a l i ze 
s t r u c t u r al 

knowledge 

to  v e ry 

common 

a n d / or 

l e v el 

them 

how 

in 

have 

t h e re 

l a r ge 

is  assumed 

commercial 

h a n d, 
v e ry 

t he 
o t h er 
to  d e v e l op 

t he  d a ta  base  r e s e a r ch  a r e a. 

On 
p r o j e c ts 
bases 
of  d a ta  base 
s i m p le  manner 
s t r u c t u r e s :. 
s i m p le  s t r u c t u r es  have  been  d e v e l o p ed 
and 
p a r a l l el  s e a r c h i ng  c a p a b i l i ty  a re  b e i ng 
in  many  p l a c e s. 

been  many 
d a ta 
T h is  k i nd 
in  a  r e l a t i v e ly 
s i m p le 
f or  such 
e x t e n s i v e ly 
hardware  systems  w i th 
developed 

E f f i c i e nt  search  a l g o r i t h ms 

to  be  used 
c o n s e q u e n t ly 

purpose 

s p e c i al 

some 

and 

has 

Our  c u r r e nt 

r e s e a r ch  g o al 

is 

to  combine 

two  s e p a r a te  e f f o r ts 
base  w i th 

t he  d e d u c t i ve  c a p a b i l i ty 

to  b u i ld  up  a  v e ry 
[ 8 ], 

t h e se 
l a r ge  d a ta 
[ l l ]. 

Codd, 

E.  F. 

[ 2] 

in 

query  w r i t t en 
to  a  sequence  of 

to  c o n v e rt  any 
sublanguage 
o p e r a t i o ns 
completeness 
a l g o r i t hm  can  be  c o n s i d e r ed  as  a 
a n s w e r i ng 
a 
b a s e.  On  t he  o t h er  h a n d,  G r e e n,  C. 

(QA)  p r o c e d u re 

o r d er 
of 

show 

t he 

on 

to 

an 
a 

a l g o r i t hm 
r e l a t i o n al 

i n t r o d u c ed 
in 
r e l a t i o n al  a l g e b r a i c, 
r e l a t i o n al 
His 

r e l a t i o n al 

a l g e b r a. 

t he 

\k] 

f o r m a l i sm 

f i r st  o r d er 

f o r m a l i z ed 
l o g i c. 

B. 
on 
t h e ir 
by  a  s et  of  axioms  and 
is  e x t r a c t ed 
t he 
q u e s t i o n. 

from 

is 

t h at  knowledge 

a  d e d u c t i ve  QA  system  based 
p o i nt 
oV 
r e p r e s e n t ed 
t he  q u e s t i on 

The  e s s e n t i al 
is 
t he  answer  of 
r e f u t a t i on 

p r o of  of 

t h at 

a 

is 

In 

f or 

l o g i c al 

t h e se 
a 

q u e r i es  which 

p a p e r, 
i n t r o d u c i ng 

e x p r e s s i o ns 
t he  s e t. 

two 
f o r m a l i s ms 
p r o of  p r o c e d u re 

t h i s, 
by 
s e t,  where 

are 
f or 
are 
A  p r o of 
r e q u i re  a ll  answers 

combined 
a 
f i n i te 
i n t e r p r e t ed  as  s et  o p e r a t i o ns  on 
p r o c e d u re 
s a t i s f y i n g t h e g i v en s p e c i f i c o. t i on i s p r e s e n t e d. 
It 
s u b s t i t u t i o ns 
i n t e r m e d i a te 
system  g e n e r a t es  an  access  p l an 
and 
answers  s a t i s f y i ng 
o p e r a t i o ns 
c o n s i d e r ed  as 
f i r st 
search 
t he  p r o of  p r o c e d u re 

based  on 
an 
the 
base, 
t he  a ll 
s et 
are 
b r e a d th 
i n to 

p r o of 
e q u i v a l e nt 
t he 

s p e c i f i c a t i o n. 
r e l a t i o n al 

p r o c e d u re 
f o r m u l a s. 
d i r e ct 

d i r e ct 
of 
r e s u lt 

expanded 
s t r a t e gy 

to 
e x e c u t ed 

t he  accees  p l a n. 

t he  d a ta 
to  get 

n o t i o ns 
and  a re 

The 
a l g e b ra 

As 
p r o o f, 

i n c o r p o r a t ed 

to  e x p r e ss 

p l an 

t h en 

t he 

t he 

t he 

t he 

of 

of 

of 

is 

S t o n e b r a k e r,  M. 

[ 1 0] 

i n t r o d u c ed 

r e l a t i o n s) 

in  o r d er 

the  n o t i on  of 
to 
and 
In 

a  s et  of  non-ground  a x i o m s. 

t he  d e d u c t i ve 

c a p a b i l i t y, 

them  by  means  of  query  m o d i f i c a t i o n. 
c o n s i d e r ed 

r e l a t i o ns 

a re 

to 

by 

d e f i n ed 

(we  c a ll 

them  vi r t u al 

views 
p r o v i de  users  w i th 
r e a l i z ed 
t h is  p a p e r,  v i r t u al 
p r o v i de  a  semantic  model  of 
a re 
query  m o d i f i c a t i on  process  can 
s u b s t i t u t i on  p r o c e ss  of  a 
f o r m u l a, 
a s s o c i a t ed  a x i o m. 
domain 
used 
r e l a t i o n al 
e x c e p t i o n al  cases  u s i ng  some 

is  p a r t i c u l a r ly 
a 
d a ta 

r e l a t i o n al 
base 

axiom 
g i ve 

of  which 

r u le 

t he 

to 

is 
An  axiom  c a l l ed 

be 

the  base 

c o n s i d e r ed 

r e l a t i o ns  and 
The 
as 
f o r m u la  by  an  e q u i v a l e nt 
t he 
c o n d i t i o n al 
is 
i n t e r e s t i n g. 
a 
pseudo 
view 
r e p r e s e nt 

to 
can 
i n f o r m a t i o n. 

which 
l i nk 

g i v en 
a 

by 

It 

In  a d d i t i o n,  some  c o n s i d e r a t i o ns  on 

d e l e t i on 
r e d u n d a n c i es  w i ll  be  p r e s e n t e d.  O p t i m i z a t i on 
The 
t r a n s f o r m a t i on  system  DBAP  w i ll 

of 
of  t he  access  p l an  w i ll  a l so  be 
implemented 
be  b r i e f ly  e x p l a i n e d. 
c o n c l u s i on 
some 
done  w i ll  be  d e s c r i b e d. 

In 
s e c t i o n, 
f u t u re  r e s e a r ch  works 

e o n e i d e r e d. 

t he 
to  be 

query 

l a st 

and 

t he 

2. 

Fo r m a li z at i on 

G e n e r a l l y,  a 
of  axioms  and  a 

s et 
f or  a  g i v en  q u e r y. 
of  our  system 

in 

f o r m al  QA  system  c o n s i s ts 

theorem  p r o v er 

F i g.  1  shows 

of 

a 
to  get  answers 
t he  c o n f i g u r a t i on 

t e r ms  of 

t he 

f o r m a l i s m. 

f o r m al 
q u e s t i on 
r e l a t i o n al  d a ta 
and  R a p h a e l, 

two 
t u p l e - w i se 
N a t u r al  Lanr:uarf»-3:  Furukawa 

base 
c l a u se  w h i ch 
There  a re 
t he 

to 

50 

In  a 
has 

f o r m al  s y s t e m,  each  datum 

in 

e x p r e s s ed  by  a  ground  c l a u se 
n ot 

c o n t a in 

any 
r e p r e s e n t a t i o n s: 

d a ta 
(a 
v a r i a b l e s ). 
n a m e l y, 

t he 

be 
does 
t y p i c al 

r e p r e s e n t a t i on  and 

t he  d o m a i n - w i se 

p u t t i ng  a 
expression  as 

p r e f ix 

read 
'Find  a il  ?x  such  that  ( i ) . . . '. 

symbol 

and 

the 

f i le  consists 

The  i n t e n t i o n al 

which  define  users' 
The  objective  of 

axioms 
r e l a t i o n s. 
views 
the  l o g i c al  structure  of 

of  non-ground 
views  or 
v i r t u al 
introducing  users' 
independent  of 
the  r e l a t i o n al  data  base. 
that  we  have  a  r e l a t i o n al  data  hase 

is  to  keep  the  query  language 

Assume 

which  consists  of  the 

following  base  r e l a t i o n s: 

EMP(NAME, DNAME  SAL) 
DEPT(WAME  MGR) 

to  define  a 

where  the  domais  DNAME  in  EMP  and  NAME 
in  DEPT 
are  both  the  set  of  departments.  Assume  also  that 
a  user  wants 
r e a l ! i on 
In  the  v i r t u al  r e l a t i on 
VEMP(NAME  DNAME  SAL  MGR). 
VEMP, 
the  employee 
r e l a t i o n,  but 
r e l a t i o n.  The  domain  MGR  is 
been 
the  employee  r e l a t i o n,  and  we  c a ll 
v i r t u al  domain  a  t r a n s i t i ve  domain. 

to  have 
the  department  r e l a t i on  to 
kind  of 

the  domain  MGR  belongs 

to  the  department 

considered 

transfered 

it  belongs 

v i r t u al 

from 

t h is 

fact 

to 

in 

in 

terms  of  the  VEMP  r e l a t i o n, 

the  fact  that 
the  manager  of  an  employee  i 
as 
VEMP.MGR(i,x).  The  QA  system  has  to  transform 
t h is  expression  to  the 
of 
l i t e r a ls  on  the  base  r e l a t i o n s: 

is  x  is  expressed 

conjunction 

following 

Let  us  consider  the  query  "Who  is  the  manager 
In  terms  of  the  v i r t u al  r e l a t i on 

t h is  question  is  l o g i c a l ly  expressed  by 

of  Mr.  SMITH  ?". 
VEMP, 

N a t u r al 

L a n r u a £ 0 - 3:  Furukawa 

60 

(3?x)(3i)(VEMP.NAME(i, 

'SMITH' 

A  VEMP.MGR(i,?x)). 

( 2) 

By  substituting 
righthand  expression  of  the  equivalence  sign  = 
( l ),  we  obtain  the  following  expression: 

in  (2)  by  the 
in 

the  second 

term 

(a? x ) ( 3 i ) ( a j ) ( 3 y) 

(VEMP.NAME(i,'SMITH' )  A  EMP. DMME( i , y) 
A  DEPT.NAME(j,y)  A  DEFT.MGR( ,1 ,?x )) . 

f o r,  we  have  obtained  the  expression  in  terms 
underlined 
the  base 
the 
the 

So 
of 
l i t e r a l. 
corresponding  base 
following  axiom: 

relations  except 

transformed 

r e l a t i on 

l i t e r al 

l i t e r al 

to 
by 

This 

the 

is 

(Vi)(Vx)(VEMP.NAME(i,x) 

i  EMP.NAME(i,x)). 

type  of  axiom 

This 
axiom,  and  a  query  which  does  not 
v i r t u al  r e l a t i on  l i t e r a ls  is  called  a  base  query. 

is  called  a  simple  domain 
include  any 

It 

the 

relations 

is  obvious 

i n s u f f i c i e nt 

terras  of  v i r t u al 

trnasfromation  by 

that  any  query  which 

is 
in 
is 
specified 
to  an  equivalent  base  query  by  logical 
translated 
the 
inference.  However, 
resolution  rule  which  is  based  on  the  modus  ponens 
is 
to  get  a ll  answers 
which  satisfy  the  given  specification.  We  can 
prove 
it  easily.  Denote  a  query  by  F[?x]  and  the 
required  answers  by 
a  base  query  G[YxJ  by  applying  the  resolution 
G  [  ?  x  ]  ~v  F  [  ?  x  ]  .  There fore, 
r ul e s , 
{?x|  G[?xll  £  {?x|  F f ? x ] l, 
equality 
holds  only  if  G[?x]  ^  F[VxJ. 

If  we  obtain 

if  we  want 

{?x|  F[?x]}. 

where 

then 

the 

to 

structure 

the  control 

So  f a r,  these  transformations  can  be  realized 
far 
by  the  query  modification  technique  [10].  As 
it  is 
as 
equivalent 
the 
GL-resolution  which  is  known  to  be  valid  only  for 
a  horn  set  [13].  But  there  exist  more  complicated 
axioms  which 
inference 
including  the  ancester  resolution.  We 
capability 
w i ll  introduce  a  few  such  axioms  later  on. 

is  concerned, 
resolution 
in 

the  whole 

require 

input 

the 

A  v i r t u al  domain  can  be  defined  in 

terms  of 
other  predefined  v i r t u al  domains.  The  axioms  for 
such  domains  transform  a  l i t e r al  to  a  conjunction 
of 
the  base 
r e1at ion 1i t er  als. 

l i t e r a ls  some  of  which  are  not 

In  this  paper,  we  consider  only  e x i s t e n t i a l ly 
the 
that 
applying 
the 
e x s i s t e n t i a l ly 
further  simplify  the 

quantified  queries. 
resulting 
queries 
transformations  are  also 
quantified. 
notation  for  queries  by  omitting  a ll  q u a n t i f i e r s. 

It  is  easily  shown 

Therefore,  we 

after 
only 

base 

3.  Deletion  of  Redundancies 

A  base  query  which  is  obtained  so 

far  may 
have  some  redundancies.  Let  us  consider  the  base 
r e l a t i o n s:  EMP(NAME  DNAME);  DEPT(NAME  MGR  LOG), 
the  v i r t u al  r e l a t i o n s:  VEMP(NAME  DNAME  LOG); 
and 
VDEPT(NAME  MGR).  Note 
is 
the  following  query  is 
t r a n s i t i v e. 
given: 

the  LOG  domain 

Assume 

that 

that 

VDEPT.MGR(j,?x)  A  VEMP.L0G( i ,1*1*2) 
A  VEMP.DNAME(i,y)  A  VDEPT.NAME(j,y) 

( 3) 

Tt  inquires  the  manager  of 
which 
expression  (3) 
base  query: 

to 
the  employee  i  located  at  1*1*2  belongs.  The 
following 

the  department  y 

transformed 

the 

to 

is 

DEPT.MGR(,1,?x) 
A  EMP.DNAME(i,z) 
A DEPT.DNAME(k,z) 
A DEPT.LOC(k,1*1*2) 
A  EMP.DNAME(i,y) 
A  DEPT.NAME(t1,y) . 

(M 
( 5) 
( 6) 
(7) 
( 8) 
(9) 

Let  us  concentrate  our  attention  on  the  l i t e r a ls 
(S)  and  (8).  They  are  the  same  except  the  values. 
However,  as  a  datum 
is  uniquely  designated  by 
specifying 
the  r e l a t i on  name,  the  domain  name  and 
the  tuple  i d,  these  two  variables  z  and  y  must 
refer 
by  the  following  axiom: 

the  same  datum.  This  fact  can  be  expressed 

Tuple  Id  Axiom 

For  any  r e l a t i on  REL  and  i ts  arbitrary  domain 

D,  the  following  statement  holds: 

(Vi)(Vx)(Vy)(REL.D(i,x)  A  REL.D(i,y) 

=  REL.D(i,x)  A  x  =  y ). 

(10) 

is 

By  applying  t h is  axiom,  to  the  above  two 
y 
exactly  the  same.  Further, 
transformed  to 

l i t e r a l s, 
replaced  by  z  and  these  two  l i t e r a ls  become 
is 

l i t e r al 

the 

(9) 

DEPT.NAME(j,z). 

( 9 )' 

in 

This  s i m p l i f i c a t i on 

is  not  the  same  as  the 
factoring  operation 
the 
proof 
procedure,  because  a ll  variables  are  quantified  by 
the  tuple  id  axiom  is  a  meaningful 
a.  Therefore, 
axiom.  Note  that  the  application  of 
t h is  axiom 
cannot  be  done  by 
input  resolution,  because  we 
need  to  resolve  two  l i t e r a ls  simultaneously. 

resolution 

r e l a t i on 

Now,  l et  us  assume  that  the  domain  NAME 

the  DEPT 
easily  shown  that  the  l i t e r a ls  (6)  and 
the 
following  axiom: 

in 
is  a  key  domain.  Then,  it  is 
( 9 )'  are 
the 

represented  by 

same. 

This 

fact 

is 

Key  Domain  Axiom 

For  any  r e l a t i on  REL  and  i ts  key  domain  K, 

the  following  statement  holds: 

(Vi ) (Vj ) (Vx ) ( R E L . K ( i , x)  A  KEL.K(j,x) 
=  REL.K(i,x)  A  i  =  j ). 

( U) 

By  applying  t h is  axiom  on  (6)  and  ( 9 ) ',  we  obtain 
the  following  simplified  base  query: 

DEPT.MGR(k,?x)  A  EMP.DNAME(i,z) 

A  DEPT.NAME(k,z)  A  DEPT.L0C(k,1*1*2) . 

(l?) 

1*.  Data  Base  Accesses  and  Proof  Procedure 

When  a  proof  contains  multiple  data  base 
accesses, 
it  is  recommended  to  plan  the  data  base 
accesses  very  carefully  in  order  to  keep  the  proof 
process  e f f i c i e n t.  We  w i ll  set  up 
following 
de si gn  obj ectives: 

the 

N a t u r al  Lanfuiajre-3:  Furukawa 

61 

1.  Do  not  access  to  the  (logically)  same  tuple 

in  a  relation  more  than  once. 

2.  Get  a ll 

tuples  which  satisfy 

the  given 

conditions  to  a  certain  relation  at  a  time. 

3.  When  more  than  one  tuple  are  to  be  accessed, 
plan  the  access  order  to  minimize  the  number 
of  data  base  accesses. 

As  mentioned 

in  section  2,  each  constituent 
of  each  tuple  is  expressed  by  a  ground  clause. 
But 
the  expression  is  merely  conceptual  and  we  do 
not  have  such  representations  in  the  actual  data 
Instead,  relational  databases  are  usually 
bases. 
organized 
in  such  a  way  that  the  data  base  access 
by  tuples  is  much  more  efficient  than  by  domains. 
In  order 
to  achieve  the  tuple-wise  access  to  the 
data  base,  a ll  l i t e r a ls  in  a  base  query  associated 
to  the  same  tuple  of  the  same  relation  have  to  be 
together.  We  call  such  a  set  of  l i t e r a ls 
grouped 
an  access  subclause.  Since  a ll 
in  an 
access  subclause  have  the  same  relation  name  and 
the  same  tuple  id  which 
to 
associate 
those  clauses  in  the  same  tuple,  we  can 
abbreviate  the  notation  for  access  subclauses  by 
factoring  out 
the  relation  name  and  omitting  the 
tuple  i d.  For  example,  the  access  subclauses  of 
(.1 ?) ar e expr es sed as.: 

introduced  only 

l i t e r a ls 

is 

Al:  DERI1  (MGR(?x),  NAME(z),  L0C(M2)J, 
A2:  EMP  {DNAME(z)}. 

(13) 
(lh) 

the 

namely, 

inference 

The  second  objective  is  deeply  related  to  the 
rule  mentioned  in 
discussion  on 
section  ?.  The  same  argument  holds 
in  getting 
any  access  subclause  must  be 
data; 
substituted  by  an  equivalent  set  of 
But 
since  the  set  consists  of  a ll  tuples  which  satisfy 
the  access  subclause, 
the 
associative 
search  strategy. 

is  obtained  by 
the  breadth 

it 
retrieval  with 

tuples. 

first-

be 

expressed 

f i r st  associative 

breadth 
(we  denote 
can 

retrieval 
it  by  r)  on  an  access 

The 
operation 
subclause 
operation  of  the  selection  and  the  projection  of 
the  relational  algebra.  Denote  the  selection  of  a 
relation  REL1  with 
condition  Di  =  a  by 
RELl[Di  =  a]  and  the  projection  of  a  relation  REL? 
to 
Assume  that 

the  domains  Dj ,. ..,Dk  as  REL2(Dj  . ..  Dk). 

by  a  compound 

a 

A  =  REL D l ) l ( x l ) , .. . J)i(xi) ,Di+l(c)} 

(15) 

where  x ] , . . . , xi  are  variables  and  c  is  a  constant. 
Then, 
is  given  by  the  following  algebraic 
r(A) 
expression: 

r(A)  -  REL[Di+l  =  C](D1  . ..  Di.) . 

(l6) 

For  example,  the  application  r  on  (13)  results  i n: 

r(Al)  ~  DEPT[LOC  =  442MGR  NAME). 

(17) 

hand,  C0NN1VER 

subclause  by  a  goal  statement  with  a  corresponding 
associative  retrieval  pattern.  But  as  mentioned 
earlier, 
the  depth  f i r st  search  strategy  employed 
in  it  is  very  inefficient  when  we  want  to  get  a ll 
answers  which  satisfy  the  given  condition.  On  the 
[12]  has  a  programming 
other 
f i r st  search 
support  to  deal  with 
strategy,  but  programmers  are 
for 
controlling  the  overall  proof  procedure.  We  w i ll 
generate  an  efficient  data  base  access  program 
from  the  given  set  of  access  subclauses. 
This 
approach 
the  PODB's  approach  developed 
by  Haral.dson,  A.  [ s ]. 

the  breadth 

responsible 

resembles 

least  one  variable 

The  proof  procedure 

Let  us  consider  the  case  in  which 

there  are 
than  one  access  subclauses.  We  say  two 
if 
in  common. 

more 
access  subclauses  are  associated  if  and  only 
they  share  at 
Assume  that  two  associated  access  subclauses  are 
given. 
f i r st  obtains  two 
separate  one-level  search 
trees  Al  and  A2  by 
executing  each  associative 
r e t r i e v a l.  Then,  it 
generates  another  one-level  tree  which  consists  of 
a ll  answers  satisfying  both  access  subclauses  by 
equating 
This  operation  corresponds 
operation  of  the  relational  algebra  [ l |,  [ 2 ].  We 
denote  the  equi-join  of  Al  and  A?  with  common 
variables  x l , . . . , xi  by  Al[xl 
by  A1.A2  when 
required  to  be  specified  e x p l i c i t l y. 

the  shared  variables 
to 

in  these  trees. 
the 

the  common  variables  are 

. ..  xi  |A2,  or  simply 

equi-Join 

not 

tree. 

as  shown 

straight-line 

in  an  arbitrary  order. 

The  association  relation  is  a  binary  relation 
and  can  be  described  by  a  graph  having  access 
subclauses  as  nodes  and  the  shared  variables  on 
the  corresponding  arcs.  We  call  this  graph  an 
association  graph.  When  there  are 
three  access 
subclauses,  the  corresponding  association  graph  is 
either 
in  Fig.  3  or 
triangular  as  shown  in  Fig.  4. 
In  either  cases, 
the  result  is  obtained  by  executing  two  successive 
join  operations 
In  order 
to  specify  the  order  of  join  operations  and  give 
proper  output 
relations,  we  introduce  a  kind  of 
tree  called  a  program 
is  constructed 
from  the  association  graph  by  an  algorithm  P  which 
the  appendix.  Some  examples 
w i ll  be  given 
the 
shown  in  Fig.  5  and  6  may  be  helpful 
idea  of  program 
trees  in 
the  association 
Fig.  5(a)  -  5(c) 
in  Fig.  3  and  Fig.  6(a)  -  6(c)  to  Fig.  4. 
graph 
Let  us  consider  about  the  execution  of  a  program 
tree. 
is  executed  at  f i r s t,  and  a 
father  node  is  executed  only  after  a ll  of  i ts  sons 
are  executed,  where  an  execution  of  a  node  A 
consists  of  r ( A ),  followed  by  the  join  operations 
with  i ts  a ll  sons  (no  join  operations  are  defined 
for  leaf  nodes).  The  multiple  join  operations  for 
a  single  node  can  be  done  in  an  arbitrary  order. 
Moreover, 
done 
simultaneously.  The  multiple  joins  for  a  branched 
tree  Tl  in  Fig.  7  are  expressed  by 

trees. 
correspond 

The  program 

theoretically 

leaf  node 

to  get 

they 

can 

be 

to 

in 

A 

It 

We  denote 
application  of  r  on  A  by  A.. 

relation 

the 

resulting 

Now, 

t h i rd  design 
objective.  Any  query  can  be  described  in  PLANNER 
language 
[6]  simply  by  expressing  each  access 

us  consider 

the 

let 

the  other  hand, 

On 
straight-lined  program  tree  T2  in  the  same 
are  expressed  by 

the  successive  joins  for  a 
figure 

Bn.Bn-1 

B2.B1.A. 

from 

the 

Bn.(Bn-l.(  ..  .(B2.(B1.A))...)). 

N a t u r al  Lanpiiap:e-3  :  Furnkawa 

62 

F i g.  6.  Three  program 
the  a s s o c i a t i on  graph 

t r e es  of 
in  F i g.  4. 

It 

is 

is 

t he 

t he 

a r cs 

t r ee  by 

t h i rd  d e s i gn  o b j e c t i ve 

t he  a s s o c i a t i on  g r a p h. 

in 
Now, 
r e s t a t ed 
t he  p r o b l em  of  c o n s t r u c t i ng  an  o p t i m al  program 
e f f i c i e n cy 
t o t al  s i ze  of  a ll  o u t p ut 
t he  p r o of  p r o c e s s. 
b o th 
in 
i t. 

p r o p o r t i o n al 
t he 

r e a s o n a b le 

to  measure 

to 
t u p le  number 

The 
t he 
The 
c o n s t r u c t i on 
few  h e u r i s t ic 
t he 
node 
The  a l g o r i t hm  P  c o n s t r u c ts  a 

t r ee 
embedding  a 

a  program 

is 
and 
t he 

as 
t r e e. 
of 
t he 
r e l a t i o ns  g e n e r a t ed  d u r i ng 
s i ze  of  a  r e l a t i on 
domain 
o p t i m i z a t i on 
a l g o r i t hm 
is 
s t r a t e g i es  which  s e l e ct  a 
a s s o c i a t i on 
program 
t r ee 
T h e r e f o r e, 
e a r l i e r. 
f o l l o w i n g: 

g r a p h. 
in  r e v e r se  o r d er 
we 

of 
done 

e x e c u t i o n. 
nodes 
t he 

r e s t r i c t ed 
adopt 
a re 

h e u r i s t i cs  we 

s u i t a b le 

program 

number 

s e l e ct 

l e ss 

The 

i ts 

by 

to 

in 

1. 
2. 

3. 

S e l e ct  a  node  w i th  s m a l l er  degree  e a r l i e r. 
S e l e ct  a 
e a r l i e r. 
S e l e ct  a  node  w i th  more  ?  v a r i a b l es  e a r l i e r. 

l e ss  c o n s t a nt 

node  w i th 

l i t e r a ls 

The  h e u r i s t i cs  1 
to  3. 
h e u r i s t i cs  as  P*. 

We 

denote 

is  a p p l i ed  p r i or 

a l g o r i t hm  P  w i th 

to  2  and  2  p r i or 
t h e se 

t he 

5..  C o n d i t i o n al  Domain 

It 

is  n ot  easy 

t he  r e l a t i o n al  d a ta  b a s e. 
t he  domain  NAME 

a re 

a l l o w ed 
t h is  o r g a n i z a t i on 

in 
t h at 
employees 
t u p l e, 
employees 
However, 
come 
to 
we  cannot  express 

b e l o ng 

in  F i g.  2 

to  appear 
is  adequate 

to  deal  w i th  e x c e p t i o n al  cases 
For  example,  assume 
is  a  k e y. 
S i n ce  no 
in  more  t h an  one 
no 
one  d e p a r t m e n t. 
has 
T h e n, 
as 

t h an 
s a y,  Mr.  SMITH 

to  more 
t h a t, 

'R&D'  and 

r e l a t i on 

'SALES'. 

o n ly 

t h is 

f a ct 

in 

if 

t h is 

it  may  happen 
b e l o ng  to  b o th 

a 

of 

to 

The 

new 

t h at 

o n ly 

node 

t h e se 

r i g h t. 

r e l a t i on 

to  be  used 

e x p r e s s i o ns 

c o n s i s ts 
in 

t he 
r e l a t i on 

a re  e v a l u a t ed 
o b t a i n ed 

from 
by 
t he  domains 
t he  s u c c e e d i ng  o p e r a t i o n s. 
t he 
t he 
the 
in 

t he  a r cs 
of 
them 
t he  g r o u n d f a t h er  node,  w h i ch 
t he 

v a r i a b l es  w h i ch 
from 
on 
a re 

r e p r e s e nt 
to 
t he  node 
shared 
by 

Note 
l e ft 
e x e c u t i ng 
w h i ch  a re 
We  w i ll  put 
o u t p ut 
f a t h er  node. 
f a t h er 
node 
t u rn  w i ll  be  used  as 
l i nk 
c o r r e s p o n d i ng  J o in  o p e r a t i o n. 
v a r i a b l es 
u n d e r l i n ed 
of 
r e s u l t, 
t he  a l g e b r a ic 
t r e e,  e . g.  F i g.  6 ( a ), 

a re 
e x p r e s s i on 
is  g i v en  b y: 

v a r i a b l es 
In  F i g.  5  and  6, 

t he 
t he 
As  a 
program 

k i n d. 
a 

Some 
and 

t h is 

f or 

on 

(18) 

A  base  query  may  contain  some  comparison 
and/or  between  a 

l i t e r a ls  between  two  variables 
variable  and  a  constant, 
15000. 

such  as 

They  are  put  on  the  appropriate  nodes  or 

N a t u r al 

Langu 

a g e - 3: 
63 

F u r u k a wa 

is 

to 

shown 

names 

(NAME 

to 
i s, 

DNAME) 

in  F i g.  8. 

schema 
That 

is 
between 

created 
employee 

long  as  we  keep  the  NAME  domain  as  a  key  domain. 
The  t r a d i t i o n al  way  to  manage  t h is  s i t u a t i on 
to 
represent  many-to-many 
use  a  general 
correspondence. 
the  domain  DNAME  is 
removed  from  the  r e l a t i on  EMP  and  a  new  r e l a t i on 
store  a ll 
ED 
and 
correspondences 
names,  as 
department 
This 
is  due  to  a  strong  constraint  on  a 
inconvenience 
r e l a t i o n al 
data  base  which  requires  that  a ll  data 
is  more 
in  a  domain  must  be  homogeneous. 
as 
natural 
exceptions.  We  use  a  special  symbol,  say 
to 
In  the  above  example, 
represent 
an 
f i e ld  and 
'R&D'>  and  <'SMITH' 
only 
'SALES'>,  are 
created  ED 
r e l a t i o n,  as  shown  in  F i g.  9-  The  domain  DNAME  is 
no  more  homogeneous,  because  the  special  symbol 
' *'  does  not  belong  to  the 
of  department 
can  be  considered  to  carry 
names. 
l i nk  information  to  the  ED  r e l a t i o n. 

is  put  on  the  Mr.  SMITH'S  DNAME 
the 

two  p a i r s,  <'SMITH' 

the  exceptions. 

the  exceptional 

cases 
' * ', 

the  newly 

domain 

symbol 

stored 

t r e at 

This 

' *' 

to 

in 

It 

change  of 

It  is  desirable  to  protect 

the 
struictural 
the  data  base  by  supplying 
the  old  r e l a t i on  EMP(NAME  DNAME  SAL)  as  a  v i r t u al 
r e l a t i o n. 
names,  we  rename  the  base  r e l a t i on  EMP  as, 
CEMP. 

To  avoid  the  c o n f l i ct  of  the  r e l a t i on 
say, 

users 

from 

The 

some 

is 
case, 

fact  that  the  employee  i 's  department 

is 
the  actual 
x  is  expressed  as  EMP.DNAME(i,x),  but 
not  always  in  the  CEMP  r e l a t i o n. 
information 
it 
r e l a t i o n. 
In 
Therefore,  we  require  a  conditional  treatment.  We 
c a ll 
a  conditional  domain. 
defined 
f o l l o w s: 

is 
terms  of  a  conditional  statement  as 

t h is  kind  of  domain  in  the  v i r t u al  r e l a t i o ns 

conditional  domain 

the 

ED 

in 

in 

is 

A 

query 

is  given: 

EMP.NAME(i,?x)  A  EMP.DNAME(i,'SALES'). 

(20) 

This  query  can  be  transformed  to 

the 

by  using 
domain  axiom  (19),  a 
simple  domain  axiom  for  the  simple  domain  NAME  and 
the  tuple 

conditional 

id  axiom. 

to  make 

expression 

Then, 
to  be 

Let  us  denote  the  conditional 
as  B.  The  l i t e r a ls 

in 
in  each  branch  of  B  are 
(21) 
access 
then  grouped  separately  in  order 
outside 
subclauses. 
access 
B  which  are 
subclauses 
they  are  d i s t r i b u t ed  to  every 
branch  of  B  and  put  i n to  the  corresponding  access 
are 
subclauses. 
also  grouped  to  make  the  access 
The 
r e s u lt 
of  applying  these  steps  to  (21)  are  given 
as  follows: 

if  there  are  l i t e r a ls 
in  any 

l i t e r a ls 
subclauses. 

contained 

the  rest 

in  B, 

After 

t h a t, 

(22) 

consists 

of  one  or  more 
Generally,  the  r e s u lt 
subclauses  and  one  or  more  conditional 
access 
conditional 
expressions.  We  regard  t h is  kind  of 
it  a_ 
expression  as  an  access  subclause  and  c a ll 
is 
conditional  access  subclause.  A  program 
constructed 
P* 
introduced  in  section  4.  The  program  t r ee  of  (22) 
i s  shown  in  F i g.  10. 

algorithm 

applying 

t r ee 

the 

by 

Now,  we  w i ll  consider  the  execution  of 

the 
conditional  access 

program 
subclause  C  has  the  following  form: 

Generally, 

t r e e. 

a 

This  axiom  is  called  a  conditional  domain  axiom. 

Now,  we  w i ll  consider  how  to  deal  w i th 

conditional  expression.  Assume  that  the 

the 
following 

where  CI  and  C2  are 

sets  of  access 

subclauses 

F i g.  8.  A  r e o r g a n i z ed  r e l a t i o n al  d a ta 
base 

to  express  an  e x c e p t i o n. 

VANS 

F ig 

10.  The  program  tree  of  (22). 

CEMP(NAME 

DEPT 

SAL) 

ED(NAME 

DNAME) 

SMITH 
BROWN  SALES 

* 

12000 
16000 

SMITH  R&D 
SMITH  SALES 

F i g.  9.  A  more  natural  way  to  express  the 
exception. 

Fig 

♦  A:  CEMP  )  NAME ( ' S M I T H1),  DNAME ( z)  \ 

Natural  Language-3:  Furukawa 

64 

and/or 
equivalent  to  the  following  OR  expression: 

l i t e r a l s.  This  expression  is 

conditional 

Assume  that  the  output  r e l a t i on  A  of  C's  father  A 
variables  which  appear  in  P.  Then, 
contains 
the  conditional 
A  can  be 
defined  by: 

j o in  between  C  and 

a ll 

algebraic 

The 
F i g.  10  is  given  by: 

expression  for  the  program  t r ee  in 

Note  that  the  l i t e r al  P  and  HP  are  passed  to 
the 
father  node  A  and  t n e ir  evaluations  are  delayed 
u n t il  the  node  A  is  evaluated. 

As  a  matter  of  f a c t,  the  l i t e r al  P  (and 

~P) 
can  often  be  evaluated  at  the  evaluation  time  of 
C.  Consider  the  following  query: 

(23) 

not 

tree 

shown 

corresponding  program 

The 
F i g.  11  has 
need 
Furthermore, 
A.  Namely,  the  r e l a t i on  .A  can  be  divided  i n to 
s u b r e l a t i o n s a nd  
a 
s a t i s f i es  P 
if   and  only 
conditional  Join  between  A  and  C  is  expressed  by 

the 
such  a  property.  Tn  t h is  case,  we 
evaluation 
postpone 
P. 
in  conjunction  with 
two 
tuple 
The 

is  evaluated 

it  belongs 

such 

that 

the 

to  

of 

in 

if 

it 

. 

( 

In  t h is  case,  the  l i t e r al  P  works  as  a  conditional 
for  the  node  C  if  A_  consists 
branching  statement 
of  only  one 
t u p l e. 
Therefore  we  express 
the 
conditional  access  l i t e r al  0  by  the  following  COND 
statement: 

We  can  choose 
expression  properly  in  the 
i n v e s t i g a t i ng 
the  conditional  access  l i t e r al  node  and  i ts  sons. 

the  COND 
time  by 
variables  on  the  arcs  between 

the  OB  expression  or 
construction 

the 

to 
normal 

Another  approach  to  deal  w i th  the  conditional 
a 
solve  each 
to 
the  redundancies  caused  by  the  separation. 
conditional 

case  might  be 
d i s j u n c t i ve 
form 
conjunction  separately.  But 
remove 
This  is  the  reason  why  we 
statement 

transform  a 
and 
it 

query 
to 

in  a  u n it 

d i f f i c u lt 

form. 

keep 

the 

to 

is 

6.  The  Implementation  of  DBAP 

l i t e r a ls 

in  a  query, 

v i r t u al 
corresponding 
was 
axioms  through  t h e ir  l o g i c al  expressions. 

and  perform  the 
transformations.  The  axiom  definer 
in  order  to  define  v i r t u al  domain 

implemented 

The  tuple  id  axioms  are 

d i f f e r e nt  way. 
for 
tuple 
redundancies 
procedure  embedded  in  the  DBAP. 

very 
There  are  no  e x p l i c it  functions 
of 
is  done  by  a  search  and  substitution 

id  axioms. 

deletion 

treated 

in  a 

The 

the 

simpler 

form  than  ( l l ); 

for  example, 

The  key  domain  axioms  are  defined 

in  a 

the 

axiom  replaces  the  tuple  id 
causes 

i  by  the  value  x 
This 
the 
and 
This  treatment  of  key 
o r i g i n al 
domain  axioms 
i n t e r a c t i on 
problem 
between  tuple  id  axioms  and  key  domain  axioms,  and 
therefore 

same  e f f e ct  as  applying 

the  e f f i c i e n c y. 

( l l ). 
the 

increase 

solves 

axiom 

key 

7-  Conclusion 

to 

language  QA  system. 

This  research  is  considered 

step 
In  order  to 
toward  a  natural 
access  the  data  base  through  the  user's  i n t e n t i o n, 
the  semantics  or  the  r e al  world  model  of  the  data 
base  must  be  represented  e x p l i c i t ly  and  be  used  to 
remove 
the  gap  between  the  semantic  expression  of 
a  query  and  the  l o g i c al  data  base  s t r u c t u r e. 

be  a 

considered 

On  the  other  hand,  the  v i r t u al  domain  axioms 
can  be 
to  be  a  representation  of  the 
data  base  semantics,  because  the  v i r t u al  r e l a t i o ns 
which  are  defined  by  a  user  can  be  regarded  as  his 
conceptual  model  of  the  r e al  world 

the  e x i s t e n t i al 

l i m i t ed  our 
only  by 

We 
modified 
Universally  q u a n t i f i ed  queries  are  related  to 
d i v i s i on  operation  of 
shown  by  Codd,  E.  F. 
can 
range  s e p a r a b i l i ty  condition 

queries 
q u a n t i f i e r s. 
the 
the  r e l a t i o n al  algebra  as 
It  is  expected  that  we 
the  d i v i s i on  operation  if  we  pose  the 

[2]  on  the  queries. 

deduce 

[ l l ]. 
consideration  on 

[2]. 

Another  d i f f i c u lt  problem  occurs 
v i r t u al 

the 
conjunction  of  base  r e l a t i on 
case, 
v i r t u al 
expressed 
general  algorithm  which  performs  the  breadth 
search  on  an  and-or  graph  w i ll  be  required. 

of 
domains  are  associated  more  than  one 
t h is 
domain  axioms  are 
a 
f i r st 

in  an  and-or  graph. 

Therefore, 

l i t e r a l s. 

whole 

some 

the 

In 

if 

Acknowledgement 

This 

research  was  mainly  done  during  my  stay 
I  would  l i ke  to  thank  Dr.  Bertram  Raphael 
study 
I  would  l i ke  to  especially  thank  Dr.  Daniel 
for 
t h e ir 
concerning 

at  SRI. 
and  other  many  people  who  helped  me 
t h e r e. 
Sagalowicz 
and 
stimulations  and 
the  ideas 

Dr.  Earl  Sacerdoti 
important  suggestions 

in  t h is  paper. 

to 

The  upper 

h a lf  of  the 
F i g.  1  was  implemented  on  an 
QLISP 
is 
prover 
various 
through  section  2 -5  were 
procedural  methods. 

[ 9 ]. 
l i ke  the  resolution 

The  DBAP 

h e u r i s ti 

kinds 

V i r t u al 

domain  axioms 
functions  which  are  invoked 

of 

language 

in 
t o t al  system  shown 
AI 
called 
not  a  formal  theorem 
theorem  prover. 
The 
c  strategies  described 
realized  by 
informal 

are  a c t u a l ly  QLAMBDA 
by 
the  patterns  of 

Natural  Language-3  : 

65 

^urukawa 

References 

Appendix 

Algorithm  P. 

the 

algorithm 

[Construction  of  a  program  t r e e] 
constructs  a  program  t r ee  in 
This 
through 
the  reverse  order  to 
marking  the  nodes  and  arcs  of  the  association 
graph.  We  use  M  and  N  to  denote  nodes  in  the 
association  graph,  and  use  Mt  and  Nt  to 
denote  the  corresponding  nodes 
in  the  program 
tree 
1. 

respectively. 
[Root  construction] 

execution 

Put  a  node  ANS  as  the  root  of 
t r e e. 
the  association  graph  and  put 
it  above 
root  as  a  son  node.  Mark  the  node  N. 

the  program 
Then,  select  an  a r b i t r a ry  node  N  in 
the 

[Tree  construction] 
there  is  an  unmarked  arc  from  the  node  N 
it  and 

If 
(we  denote  t h is  arc  as  A), 
move  to  the  other  node  M  of  arc  A. 

then  mark 

2. 

the  node  M 

is,  marked,  then  put  the 
is 
the  pass  from  the  node  Nt  to  the  node 

Tf 
variables  of  arc  A  on  every  arc  which 
on 
Mt.  Go  to  2. 
Otherwise 
is 
unmarked),  put  the  node  M  as  a  son  of  the 
node  Nt  and  put  the  variables  of  arc  A  on 
the  new 
are.  Mark  the  node  M.  Rename 
the  node  M  as  N.  Go  to  2. 

node  M 

( i . e. 

the 

if 

root 

if  a ll  arcs 

traverse  the  tree 
from  Nt 
u n t il  a  node  of  which 

from  the  node  N 
Otherwose  ( i . e. 
to 
are  marked), 
the 
the 
corresponding  node  on  the  association  graph 
has  an  unmarked  arc 
there 
exists  such  a  node,  name  the  node  as  Nt  and 
the 
corresponding  node  on  the  association 
graph  as  N.  Go  to  2.  Otherwise,  go  to  3. 

found. 

is 

If 

3. 

[Carrying  ?variables  to  the  r o o t] 

For  each  ?variables,  put 
the  pass 
variable  to 

on 
from  the  node  which  contains  the 
the  r o o t. 

it  on  a ll  arcs 

Terminate. 

the 

connects 

root  with  Nt. 
Since 

If  the  node  M  is  marked  in  step  2, 

Remark. 
then 
the  corresponding  tree  node  Mt  must  be  on  the  pass 
is 
which 
easily  proved  as 
is 
constructed  in  pre-order,  a ll  nodes  are  completely 
those  (JV  which  the  corresponding 
expanded  except 
nodes,  in  the  tree  are  on  the  pass.  But 
since  we 
reached 
it  is 
expandable.  Therefore,  the  node  M  is  on  the  pass 
from  Nt  to  the  r o o t. 

the  node  M  v ia  an  unmarked  arc, 

This 
the 

fact 
tree 

f o l l o w s. 

Chang,  C.  L., 
language  for  r e l a t i o n al 
appear 
Recognition, 
Press. 

in  A r t i f i c i al 

"DEDUCE  -  A  deductive  query 
To 
Inteligence  and  Pattern 
(ed.  Chen,  C.  H.),  Academic 

bases," 

data 

Codd,  E.  F.,  "Relational  Completeness  of  Data 
Rase  Sublanguages,"  Courant  Computer  Science 
Symposium  6,  P r e n t i c e - H a l l,  (197?)• 

Green,  C,  "Application  of 
proving 
t  o  pr  o  b1em  solving"  Pr  oc.  1st  1  JCAI, 
pp.219-239, 

theorem 

(1969). 

and  Raphael,  B., 

Green,  C, 
theorem  proving 
answering  systems,"  Proc. 
ACM,  Brandon  Press,  Princeton, 
(1968). 

techniques 

"The 

use  of 

in  question 

23rd  Nat.  Conf. 
New  Jersey, 

Haraldson,  A., 
predicate  calculus  data  base,"  Proc. 
Congress  74,  pp.575-579,  (1974). 

"A  procedure  generator  for  a 
IFTP 

C, 
(using 
for 

"Description  and 

Hewitt, 
analysis 
language 
manipulating  models 
No.  251,  MIT1  Project  MAC,  ( A p r il  197?). 

t h e o r e t i c al 
A 
of  PLANNER: 
theorems 
and 
r o b o t ,"  Al  Memo 

schemata) 
proving 

in  a 

Levien,  R.  E.,  and  Maron,  M.  E.,  "A  Computer 
system 
inference  execution  and  data 
r e t r i e v a l ,"  CACM  Vol.  10,  No.  1 1,  pp.715-721, 
(November,  1967)• 

for 

Raphael,  B.,  The  Thinking  Computer,  W.  H. 
Freeman  and  Company,  San  Fransisco,  (1976)• 

Sacerdoti,  E.  D.  e t.  a l .,  "QLISP  -  A  language 
for  the 
complex 
systems,"  Proc.  AFIPS  1976  NCC,  Vol.  45, 
pp.349-356,  (1976). 

development 

i n t e r a c t i ve 

of 

"implementation  of 

i n t e g r i ty 
Stonebraker,  M., 
constraint 
and  views  by  query  m o d i f i c a t i o n ," 
Proc.  1975  SIGM0D  Workshop  on  Management  of 
Data,  San  Jose,  C a l i f .,  pp.65-78,(May,  1975). 

and 

Smith,  J.M. 
"Data 
abstruetion:  Aggregation  and  g e n e r a l i z a t i o n ," 
To  apear 
in  ACM  Transactions  on  Database 
Systems. 

Smith,  D.  C.  P., 

Sussman,  G.  J.  and  McDermott,  D.  V ., 
PLANNER 
Proc.  FJCC,  p p . I I 7 I - I I 7 9,  (197?). 

"From 
-  A  genetic  approach," 

to  C0NN1VER 

VanderBrug,  G.  and  Minker,  J ., 
"State-Space, 
Problem  Reduction,  and  Theorem  Proving  -  Some 
Relationship," 
2, 
pp.107-115, 

V o l. 
(February  1975). 

CACM 

No. 

18, 

N a t u r al 

L a n g u a ge 

66 

F u r u k a wa 

