Automatic Veriﬁcation of Knowledge and Time with NuSMV

Alessio Lomuscio∗
Dept. of Computing

Charles Pecheur†

Dept. INGI

Imperial College London, UK
A.Lomuscio@imperial.ac.uk

Univ. cath. de Louvain, Belgium
charles.pecheur@uclouvain.be

Franco Raimondi‡

Dept. of Computer Science
Univ. College London, UK

f.raimondi@cs.ucl.ac.uk

Abstract

We show that the problem of model checking multi-
dimensional modal logics can be reduced to the
problem of model checking ARCTL, an extension
of the temporal logic CTL with action labels and
operators to reason about actions.
In particular,
we introduce a methodology for model checking a
temporal-epistemic logic by building upon an ex-
tension of the model checker NuSMV that enables
the veriﬁcation of ARCTL. We brieﬂy present the
implementation and report experimental results for
the veriﬁcation of a typical security protocol in-
volving temporal-epistemic properties: the proto-
col of the dining cryptographers.

1 Introduction
Epistemic logic [Fagin et al., 1995; Meyer and Hoek, 1995]
has traditionally played an important role in Artiﬁcial Intel-
ligence (AI). Not only does epistemic logic provide a formal
basis for reasoning about states of knowledge in automatic
reasoners but it can also be seen as a formal speciﬁcation
language to reason about artiﬁcial agents. Indeed, epistemic
concepts are particularly appropriate in multi-agent systems
(MAS) as knowledge constitutes the basis for rational ac-
tion. In this line of work typically one considers the epis-
temic modal logic S5n combined with a temporal logic for
branching time or linear time interpreted on computationally
grounded semantics [Wooldridge, 2000] such as the one of in-
terpreted systems [Fagin et al., 1995], or a suitable variation
of it [Wooldridge and Lomuscio, 2000].

While much attention in the 80s and 90s focused on prov-
ing meta-logical results (notably completeness and computa-
tional complexity) for various temporal and epistemic combi-
nations [Halpern and Moses, 1992; Meyden, 1994; Meyden
and Wong, 2003], considerable attention has been given in
the past few years to the problem of devising model check-
ing techniques for these formalisms [Hoek and Wooldridge,

∗

The

author

acknowledges

support

from EPSRC grant

GR/S49353.

†

‡

With RIACS at NASA Ames while performing this work.
With MCT at NASA Ames while performing this work. The

2002; Gammie and van der Meyden, 2004; Raimondi and Lo-
muscio, 2005; Penczek and Lomuscio, 2003]. These efforts
are strictly related to the recent shift of attention from theo-
rem proving to model checking as suggested, among others,
in [Halpern and Vardi, 1991].

This article intends to make a contribution in this line by
proposing an efﬁcient model checking technique for verifying
CTLK (an epistemic logic on branching time [Penczek and
Lomuscio, 2003]) based on NuSMV [Cimatti et al., 2002], a
mainstream model checker for temporal logic. Speciﬁcally
the present article makes the following points. First, it is
shown that the model checking of CTLK can be (automat-
ically) rephrased as the one of model checking the action-
based temporal logic ARCTL [Pecheur and Raimondi, 2006].
Second, we present an automatic translator from an SMV-like
language for a semantics of MAS for the extension above.
The main beneﬁts of this proposal against the current state-
of-the-art lies in the efﬁciency of the approach which we try
to demonstrate by discussing experimental results.

2 Preliminaries

We summarise the formalism of interpreted systems in Sec-
tion 2.1, a formalism to reason about time and knowledge in
a system of agents. In Section 2.2 we discuss the problem of
model checking using NuSMV.

Interpreted systems and CTLK

2.1
The formalism of interpreted systems, introduced in [Fagin et
al., 1995], provides a formal framework to reason about time
and knowledge in a system of agents. Let Σ be a set of n
agents: Σ = {1, . . . , n}. A set of local states Li and a set
of actions Acti is associated to each agent i, together with a
protocol Pi : Li → 2Acti assigning a list of enabled actions to
each local state. The local states of an agent change according
: Li × LE × Act → Li,
to a local evolution function ti
where LE is the set of local states of a special agent in Σ
(the environment), and Act = Act1 × . . . × Actn. The set
S = L1 × . . . × Ln is called the set of global states. Given a
set of initial global states I ⊆ S, the set G ⊆ S representing
the set of reachable states is generated by the evolution of
I and in accordance with the protocol and the agents’ local
evolution functions1. Given a set of atomic propositions AP

1The system evolves synchronously, i.e, at each time step all the

author acknowledges support from EPSRC grant CNA/04/04.

agents perform a move.

IJCAI-07

1384

and an interpretation V ⊆ S × AP , an interpreted system is
a tuple

(cid:3)

(cid:2)

IS =

(Li, Acti, Pi, ti)

i∈Σ , I, V

The logic CTLK combines the traditional AI epistemic
logic S5n with the temporal logic CTL. Speciﬁcally, the syn-
tax of CTLK is deﬁned as follows:

ϕ ::= p | ¬ϕ | ϕ ∨ ϕ | EXϕ | EGϕ | E[ϕU ϕ] | Kiϕ (1)

where Kiϕ is read as “agent i knows ϕ” and the CTL opera-
tors have the standard meaning — for example, EGϕ is read
as “there exists a path where ϕ holds forever”. Other derived
operators are deﬁned in a standard way (see e.g. [Clarke et
al., 1999; Fagin et al., 1995]). To evaluate CTLK formulae,
a Kripke model MIS = (W, I, Rt, ∼1, . . . , ∼n, V ) is associ-
ated to a given interpreted system IS, as follows: W is the
set G of reachable states, I ⊆ W is the set of initial states,
the temporal relation Rt ⊆ W × W is obtained using the
protocols Pi and the evolutions functions ti, the epistemic re-
lations ∼i ⊆ W × W , for i ∈ Σ, are deﬁned by checking
the equality of the i-th local component of two global states
(i.e., (l1, . . . , ln) ∼i (l(cid:3)
i), and V is the
evaluation relation appearing in IS2.

) iff li = l(cid:3)

1, . . . , l(cid:3)
n

The formulae deﬁned by (1) are interpreted in MIS in a
standard way: we refer to [Clarke et al., 1999; Fagin et al.,
1995; Penczek and Lomuscio, 2003] for the formal deﬁnition
of M |= ϕ, where |= is the standard satisfaction relation.

2.2 Model checking using NuSMV
Given a Kripke model M and a formula ϕ, model checking is
deﬁned as the problem of establishing whether or not M |=
ϕ. In this approach M represents the system to be checked
and ϕ the speciﬁcation of the system. In the last ﬁfteen years
techniques and tools have been developed to perform the veri-
ﬁcation task in an automatic way, mainly for temporal models
and temporal speciﬁcations. NuSMV [Cimatti et al., 2002] is
a mature model checker for temporal logics and it has been
employed in the veriﬁcation of a number of examples. Other
very successful model checkers exist, notably Spin [Holz-
mann, 1997], Verics [Nabialek et al., 2004], etc.

NuSMV has a dedicated modelling language (the SMV
language), which permits the deﬁnition of the temporal model
in an expressive, compact and modular way. NuSMV avoids
building or exploring the state space corresponding to its
models explicitly; instead, NuSMV applies symbolic tech-
niques based on ordered binary decision diagrams (OBDDs)
or propositional satisﬁability (SAT) solvers to efﬁciently per-
form veriﬁcation over large state spaces.

NuSMV is a command line tool available for most operat-
ing systems, and its source code is available under the terms
of the GNU General Public License (GPL).

3 Model checking MAS: state of the art

Recently, different approaches have been proposed to extend
model checking techniques from temporal logics to richer

2Note that W is, by deﬁnition, the reachable state space, i.e.
it only contains states that are reachable from I through Rt. This
condition is crucial for the proper interpretation of ∼i and Kiϕ.

logics, with the aim of verifying knowledge-based and agent-
based systems. Two main streams can be identiﬁed in the
recent literature:

1. Dedicated tools. Works along this line include
the model checker MCK (Model Checking Knowl-
edge, [Gammie and van der Meyden, 2004]), imple-
menting the veriﬁcation of certain classes of interpreted
systems. Verics [Nabialek et al., 2004] is a model
checker for MAS described using networks of timed au-
tomata. MCMAS [Raimondi and Lomuscio, 2005] is an
OBDD-based model checker for MAS described in in-
terpreted systems.

2. Extensions (and translations) to existing tools. [Hoek
and Wooldridge, 2002] propose the use of local propo-
sitions to reduce the problem of model checking
knowledge and time to the veriﬁcation of a temporal-
[Wooldridge et al., 2002] deﬁne the
only model.
MABLE language, and they show how the veriﬁca-
tion of this language can be reduced to the veriﬁcation
of PROMELA code (the input language of the model
checker SPIN [Holzmann, 1997]). Similarly, [Bordini
et al., 2003] introduce the language AgentSpeak(F), and
they present a translation into PROMELA code.

Experimental results from the papers cited above show
that, on average, purpose-built tools can handle larger exam-
ples, and that trying to use existing tools often requires man-
ual intervention. We show below this is not necessarily the
case. In the remainder of this paper our aim is to introduce
a fully automated methodology that builds upon an existing
tool (NuSMV) and show that it performs comparably or bet-
ter than similar approaches.

4 Model checking CTLK in NuSMV

This section introduces the logic ARCTL (Action-Restricted
CTL) and a proposed extension to NuSMV thereby enabling
the veriﬁcation of ARCTL operators. In Section 4.2 we show
how the problem of model checking for CTLK can be re-
duced to the problem of model checking for ARCTL, thereby
permitting the veriﬁcation of CTLK by using NuSMV. In ad-
dition, in Section 4.3 we present an SMV-like language for
interpreted systems and its translation into SMV code.

4.1 The logic ARCTL
The logic ARCTL [Pecheur and Raimondi, 2006] extends
the logic CTL by allowing quantiﬁcation over action labelled
paths. More in detail, given a set of atomic propositions AP
and a set of atomic actions AA, the syntax of ARCTL is de-
ﬁned as:

ϕ ::= p | ¬ϕ | ϕ ∨ ϕ | EαXϕ | AαXϕ |

Eα[ϕU ϕ] | Aα[ϕU ϕ]

(2)

α ::= b | ¬α | α ∨ α

(3)
where ϕ and α are state and action formulae and p ∈ AP, b ∈
AA are atomic propositions over states and actions, respec-
tively. Similarly to CTL, other temporal operators can be de-
rived in a standard way.

IJCAI-07

1385

A model for ARCTL is a tuple of the form M =
(S, S0, A, T, VP , VA), where S is a set of states, S0 ⊆ S is a
set of initial states, A is a set of actions, T ⊆ S × A × S
is a transition relation (notice the dependence on actions),
VP : S → 2AP is an interpretation for atomic propositions,
and VA : A → 2AA is an interpretation for atomic actions.
Given a model M = (S, S0, T, VP , VA), the α-restriction of
M , denoted by Mα, is a model Mα = (S, S0, Tα, VP , VA),
where Tα is a transition relation such that (s, a, s(cid:3)) ∈ Tα iff
(s, a, s(cid:3)) ∈ T and a |= α (where |= is the natural extension
of VA to propositional formulae α). We refer to [Pecheur and
Raimondi, 2006] for further details.

For model checking purposes, we have extended NuSMV
to support the veriﬁcation of ARCTL formulae. We used
NuSMV existing “input” variables to model ARCTL actions.
In particular, we have modiﬁed the syntax of the formulae
accepted by NuSMV as follows:

ctlexpr

::= . . .

(existing CTL forms)

EAX(simpleexpr)ctlexpr
EAG(simpleexpr)ctlexpr

EA(simpleexpr)[ctlexpr U ctlexpr]

where simpleexpr is a conditional expression, further re-
stricted to contain only input variables.
For example,
EA(a)[p U q] is the concrete syntax for Ea[pU q]. Ad-
ditionally, we have implemented extensions to the NuSMV
code base to enable the veriﬁcation of these operators (the
details of these modiﬁcations are beyond the scope of this
paper, we refer to [Pecheur and Raimondi, 2006] for further
details).

4.2 Reducing CTLK to ARCTL

Agentmodel(xtd.NuSMV)

CTLKspecs

M4translator

NuSMVmodel
ARCTLspecs

NuSMV

(w/ARCTLsupport)

TRUE

FALSE
counterex.

Figure 1: Veriﬁcation work ﬂow for interpreted systems

The translation of a temporal-epistemic formula into an

ARCTL formula is inductively deﬁned as follows:

• F (p) = p, if p is a propositional formula.
• F (EXϕ) = ERunXϕ; F (E[ϕU ψ]) = ERun[ϕU ψ];

F (EGϕ) = ERunGϕ; F (Kiϕ) = AAgti Xϕ.

In other words we use the labels Run (Agti, respectively)
to denote a temporal relation (the epistemic relation for
agent i, respectively). This translation allows us to model
check CTLK formulas by model checking their translations
in ARCTL. Clearly a similar approach can be used for more
complex modal logics.

The translation from an interpreted system IS to the
ARCTL model F (MIS) is performed automatically by a
translator we have implemented (see next section).

The problem of model checking CTLK (see Section 2.1)
can be reduced to the problem of model checking ARCTL.
Speciﬁcally, given a CTLK model MK and a CTLK for-
mula ϕK , we can deﬁne an ARCTL model M = F (MK)
and an ARCTL formula F (ϕK) such that MK |= ϕK
iff F (MK)
Let Σ = {1, . . . , n} be a
set of agents, and let MK = (W, I, Rt, {∼i}i∈Σ, V ) be
a model associated to some interpreted system IS =
(cid:2)
(Li, Acti, Pi, ti)
The model F (MK) is an
ARCTL model M = (S, S0, A, T, VP , VA) such that

|= F (ϕK).

i∈Σ , I, V

(cid:3)
.

• S = W and S0 = I;
• the set AA = {Run, Agt1, . . . , Agtn} contains a
proposition Run to label temporal transitions (deﬁned
by Rt) and n propositions Agti (one for each agent) to
label epistemic equivalence steps (deﬁned by ∼i), and
the action set A is 2AA;

• the transition relation T combines the temporal transi-
tion Rt and the epistemic relations {∼i}i∈Σ in the fol-
lowing way: for states s, s(cid:3) ∈ W , (i) (s, {Run}, s(cid:3)) ∈ T
iff sRts(cid:3); (ii) (s, {Agti}, s(cid:3)) ∈ T iff s ∼i s(cid:3); (iii)
(s, {a1, . . . , ak}, s(cid:3)) ∈ T iff (s, {ai}, s(cid:3)) for all 1 ≤ i ≤
k. 3

In

its

local

state,

a

this

language,

4.3 An SMV-like language for interpreted systems
We have designed extensions of the SMV language for the de-
scription of interpreted systems and CTLK formulae. These
extensions can be translated to into a standard SMV model
and ARCTL formulae. Concretely, the extensions are deﬁned
as a library of M4 macros4. The work ﬂow needed to per-
form veriﬁcation of an interpreted system is summarised in
Figure 1. Notice that the only manual intervention is the pro-
vision of the input ﬁle describing the problem to be veriﬁed.
asso-
SMV variables <v1>,..,<vn>
ciated with
declaration
that
deﬁne
AGENT(<name>,<v1>,..,<vn>).
The actions of
each agent are represented as input variables (IVAR). The
protocol of each agent is described as a relation between
its local state and action variables (within an SMV TRANS
statement).
The transition function is encoded using a
new TTRANS statement, and initial conditions using a new
TINIT statement. Figure 2 shows the structure of a typical
deﬁnition of a class of agents as an SMV module (note that
“--” starts comments in SMV, see [Cimatti et al., 2002] for
details).

agent <name> is

through

the

an

3Case (iii) is necessary for interpreting distributed knowledge

4M4 [Kernighan and Ritchie, 1977] is a general-purpose macro

operators, but this discussion is beyond the scope of this paper.

processor available on most UNIX platforms.

IJCAI-07

1386

MODULE anAgent(args,ENV) -- an agent module
-- the local state
-- declare the local state
-- actions of the agent
-- initial conditions

VAR local : {...};
AGENT(me,local)
IVAR action : {...};
TINIT( ... );
TRANS( action =

case ... )

-- the agent’s protocol

TTRANS( NEXT(local) =

case ... )

-- the agent’s evolution function

MODULE main
VAR_ENV
VAR alice : anAgent(args1,ENV) ;
: anAgent(args2,ENV) ;

bob

-- main module
-- declare ENV variables

-- an agent
-- another agent

Figure 2: Example of agent deﬁnition in extended SMV

Internally,

the translation generates additional Boolean
variables IVARS corresponding to the Run and Agti propo-
sitions of the ARCTL model (e.g. RUN, bob.me and
alice.me in the model of Fig. 2), and TTRANS statements
expand to standard TRANS statements conditioned on RUN.

Note that the state space of the NuSMV model is not a pri-
ori restricted to the (temporally) reachable states; this has to
be imposed by the translation scheme. A state is reachable
iff it can be reached from the initial states through a series of
temporal steps (or, equivalently, iff there exists a reverse path
from that state back to the initial set). Assuming we have ac-
cess to reverse temporal transitions through some action con-
dition Back in our ARCTL model, and a state condition Init
for initial states, the set of the (temporally) reachable states is
captured by the following ARCTL formula:
Reachable ≡ EBackF Init

Since this is a temporal formula, it has to be folded into
NuSMV properties; it cannot be used in the NuSMV model
itself. For example, the CTLK formula Kiϕ expands to the
ARCTL formula AAgti X(Reachable → ϕ).

Our library implements this scheme.

In particular, the
TTRANS construct implements an encoding scheme allowing
temporal transitions to be traversed both forwards and back-
wards. On the speciﬁcation side, new operators TAX, TAG,
etc. provide the equivalent of SMV’s built-in AX, AG, etc., re-
stricted to temporal transitions, and a new operator KK imple-
ments Kiϕ. For instance, the CTLK formula AG(Ka(p ∨ q))
expressing that agent a always knows either p or q, is written
as TAG(KK(a,p|q)).

5 Example application
In this section we model the protocol of the dining cryp-
tographers using the formalism presented in Section 2.1, in
order to enable its veriﬁcation using the methodology pre-
sented in Section 4.2. The protocol was introduced by Chaum
in [Chaum, 1988], and was modelled using agents by various
authors [van der Meyden and Su, 2004; Raimondi and Lo-
muscio, 2005; Kacprzak et al., 2006]. The aim of this proto-
col is to allow the anonymous broadcasting of messages, and
it is usually introduced using the following scenario (wording
from [Chaum, 1988]):

“Three cryptographers are sitting down to dinner at their
favorite three-star restaurant. Their waiter informs them that
arrangements have been made with the maitre d’hotel for the

bill to be paid anonymously. One of the cryptographers might
be paying for dinner, or it might have been NSA (U.S. Na-
tional Security Agency). The three cryptographers respect
each other’s right to make an anonymous payment, but they
wonder if NSA is paying. They resolve their uncertainty fairly
by carrying out the following protocol:

Each cryptographer ﬂips an unbiased coin behind his
menu, between him and the cryptographer on his right, so
that only the two of them can see the outcome. Each cryptog-
rapher then states aloud whether the two coins he can see–the
one he ﬂipped and the one his left-hand neighbour ﬂipped–fell
on the same side or on different sides. If one of the cryptogra-
phers is the payer, he states the opposite of what he sees. An
odd number of differences uttered at the table indicates that a
cryptographer is paying; an even number indicates that NSA
is paying (assuming that dinner was paid for only once). Yet
if a cryptographer is paying, neither of the other two learns
anything from the utterances about which cryptographer it
is”

This protocol can be extended to any number n of cryptog-
raphers greater than three. We encode the scenario by using
an interpreted system by introducing n agents C1, . . . , Cn,
and one agent E to represent the environment (which selects
the payer and the result of coin tosses at the beginning of each
run, non-deterministically) [Raimondi and Lomuscio, 2005].
The local state of cryptographer Ci is modelled using
three variables equali, paidi, eveni, representing respec-
tively whether the coins that Ci can see are equal or different,
whether Ci is the payer, and whether the number of different
utterances reported is even.5 The list of actions for each cryp-
tographer includes the actions do nothing, say equal,
and say different, performed in compliance with the
description provided above. In the initial state the variables
for each cryptographer are initialised to a null value, and
they are updated in the ﬁrst time step, to reﬂect the environ-
ment’s conﬁguration. At this point, each cryptographer utters
the appropriate phrase (represented by say equal or say
different) and the variable storing the value of “differ-
ent” utterances (either even or odd) is appropriately updated.
The key properties of this scenario [van der Meyden and

Su, 2004] are easy to express using CTLK. For instance:

(odd ∧ ¬paid1) → AX(KC 1(paid2 ∨ paid3)

∧¬KC 1(paid2) ∧ ¬KC 1(paid3))

even → AX(KC 1(¬paid2 ∧ ¬paid3))

(4)

(5)

Formula (4) expresses the property that, if the ﬁrst cryptog-
rapher did not pay for the dinner and there is an odd number
of utterances, then, upon update of his local state, the ﬁrst
cryptographer knows that someone of the remaining cryptog-
raphers paid for the dinner, but the ﬁrst cryptographer does
not know who the payer is. Formula (5) expresses the prop-
erty that if the number of utterances is even, the ﬁrst cryptog-
raphers knows that nobody paid for the dinner.

5We refer to [Kacprzak et al., 2006] for other possible encodings
of the same protocol. Our choice here is motivated by the need of
comparing our experimental results with the ones in [Raimondi and
Lomuscio, 2005; Kacprzak et al., 2006].

IJCAI-07

1387

N. crypt

Bool vars NUSMV MCMAS VERICS

3
4
5
6
7
8
9

61
78
99
116
137
156
175

0.34s
0.46s
0.86s
2.95s
1m15s
6m34s
49m5s

0.67s
2.09s
8.91s
19.5s
2m29s
2h59m

N/A

84s
730s
1h5m
8h32m

N/A
N/A
N/A

Table 1: Average experimental results.

performance is due to the optimisation techniques imple-
mented in NuSMV (such as on-the-ﬂy model checking and
caching). Obviously, experimental results depend on the ex-
amples tested and it is not appropriate to draw ﬁnal conclu-
sions on one example only. Additionally, we would expect
VERICS to outperform the approach presented here when try-
ing to falsify formulas on very large state spaces. Neverthe-
less, we think the discussion above shows that the technique
presented here can signiﬁcantly complement the other model
checkers in many instances.

We have encoded this scenario using the language pre-
sented in Section 4.3 and we have been able to verify the
example for up to nine cryptographers6. Experimental results
are reported in the next section.

6 Experimental results

Table 1 reports the time results obtained in the veriﬁcation of
the example presented in the previous section, as a function
of the number of cryptographers (ﬁrst column). The third
column reports the time required for the veriﬁcation of the
formulae 4 and 5 (appropriately translated into ARCTL for-
mulae). The second column reports the number of Boolean
variables required to encode the example (see [Clarke et al.,
1999] for more details on this technique), and provides an es-
timate for the size of the model; for instance, 137 Boolean
variables are required to encode an example with 7 cryp-
tographers, corresponding to a maximal state space of size
2137 ≈ 1041.

The fourth and ﬁfth columns report the time results ob-
tained in the veriﬁcation of the protocol of the dining cryp-
tographers using the model checkers MCMAS and Verics, as
reported in [Raimondi and Lomuscio, 2005; Kacprzak et al.,
2006], for the veriﬁcation of the same formulae mentioned
above, as a function of the number of cryptographers. No-
tice that, in the case of MCMAS, the veriﬁcation time does
not depend on the formula being veriﬁed and it is usually a
fraction of the time spent in reading and parsing the model
(the opposite is true for NuSMV, because of different imple-
mentation choices). The last column reports the time results
for Verics. Differently from the previous two cases, Verics’s
results are based on an implementation of Bounded Model
Checking for CTLK. [Penczek and Lomuscio, 2003]. Due to
this, Verics’s performance for this two formulae is worse than
the other two model checkers, but Verics is normally capa-
ble of ﬁnding counterexamples for false formulae effectively:
in [Kacprzak et al., 2006] it is shown that certain false formu-
lae can be veriﬁed in scenarios with up to 100 cryptographers.
Neither MCMAS nor the technique of this article can handle
this magnitude of state spaces.

6.1 Discussion
A comparison of the results obtained with the three model
checkers is reported in Figure 3. Clearly for the formu-
lae considered here the approach presented here performs
moderately better than MCMAS and VERICS. The better

6The source code for

these examples is available from
http://www.cs.ucl.ac.uk/staff/f.raimondi/dincrypt-code.zip.

)
s
(
 
e
m
i
T

100000

10000

1000

100

10

1

0.1

NuSMV

mcmas

Verics

0

1

2

3

4

5

6

7

8

9

10

N. Crypt

Figure 3: Comparison of the experimental results.

We could not compare our methodology to other existing
approaches based on existing model checkers (see Section 3).
Indeed, such approaches often require a manual intervention
in the translation from their speciﬁc programming language
into the programming language of the temporal model check-
ers, and this is not feasible for large examples such as the one
considered here.

7 Conclusion

In this paper we have presented a novel technique for model
checking CTLK that relies on the translation of this logic into
action-based temporal logic and model checking of this logic
with NuSMV. The approach is sound and complete and our
implementation shows experimental results that are in line
with or better than existing specialised tools.

The use of macros for extending the NuSMV language has
allowed for easy prototyping but limits the syntactic ﬂexibil-
ity. A more natural syntax could be supported with more in-
volved translation facilities. Further planned work includes
investigating optimisation of the veriﬁcation scheme, both
at the level of the translation from CTLK to ARCTL and
through additional extensions or optimizations of NuSMV it-
self. Moreover, we limited our analysis to dining cryptogra-
phers because this is the only scenario for which experimental
results are available in the literature. In future work we cer-
tainly plan to use the technique and tool presented here to
investigate more realistic scenarios.

Another important issue to be addressed is the handling of
witness traces generated by NuSMV, which need to be formu-
lated back in terms of the original CTLK model. We would
also like to investigate using NuSMV’s SAT-based bounded
model checking capabilities rather than the current OBDD-
based approach. Given the limitation of NuSMV, this requires

IJCAI-07

1388

shifting from branching to linear temporal logic, requiring a
new and more restrictive encoding scheme for CTLK prop-
erties. The feasibility and applicability of such a scheme re-
mains to be explored.

References
[Bordini et al., 2003] R. H. Bordini, M. Fisher, C. Pardavila,
and M. Wooldridge. Model checking AgentSpeak. In J. S.
Rosenschein, T. Sandholm, W. Michael, and M. Yokoo,
editors, Proceedings of AAMAS-03, pages 409–416. ACM
Press, 2003.

[Chaum, 1988] D. Chaum. The dining cryptographers prob-
lem: Unconditional sender and recipient untraceability.
Journal of Cryptology, 1(1):65–75, 1988.

[Cimatti et al., 2002] A.

Cimatti,

E. M.

Clarke,
E. Giunchiglia, F. Giunchiglia, M. Pistore, M. Roveri,
R. Sebastiani, and A. Tacchella. NUSMV2: An open-
source tool for symbolic model checking. In Proceedings
of CAV’02, volume 2404 of LNCS, pages 359–364.
Springer-Verlag, 2002.

[Clarke et al., 1999] E. M. Clarke, O. Grumberg, and D. A.
Peled. Model Checking. The MIT Press, Cambridge, Mas-
sachusetts, 1999.

[Fagin et al., 1995] R. Fagin, J. Y. Halpern, Y. Moses, and
M. Y. Vardi. Reasoning about Knowledge. MIT Press,
Cambridge, 1995.

[Gammie and van der Meyden, 2004] P.

and
R. van der Meyden. MCK: Model checking the logic of
knowledge. In Proceedings of CAV’04, volume 3114 of
LNCS, pages 479–483. Springer-Verlag, 2004.

Gammie

[Halpern and Moses, 1992] J. Halpern and Y. Moses. A
guide to completeness and complexity for modal logics of
knowledge and belief. Artiﬁcial Intelligence, 54:319–379,
1992.

[Halpern and Vardi, 1991] J. Halpern and M. Vardi. Model
checking vs. theorem proving: A manifesto. In Proceed-
ings of the 2nd International Conference on Principles of
Knowledge Representation and Reasoning (KR’91), pages
325–334. Morgan Kaufmann, April 1991.

[Hoek and Wooldridge, 2002] W.

and
M. Wooldridge. Model checking knowledge and time. In
SPIN 2002 – Proceedings of the Ninth International SPIN
Workshop on Model Checking of Software, Grenoble,
France, April 2002.

der Hoek

van

[Holzmann, 1997] G. J. Holzmann.

The model checker
IEEE transaction on software engineering,

SPIN.
23(5):279–295, 1997.

[Kacprzak et al., 2006] M. Kacprzak,

Lomuscio,
and
A. Niewiadomski, W. Penczek, F. Raimondi,
M. Szreter. Comparing BDD and SAT based techniques
for model checking Chaum’s dining cryptographers
protocol. Fundamenta Informaticae, 2006. to appear.

A.

[Meyden and Wong, 2003] R. van der Meyden and K. Wong.
Complete axiomatizations for reasoning about knowledge
and branching time. Studia Logica, 75(1):93–123, 2003.

[Meyden, 1994] R. van der Meyden. Axioms for knowledge
and time in distributed systems with perfect recall.
In
Proceedings, Ninth Annual IEEE Symposium on Logic in
Computer Science, pages 448–457, Paris, France, 1994.
IEEE Computer Society Press.

[Meyer and Hoek, 1995] J.-J. Ch. Meyer and W. van der
Hoek. Epistemic Logic for AI and Computer Science, vol-
ume 41 of Cambridge Tracts in Theoretical Computer Sci-
ence. Cambridge University Press, 1995.

[Nabialek et al., 2004] W. Nabialek, A. Niewiadomski,
W. Penczek, A. P´olrola, and M. Szreter. VerICS 2004:
A model checker for real
time and multi-agent sys-
tems.
In Proceedings of CS&P’04, volume 170 of
Informatik-Berichte, pages 88–99. Humboldt University,
2004.

[Pecheur and Raimondi, 2006] C. Pecheur and F. Raimondi.
Symbolic model checking of logics with actions. In Pro-
ceedings of MoChArt 2006, Lecture Notes in Artiﬁcial In-
telligence. Springer Verlag, August 2006. to appear.

[Penczek and Lomuscio, 2003] W. Penczek and A. Lomus-
cio. Verifying epistemic properties of multi-agent systems
via bounded model checking. Fundamenta Informaticae,
55(2):167–185, 2003.

[Raimondi and Lomuscio, 2005] F. Raimondi and A. Lo-
muscio. Automatic veriﬁcation of multi-agent systems by
model checking via OBDDs. Journal of Applied Logic,
2005. To appear in Special issue on Logic-based agent
veriﬁcation.

[van der Meyden and Su, 2004] R. van der Meyden and
Kaile Su. Symbolic model checking the knowledge of the
dining cryptographers. In Proceedings of the 17th IEEE
Computer Security Foundations Workshop (CSFW’04),
pages 280–291, Washington, DC, USA, 2004. IEEE Com-
puter Society.

[Wooldridge and Lomuscio, 2000] M. Wooldridge

and
A. Lomuscio. Multi-agent VSK logic.
In M. Ojeda-
Aciego, I. P. de Guzm´an, G. Brewka, and L. Moniz
Pereira, editors, Proceedings of JELIA 2000 (LNAI
Volume 1919), pages 300–312. Springer-Verlag, 2000.

[Wooldridge et al., 2002] M. Wooldridge, M.

Fisher,
M. Huget, and S. Parsons. Model checking multia-
gent systems with MABLE.
the
First International Conference on Autonomous Agents
and Multiagent Systems (AAMAS-02), pages 952–959,
Bologna, Italy, July 2002.

In Proceedings of

[Wooldridge, 2000] M. Wooldridge.

Computationally
grounded theories of agency.
In E. Durfee, editor, Pro-
ceedings of ICMAS, International Conference of Multi-
Agent Systems, pages 13–22. IEEE Press, 2000.

[Kernighan and Ritchie, 1977] B.W. Kernighan and D.M.
Ritchie. The M4 Macro Processor. Bell Laboratories,
1977.

IJCAI-07

1389

