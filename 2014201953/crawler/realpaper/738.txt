A Constraint Language for Specifying Combinatorial Problems

The Design of ESSENCE:

Alan M. Frisch1 Matthew Grum1
Bernadette Mart´ınez Hern´andez1

Chris Jefferson2
Ian Miguel3

1Artiﬁcial Intelligence Group, Dept. of Computer Science, Univ. of York, UK. {frisch, grum, berna}@cs.york.ac.uk

2Oxford University Computing Laboratory, Univ. of Oxford, UK. chrisj@comlab.ox.ac.uk

3School of Computer Science, Univ. of St. Andrews, UK. ianm@dcs.st-and.ac.uk

Abstract

ESSENCE is a new formal language for specify-
ing combinatorial problems in a manner similar
to natural rigorous speciﬁcations that use a mix-
ture of natural language and discrete mathematics.
ESSENCE provides a high level of abstraction, much
of which is the consequence of the provision of
decision variables whose values can be combina-
torial objects, such as tuples, sets, multisets, rela-
tions, partitions and functions. ESSENCE also al-
lows these combinatorial objects to be nested to ar-
bitrary depth, thus providing, for example, sets of
partitions, sets of sets of partitions, and so forth.
Therefore, a problem that requires ﬁnding a com-
plex combinatorial object can be directly speciﬁed
by using a decision variable whose type is precisely
that combinatorial object.

Introduction

1
This paper describes ESSENCE,1 a new language for speci-
fying combinatorial (decision or optimisation) problems at a
high level of abstraction. ESSENCE is the result of our attempt
to design a formal language that enables abstract problem
speciﬁcations that are similar to rigorous speciﬁcations that
use a mixture of natural language and discrete mathematics,
such as those catalogued by Garey and Johnson [1979].

ESSENCE is intended to be accessible to anyone with a
background in discrete mathematics; no expertise in con-
straint programming should be needed. Our working hypoth-
esis has been that this could be achieved by modelling the
language after the rigorous speciﬁcations that are naturally
used to describe combinatorial problems rather than develop-
ing some form of logical language, such as Z [Spivey, 1989]
or NP-SPEC [Cadoli et al., 2000]. This has resulted in a
language that, to a ﬁrst approximation, is a constraint lan-
guage, such as OPL [Van Hentenryck, 1999], F [Hnich, 2003]
or ESRA [Flener et al., 2004], enhanced with features that
greatly increase its level of abstraction. Most importantly, as a
combinatorial problem requires ﬁnding a certain type of com-
binatorial object, ESSENCE provides decision variables whose

1ESSENCE version 1.1.0 is used within this paper. A full speciﬁ-

cation of the language can be found at [York Web, 2006].

domain elements are combinatorial objects of that type and
constraints that operate on that type. This enables problems
to be stated directly and naturally; without the decision vari-
ables of the appropriate type the problem would have to be
“modelled” by encoding the desired combinatorial object as
a collection of constrained decision variables of some other
type, such as integers.

As our motivations — and hence our methodology and re-
sults — for developing ESSENCE differ greatly from those that
have lead to the development of other constraint languages it
is important to consider these carefully at the outset.

Our primary motivation comes from our ongoing study
of the automation of constraint modelling. Constraint mod-
elling is the process of reducing a given problem to the ﬁnite-
domain constraint satisfaction or optimisation problem (CSP)
in which all the domains and constraints are supported by the
intended solver technology. In current practice, this process is
conducted manually and unsystematically — that is, it is still
an art. As current solvers provide decision variables whose
domains contain atomic values or, sometimes, ﬁnite sets of
atomic values, models must always be in terms of these. We
call such variables atomic and atomic set variables, respec-
tively. As an example, consider the Social Golfers Problem
(SGP), which requires partitioning a set of golfers into equal-
sized groups in each week of a tournament subject to a certain
constraint. Thus, the goal is to ﬁnd a multiset of regular parti-
tions2 that satisﬁes the constraint. A model for the SGP must
therefore represent this multiset of regular partitions by a col-
lection of constrained atomic or atomic set variables. There
are at least 72 ways that this can be done [Frisch et al., 2005c].
To automatically generate models for a problem, one must
start with a formal speciﬁcation of the problem and this spec-
iﬁcation must be sufﬁciently abstract that no modelling de-
cisions have been made in constructing it. Thus, the formal
language for writing speciﬁcations must provide a level of ab-
straction above that at which modelling decisions are made.
We refer to such a language as a problem speciﬁcation lan-
guage and distinguish it from modelling languages, whose
purpose is to enable the speciﬁcation of models. Thus, de-
signing a problem speciﬁcation language is a prerequisite to
studying automated modelling and the goal of this paper is to
put forward a language that makes a large step towards satis-

2A partition is regular if all its subsets have the same cardinality.

IJCAI-07

80

fying this challenging prerequisite.

Another motivation for designing ESSENCE is that formal
problem speciﬁcations could facilitate communication be-
tween humans better than the informal speciﬁcations that are
currently used and further beneﬁts could accrue from stan-
dardising a problem speciﬁcation language. For example, the
informal problem descriptions in the CSPLib problem library
(http://csplib.org) could be replaced or supplemented by for-
mal ones, but doing so requires the availability of a problem
speciﬁcation language as the founders of CSPLib insisted on
describing problems rather than models. Using formal speci-
ﬁcations for human communication imposes the requirement
that the language is natural — that is, it is similar to the
manner in which people think of problems and the style in
which they specify them informally. Naturalness is also an
important property for the input language of an an automated
modelling system; one cannot claim to have an automated
modelling system if using it requires a major translation of
the problem into the system’s input language. Finally, exper-
tise in constraint modelling or constraint solving should not
be needed for writing a formal problem speciﬁcation, be it
for human communication or for input to an automated mod-
elling system.

Three primary objectives have driven the design of
ESSENCE. This section has discussed two: The language
should be natural enough to be understood by someone with
a background in discrete mathematics and it should provide
a high level of abstraction. These two objectives are related;
providing an appropriate level of abstraction is necessary to
achieve naturalness. The third design objective is that prob-
lems speciﬁed in the language can be effectively mapped to
CSPs. As an illustration, one consequence of this objective is
that every decision variable in ESSENCE is associated with a
ﬁnite domain.

The remainder of this paper introduces ESSENCE and argues
that it largely meets its design objectives. This paper does
not present a formal syntax (this can be found at [York Web,
2006]) or a formal semantics (this can be found in [Frisch et
al., 2005a]).

2 An Introduction to ESSENCE by Example
Through the presentation of examples, this section both intro-
duces ESSENCE and demonstrates its naturalness.

We begin by asking the reader to examine the ﬁrst ESSENCE
speciﬁcation given in Fig. 1. This is a speciﬁcation of a well-
known problem. Can you identify it?

You should have been able to identify this as the Knap-
sack decision problem because the ESSENCE speciﬁcation is
nearly identical to the speciﬁcation given by Garey and John-
son [1979, problem MP9, page 247]:

INSTANCE: Finite set U, for each u ∈ U: a size s(u) ∈ Z
value v(u)∈ Z
+ and positive integers B and K.
QUESTION: Is there a subset U(cid:2) ⊆ U such that
B and
The similarity of

this ESSENCE speciﬁcation to the
naturally-arising problem speciﬁcation illustrates our main
point: Problems are often speciﬁed rigorously via discrete
mathematics. ESSENCE is based on the notation and concepts

+, a
u∈U(cid:2) s(u) ≤

u∈U(cid:2) v(u) ≥ K?

P

P

Mystery Problem:

given

find
such that

U enum(...), s : U → int (1...),
v : U → int (1...), B, K: int
(cid:2)
: set of U
U
P
u∈U(cid:2) .s(u) ≤ B,

P

u∈U(cid:2) .v(u) ≥ K

Golomb Ruler Problem (GRP): Given n, put n integer ticks on a ruler of size m
such that all inter-tick distances are unique. Minimise m.

given
where
letting
find
minimising
such that

n : int
n ≥ 0
bound be 2n
T icks : set (size n) of int (0..bound)
max(T icks)
∀pair1,pair2:set (size 2) of int⊆Ticks.pair1 (cid:6)= pair2 =⇒
max(pair1) − min(pair1) (cid:6)= max(pair2) − min(pair2)

SONET Problem: A SONET communication network comprises a number of
rings, each joining a number of nodes. A node is installed on a ring using an ADM
and there is a capacity bound on the number of ADMs that can be installed on a
ring. Each node can be installed on more than one ring. Communication can be
routed between a pair of nodes only if both are installed on a common ring. Given
the capacity bound and a speciﬁcation of which pairs of nodes must communicate,
allocate a set of nodes to each ring so that the given communication demands are
met. The objective is to minimise the number of ADMs used. (This is a common
simpliﬁcation of the full SONET problem, as described by Frisch et.al. [2005b])

given
letting
given
find

nrings, nnodes, capacity : int (1...)
Nodes be int(1..nnodes)
demand : set of set (size 2) of Nodes
network : mset (size nrings) of
P

set (maxsize capacity) of Nodes

|ring|

minimising
such that ∀pair∈demand. ∃ring∈network. pair ⊆ ring

ring∈network

Social Golfers Problem (SGP): In a golf club there are a number of golfers who
wish to play together in g groups of size s. Find a schedule of play for w weeks
such that no pair of golfers play together more than once. (This transforms into a
decision problem and parameterises problem number 10 in CSPLib.)

w, g, s : int (1...)
golfers be new type of size g ∗ s
sched : mset (size w) of rpartition (size s) of golfers

given
letting
find
such that ∀week1,week2∈sched.week1 (cid:6)= week2 =⇒
Alternative constraint:
such that ∀golfer1,golfer2:golfers.golfer1 (cid:6)= golfer2 =⇒

∀group1∈week1,group2∈week2.|group1 ∩ group2| < 2

week∈sched .together(golfer1, golfer2, week)) < 2

P

(

Figure 1: ESSENCE speciﬁcations of four problems.

of discrete mathematics. Hence, someone able to understand
rigorous problem speciﬁcations that employ discrete math-
ematics can, with little training, also understand ESSENCE
speciﬁcations. This is a signiﬁcant advantage as far more
people are familiar with discrete mathematics than constraint
programming.

Natural problem speciﬁcations, such as the one above,
identify what is given (the parameters to the problem), what
combinatorial objects must be found (the decision vari-
ables) and what constraints the objects must be satisfy to
be a solution. The speciﬁcation might also introduce some
terminology, give an objective function if the problem is
an optimisation problem, and identify conditions that must
be met by the parameter values. ESSENCE supports these
components of a problem speciﬁcation with seven kinds
of statements, signalled by the by the keywords given,
where, letting, find, maximising, minimising and
such that. letting statements declare constant identi-
ﬁers and user-deﬁned types. given statements declare pa-

IJCAI-07

81

rameters, whose values are input to specify the instance of
the problem class. Parameter values are not part of the
problem speciﬁcation. where statements dictate allowed pa-
rameter values; only allowed values designate valid prob-
lem instances. find statements declare decision variables.
A minimising or maximising statement gives the objec-
tive function, if any. Finally, such that statements give the
problem constraints.

An ESSENCE speciﬁcation is a list of statements composed

according to the regular expression:

∗

∗
[minimising | maximising] (such that)

(given | letting | where | find)
Now consider the speciﬁcation of the Golomb Ruler Prob-
lem (GRP, problem 6 in CSPLib) in Fig. 1, and the instance
obtained by letting n be 4. The domain of the decision vari-
able T icks contains all sets of four elements drawn from
{0, .., 16}. Consider an assignment of T icks to {0, 1, 3, 7}.
Is this a solution to this instance? If we have succeeded in
our goal of making ESSENCE speciﬁcations natural to those
with a discrete mathematics background, then it should be
clear that it is: given any two distinct pairs from {0, 1, 3, 7},
the distance between one pair, max(pair1) − min(pair1) is
different from the distance between the other max(pair2) −
min(pair2). We believe that the reader will concur that the
ESSENCE speciﬁcation closely matches the given English de-
scription, and is substantially closer than a standard CSP
model of the problem.

The GRP speciﬁcation ﬁrst declares parameter n (valid
when positive) and identiﬁer bound. The declaration of
bound uses n, so n must be declared ﬁrst. Identiﬁers must be
declared before use, preventing cyclical deﬁnitions and deci-
sion variables from being used to deﬁne constants or param-
eters.

Constraints are built from parameters, constants, quanti-
ﬁed variables and decision variables using operators com-
monly found in mathematics. ESSENCE also includes variable
binders such as ∀x, ∃x and Σx, where x can range over any
speciﬁed ﬁnite domain (e.g.
integer range but not integer).
The GRP constraint can be read “For any two unordered pairs
of ticks, pair1 and pair2, if the two pairs are different then the
distance between pair1 is not equal to the distance between
pair2.”

Now consider the speciﬁcation of the SONET problem
(Fig. 1). Notice that Nodes is declared to be a domain whose
elements are the integers in the range 1..nnodes. The param-
eter demand is to be instantiated with a set of sets, where
each inner set has cardinality two. The goal is to ﬁnd a mul-
tiset (the rings), each element of which is a set of Nodes (the
nodes on that ring). The objective is to minimise the sum of
the number of nodes installed on each ring. The constraint
ensures that any pair of nodes that must communicate are in-
stalled on a common ring.

Finally, Fig. 1 gives two versions of a speciﬁcation of the
Social Golfers problem (SGP). As the problem description
does not refer to the golfers individually, they are speciﬁed
naturally with an unnamed type. The decision variable is rep-
resented straightforwardly as a multiset (the fact that it is a
set is an implied constraint) of regular partitions, (regularity
guarantees equal-sized partitions) each representing a week
of play. The speciﬁcations differ only in the expression of the

socialisation constraint. The ﬁrst constraint quantiﬁes over
the weeks, ensuring that the size of the intersection between
every pair of elements of the corresponding partitions is at
most one (otherwise the same two golfers are in a group to-
gether more than once). The alternative constraint quantiﬁes
over the pairs of golfers, ensuring that they are partitioned to-
gether (via the global constraint together) over the weeks
of the schedule at most once. Note that here we make use of
a facility common to constraint languages: treating Booleans
as 0/1 for the purpose of counting.

3 The Features of ESSENCE
This section explains the most signiﬁcant
features of
ESSENCE. The ﬁrst two subsections discuss types and do-
mains and the next two discuss expressions and quantiﬁca-
tion.

ESSENCE is a strongly-typed language; every expression
has a type and the parser that can infer the types of expres-
sions and can perform type-checking. Types are also impor-
tant in determining the denotation of an overloaded operator.
For example, the union operator can denote set union or mul-
tiset union depending on the types of its arguments.

ESSENCE is a ﬁnite-domain language; every decision vari-
able is associated with a ﬁnite domain of values. These do-
mains can be quite intricate sets of values. For example a
domain could be any ﬁnite subset of integers or it could be
the set of two-element sets drawn from a given ﬁnite set of
integers.

Types and domains play a similar role; they prescribe a
range of values that a variable can take. It is tempting — and,
indeed, we were tempted — to view types and domains as one
and the same thing. However, this view leads to the difﬁcult,
if not unsolvable, problem that the intricate patterns used in
constructing domains must be handled by the type system.
For example, if every ﬁnite subset of the integers is a distinct
type then the problem of assigning types to expressions is
difﬁcult, if not impossible.

As we have desired to keep the type system of ESSENCE
simple, we have reached the decision that types and domains
are distinct, though closely related concepts. Types are sets
that contain all elements that have a similar structure, whereas
domains are sets drawn from a single type. In this manner,
each domain is associated with an underlying type. For ex-
ample integer is the type underlying the domain comprising
integers between 1 and 10; set of integers is the type under-
lying the domain comprising all sets of two integers between
1 and 10. Type checking, type inference, and operator over-
loading are based only on types, not on domains.

Types Our design goal has been to provide ESSENCE with
a rich collection of types, yet a simple type system. The rich-
ness of the types comes from the large number of types and
type constructors that are supported. The simplicity of the
type system comes from the fact that typing is static and that
all types are disjoint.

The atomic types of ESSENCE are int (integer), bool
(Boolean), user-deﬁned enumerated types and user-deﬁned
unnamed types. The two user-deﬁned types are deﬁned
through letting or given statements such as the following:

IJCAI-07

82

letting players be new type enum {alan, ian, chris, berna}
letting rings be new type of size 4
given players new type enum (...)
The ﬁrst statement deﬁnes a new type comprising four
named atomic elements. As all types are disjoint, the ele-
ments of this type cannot be members of any other type, and
the four names cannot be used to name anything else. The
second statement also deﬁnes a new type comprising four el-
ements; however these elements are not named. These four
elements are distinct from the elements of all other types. The
third statement is similar to the ﬁrst except that the enumer-
ation of the elements of the type is provided as input rather
than as part of the speciﬁcation.

The elements of the integer and Boolean types and of all
enumerated types are totally ordered. The integers are or-
dered in the usual way, the Booleans are ordered by F < T,
and the elements of an enumerated type take on the order in
which they are named in the letting statement or given as in-
put. All other types — user-deﬁned unnamed types and all
compound types — are unordered.

Compound types are built with type constructors to form
sets, multisets, functions, tuples, relations, partitions and ma-
trices. If τ, τ1, τ2, . . . are the names of any types, θ1, θ2, . . .
are the names of any ordered types, φ is the name of a ﬁnite
type (bool, an enumerated type or an unnamed type) and n
is any positive integer then the following all name compound
types:

set of τ
mset of τ
τ1 → τ2
tuple (cid:7)τ1, . . . , τn(cid:8)
rel τ1 × ··· × τn
partition of φ
rpartition of φ
matrix indexed by

[ θ1, . . . , θn ] of τ

(a ﬁnite set drawn from τ)
(a ﬁnite multiset drawn from τ)
(a ﬁnite3 partial function with domain τ1
and codomain τ2)
(an n-tuple)
(a ﬁnite n-ary relation)
(a partition of the elements of φ)
(a regular partition of the elements of φ)
(an n-dimensional matrix)

For example, set of int and rel int×int are both types.
The type constructors can be nested to arbitrary depth, thus
allowing types such as

set of set of set of int
rel partition of players × mset of set of int
Notice that ﬁniteness plays a central role in the semantic
explanation accompanying each type constructor above. A
consequence is that, although types may contain an inﬁnite
number of elements, each element is of a ﬁnite size or cardi-
nality. This is necessary to achieve the objective that ESSENCE
speciﬁcations can be mapped to CSPs.

Finally notice that the parameters and decision variables
of a speciﬁcation cannot enter the type names. This restric-
tion is necessary to enable the type of every expression in a
speciﬁcation to be determined before the parameters are in-
stantiated with values. This is why we say that ESSENCE is
statically typed.

Domains A domain is a set of values all of the same type.
In ESSENCE every type is a domain. ESSENCE also allows do-

3A function is ﬁnite if it is deﬁned on only a ﬁnite set of values.
Similarly, a relation is ﬁnite, if it contains only a ﬁnite set of tuples.

mains to be named by annotating the name of the type with
restrictions that select particular values of the type. For ex-
ample, int (1..10) and set (size 2) of int (1..10) are both
domains. As annotations are always written in parenthesis,
the type underlying a domain can always be obtained by re-
moving the parenthesised subexpressions. Thus, the types
underlying the above two domains are int and set of int,
respectively.

First consider how atomic types can be annotated to form
atomic domains. Atomic domains can be formed by taking
subsets of the integer or Boolean type or any enumerated
type. These subsets are identiﬁed either by a list contain-
ing values and value ranges or by an arbitrary set expression.
Examples include:

(the players from alan to chris inclusive)
(a mixture of values and ranges)
(the positive integers)
(the non-zero integers)
(the integers from l to u inclusive)
(the integers in S and 0 and 1)

players (alan..chris)
int (1, 3, 4..10)
int (1..)
int (..-1,1..)
int (l..u)
int (S ∪ {0, 1})
In these last two examples, l, u and S can be parameters or
identiﬁers declared by a letting statement. This illustrates
another important distinction between domains and types. Pa-
rameters can appear in the annotations of a domain but they
cannot appear in a type. However, decision variables cannot
appear in domains, a requirement that is needed if speciﬁca-
tions are to be mapped to CSPs.

Now consider how type constructors can be annotated. The
set, multiset, partition, regular partition and relation construc-
tors can all be annotated by inserting, before the keyword
“of,” a size restriction of the form (size intexp) or (maxsize
intexp), where intexp is an integer expression that contains no
decision variables. Thus, all the following are domains:

set (size n) of int
mset (maxsize n+2) of int (1..100)
partition (size m) of mset (maxsize 4) of int
(1..100)

The second and third of these domains illustrate that the an-
notations can be attached not only to the outer constructor,
but also to the nested constructors and atomic types. The
ESSENCE syntax has been designed so that there is no am-
biguity about where an annotation is attached.

In addition to the size annotation, the relation constructor
can also be annotated with multiplicities that specify, for ex-
ample, that a relation is n-to-m. As we have modelled this
feature on a similar feature provided by ESRA, we will not
describe it further.

The function constructor can have one annotation to indi-
cate that the function is total or partial and another to indicate
that the function is surjective, injective or bijective. For ex-
ample, the following are domains:
players →(total) players
players →(injective) players
players →(total surjective) players
The matrix and tuple type constructors take no annotations,
though, of course, the types nested in them can be annotated,
as in these examples:

tuple (cid:7) int (1..), set (size 2) of int (cid:8)
matrix indexed by [players, int (5..10)] of bool

IJCAI-07

83

In all uses of the matrix constructor the domains for the in-
dices must be a single range of an ordered type, as illustrated
in the second statement above.

Every domain is either ﬁnite or inﬁnite and the domains as-
sociated with a decision variable must be ﬁnite, which is re-
quired to ensure that speciﬁcations map to CSPs. Elsewhere
[Frisch et al., 2005a] we have given a set of rules for gen-
erating all ﬁnite domains. This paper instead relies on the
reader’s intuition and understanding to determine if a domain
contains a ﬁnite or inﬁnite set of elements.

Expressions The expressions of ESSENCE are formed in
a manner much as one would expect, bearing in mind that ev-
ery expression has a type. Constraints and the restrictions in
where statements are expressions of type Boolean and objec-
tive functions are expressions of any ordered type.

The atomic expressions of ESSENCE are the constants, pa-
rameters, decision variables and quantiﬁed variables. Other
than the unnamed types, and compound types constructed
from them, every value has a name. These names are the
constants of the language.

We shall not explain the syntax for naming constants, but
note that our objective was to give every value a distinct
name. A difﬁculty is that the emptyset is a member of ev-
ery type of the form set of τ. Our remedy is to explicitly
attach the type to every emptyset. Thus, for example {}:set
of int and {}:set of players are distinct names for distinct
objects.

Compound expressions are formed by applying operators
to expressions. ESSENCE provides a wide range of operators
drawn from discrete mathematics (e.g., intersection, function
application, projection, set membership), logic (e.g., conjunc-
tion, implication), and the global constraints found in con-
straint programming (e.g., alldifferent, global cardinality, lex-
icographic ordering). Whereas the global constraints of other
constraint languages apply only to matrices of integers, those
of ESSENCE apply to matrices of any reasonable type. For ex-
ample, in ESSENCE, alldifferent applies to a matrix of any type
and lexicographic ordering applies to two one-dimensional
matrices of any ordered type.

The type of a compound expression is a function of its op-
erator and the types of its operands. Some operators are over-
loaded. For example, the intersection operator can be applied
to two multisets to produce a multiset and it can be applied to
two sets to produce a set.

Quantiﬁcation ESSENCE provides an exceptionally rich
set of constructs for expressing quantiﬁcation. Examples
can be seen in all of the constraints of Fig 1 as well is in
the “minimising” statement of the SONET speciﬁcation.
Each quantiﬁcation expression consists of three components:
, ∀ or ∃; followed by a non-empty list
a quantiﬁer, either
of variables (these are the quantiﬁed variables that are being
“declared”); followed by a binding expression that dictates a
ﬁnite set of values over which the variables range. These val-
ues are all of the same type, and this is taken as the type of
the associated quantiﬁed variables. The ﬁniteness of the set
of values over which a variable ranges is necessary to enable
the mapping of speciﬁcations to CSPs.

Binding expressions employ two methods of dictating
these values. The ﬁrst is to give a ﬁnite domain, as in the the

P

universal quantiﬁer of the alternative constraint of the SGP
speciﬁcation in Fig. 1. The second method is to obtain the
values by taking all elements or (strict or non-strict) subsets of
a set, partition or regular partition. All the quantiﬁcation ex-
pressions in the Knapsack and SONET speciﬁcations in Fig. 1
draw their values from a set. The set, partition or regular par-
tition can be denoted by an arbitrary expression, including
expressions that contain decision variables, as seen in the ex-
amples mentioned. In quantiﬁcation expressions of this kind
there is no need to specify the types of the quantiﬁed variables
as they can easily be inferred. For example, in the quantiﬁed
(cid:2) of the Knapsack speciﬁcation it is clear
expression
that u must be of type U since U(cid:13) is of type set of U. Fi-
nally it is also possible to employ both methods to dictate the
values taken by the quantiﬁed variables. An example is seen
in the constraint of the GRP speciﬁcation. Here pair1 and
pair2 must each be a subset of T icks and must also be a set
of size 2.4

u∈U

(cid:2)

4 Abstraction in ESSENCE
This section explains how the features of ESSENCE, as intro-
duced in the previous section, yield a language with a great
deal of abstraction.

A guiding principle in the design of ESSENCE has been that
the language should not force a speciﬁcation to provide un-
necessary information or make unnecessary decisions. Ex-
isting languages often force a speciﬁcation to introduce un-
necessary objects or to unnecessarily distinguish between ob-
jects. This typically introduces symmetry into the speciﬁca-
tion. As will be demonstrated, the facilities ESSENCE has for
abstraction enable this to be avoided.

The high level of abstraction provided by ESSENCE is pri-
marily a consequence of four features, which we discuss in
the next four subsections.

Wide Range of Types ESSENCE supports a wide range of
types and type constructors (including sets, multisets, tuples,
relations, functions and partitions) and decision variables can
have domains containing values of any one of these types.
For example, the KNAPSACK problem requires identifying
the set of objects that are to go in the knapsack, so this is
readily represented by a decision variable of type set of U,
where U is the set of all objects. The objects themselves are
a given enumerated type; there is no need to identify them
with, say, integers. Notice that the speciﬁcation of Garey and
Johnson [1979] does not identify the objects with integers and
a speciﬁcation language should not force one to do so.

Nested Types ESSENCE allows type constructors to be
nested to arbitrary depth. This is the most important and dis-
tinctive feature of ESSENCE, and could be considered our most
important contribution to the design of constraint languages.
To observe its importance, consider the SONET problem,
which requires placing each of a set of communicating nodes
onto one or more communication rings in such a way that the
speciﬁed communication demand is met. Thus, the goal is to
ﬁnd a set of rings, each of which is a set of nodes—and this

4In this case the domain is not ﬁnite, but ﬁniteness is obtained

since the sets must be a subset of T icks, which is ﬁnite.

IJCAI-07

84

can be stated directly and explicitly in ESSENCE by using a
decision variable of type set of sets.

Many languages support variables of type set of integer, but
not nested sets. In such a language one would have to model
the decision variable of SONET by a matrix of set variables,
and the indices of this matrix would be symmetric. Thus, a
limitation of the modelling language has forced the user to in-
troduce a symmetry into the speciﬁcation that is not present in
the problem. Notice that neither this symmetry, nor anything
corresponding to it, is present in the ESSENCE speciﬁcation of
Fig. 1.

Alternatively, one could model the SONET problem with
a decision variable whose type is a relation between the rings
and the nodes. But, again, this introduces a symmetry into
the model as the individual rings are interchangeable.

Quantiﬁcation over Decision Variables As we have
seen, ESSENCE allows quantiﬁers to range over values de-
termined by a decision variable. For example, notice that
the constraint of the GRP (see Fig. 1) is of the form
∀pair1, pair2⊆Ticks.Constraint, where Ticks is a decision variable
of type set. Without this capability, the GRP constraint
would need to take the form

∀
pair1, pair2:set (size 2) of int (1..2n).

(pair1⊆Ticks ∧ pair2⊆Ticks) =⇒ Constraint

Besides being awkward, this always leads to an implemen-
tation containing Θ(24n) constraints, one for each way of
drawing two pairs from a set of 2n elements. In contrast, the
ESSENCE constraint that quantiﬁes over the decision variable
can be compiled to a model with Θ(n4) constraints, one for
each way of drawing two pairs from a set of n elements.

Unnamed Types ESSENCE provides types containing un-
named, indistinguishable elements, a feature necessary for
adequate abstraction. Many problems involve some set of el-
ements, yet do not mention particular elements. For example,
we know of no speciﬁcation or model of the SGP in which the
constraints name any particular golfer, hence the golfers are
indistinguishable. But since constraint languages do not have
unnamed types, all models and speciﬁcations, other than the
ESSENCE speciﬁcation in Fig. 1, name the golfers either in the
speciﬁcation itself or in giving the input values. Naming, and
hence distinguishing, the otherwise indistinguishable golfers
introduces symmetry into the model, namely the golfer names
can be interchanged.

Implementing ESSENCE

5
At this point we have implemented in Haskell a parser for
all of ESSENCE 1.1.0; it performs complete syntactic analysis,
including all necessary type checking and type inference. A
second implementation of this same parser in Java is nearing
completion.

We have implemented a rule-based system, called CON-
JURE [Frisch et al., 2005c], that can translate —we say reﬁne
— speciﬁcations in a fragment of ESSENCE into model kernels
at a level of abstraction supported by existing modelling lan-
guages. We call these “kernels” because they do not contain
many of the enhancements that characterize the most effective
models, such as symmetry-breaking constraints and implied
constraints.

The model kernels generated by CONJURE are expressed
(cid:2), a subset of ESSENCE that has a level of abstrac-
in ESSENCE
tion that is supported by existing constraint solvers. As such,
(cid:2) only supports atomic variables, atomic set vari-
ESSENCE
ables, and matrices of these. It allows neither quantiﬁcation
(cid:2)
over decision variables nor unnamed types. Thus, ESSENCE
can be thought of as a solver-independent modelling language
and is somewhat similar to OPL, another solver-independent
modelling language.
(cid:2) has a level of abstraction similar to ex-
Because ESSENCE
(cid:2)
isting solvers it is not extremely difﬁcult to translate ESSENCE
models into existing languages. In particular, the translation
can be performed without making any modelling decisions.
(cid:2) to
We have implemented a translator for mapping ESSENCE
Eclipse [Wallace et al., 1997] and are currently developing
(cid:2) to Minion [Gent et al., 2006].
another one to map ESSENCE
One reason why new types of decision variables have
been incorporated into constraint programming languages so
slowly has been the difﬁculty of implementing the enhance-
ments. Frisch et.al. [2005c] identify a difﬁcult, fundamental
problem in reﬁning types that can be nested to arbitrary depth
and they present a solution to it. With this breakthrough,
and other techniques pioneered in the development of the
CONJURE prototype, we believe we have all the technology
needed to reﬁne all of ESSENCE to kernel models.

Of course, our ultimate goal is to develop a reﬁnement sys-
tem that can reﬁne any ESSENCE speciﬁcation into a single,
(cid:2) model. We consider this to be
complete, effective ESSENCE
the goal of achieving fully-automated modelling, something
which we do not consider achievable in less than a lifetime.
As explained earlier, the development of a suitable problem
speciﬁcation language is necessary to embark on the venture.

6 An Evaluation of the Use of ESSENCE
To evaluate ESSENCE we speciﬁed a large suite of problems
in the language and here reﬂect on the process and results.
A suite of 58 problems, both theoretical and practical, was
selected, 26 drawn from CSPLib, and 32 from the literature.
Speciﬁcation was undertaken by an undergraduate in com-
puter science with no previous experience of constraint or
logic programming. He was easily able to adapt to ESSENCE
by drawing on his understanding of discrete mathematics.

Speciﬁcation began by obtaining an unambiguous natu-
ral language description of the problem. The ﬂexibility of
ESSENCE allowed speciﬁcations to be written directly from
this description. The key decision concerned the representa-
tion of the decision variables; from this the constraints fol-
lowed easily. Attention had to be paid to abstraction in order
to make full use of the language. Some of the problems were
described in the literature in terms of low-level objects such
as matrices. With the goal of producing an abstract speciﬁca-
tion there was typically a single obvious choice for the type
of the decision variable. This was not, however, always the
case: in the SONET problem the conﬁguration can be repre-
sented as a relation from rings to nodes or as a set of sets of
nodes. The latter is preferable as it avoids having to name the
rings.

Speciﬁcation grew easier with experience; many speciﬁca-

IJCAI-07

85

tions contained reusable common idioms. Another advantage
of ESSENCE is that similarities are present in abstract spec-
iﬁcations that would not necessarily appear in the concrete
constraint programs due to differing modelling choices.

The resulting catalogue [York Web, 2006] contains
ESSENCE speciﬁcations for the problem suite and, for compar-
ison, previously-published speciﬁcations in Z, ESRA, OPL and
F. The relative expressiveness and elegance of ESSENCE is
clearly demonstrated. Throughout, the speciﬁcation length is
proportional to the size of the problem statement, with larger
examples being just as easy to read.

7 Comparison with Other Languages
Algebraic modelling languages, dating from the 1970s and
originating in the ﬁeld of mathematical programming (e.g.
GAMS [Brooke et al., 1988] and MGG [Simons, 1987]),
made two signiﬁcant advances. Firstly they were developed
to simplify the user’s role in solving mathematical program-
ming problems, providing a syntax much closer to the ex-
pression of these problems found in the literature. Secondly,
they are declarative, characterising the solutions to a problem
rather than how the solutions are to be found. This lifts a bur-
den from the user, and allows different solvers to be easily
applied to the same problem. Many other useful modelling
languages have been created in other areas, for example ACE
[Fuchs and Schwitter, 1996], an English-like modelling lan-
guage for reasoning about knowledge bases.

The success of modelling languages suggests that a similar
approach might be fruitful for constraint solving. From early
in the development of the ﬁeld, the ALICE language [Lau-
riere, 1978] shares many features with algebraic modelling
languages of the time, including its declarative nature.

Constraint programming languages have gradually evolved
a greater range of types for decision variables. For example,
Eclipse [Gervet, 1994] supports decision variables whose do-
main elements are sets; similarly F supports functions, ESRA
supports relations and functions, and NP-Spec supports sets,
permutations, partitions and integer functions. Each increase
in abstraction allows the user to ignore additional modelling
decisions, leaving this to the compiler. ESSENCE makes a
large leap in this direction by providing a range of types wider
than previous languages and, uniquely, type constructors that
can be arbitrarily-nested. The magnitude and importance of
this leap cannot be over-emphasized; it is largely responsi-
ble for making ESSENCE a problem speciﬁcation language
rather than a modelling language. Zinc [Marriott et al., 2006;
de la Banda et al., 2006] is a new speciﬁcation language
that follows ESSENCE in providing arbitrarily-nested type
constructors but also provides some features not found in
Essence, such as the ability to deﬁne predicates. The Zinc
language is still in development and a full implementation
does not yet exist.

To fully realise the abstraction provided by a rich type sys-
tem a language must permit quantiﬁcation over decision vari-
ables, rather than just ﬁxed ranges of integers. Other than
ESSENCE we know of only three constraint languages that
provide this feature: ESRA, F and LOCALIZER [Michel and
Van Hentenryck, 2000]. It is worth noting that these are all

SONET Optimisation Part
solution : SONET
objective : SONET
∀ s : SONET • objective(s) = #(s.rings-nodes)
objective(solution) = min(objective SONET )

Figure 2: Part of a Z speciﬁcation of the SONET problem.

declarative languages. In contrast, programming languages
that are augmented with constraint facilities, such as Solver
and Eclipse, achieve quantiﬁcation through iteration, which
makes it impossible to support quantiﬁcation over variables.
Further abstraction is obtained through the provision of un-
named types. As far as we know, ESSENCE is the only con-
straint language to provide such a facility.5

Another approach to problem speciﬁcation is to employ a
more-powerful, more-general speciﬁcation language such as
Z. This approach has been explored thoroughly by Renker
and Ahriz [2004], who have built a toolkit of Z schemas to
support common global constraints and other common idioms
and have used this to build a large catalogue of speciﬁcations
[RGU Web, 2006]. A shortcoming of this approach is that Z
is too general for the task as it allows speciﬁcations of prob-
lems that do not naturally reduce to the CSP. For example,
unlike ESSENCE, nothing prevents a decision variable from
having no domain or an inﬁnite domain and nothing prevents
using a decision variable to specify the size of a matrix of de-
cision variables. Of course, one could try to identify a subset
of Z that is suitable for the task, but we believe doing this
and enhancing the language with a suitable schema library
would result in a language that approximates ESSENCE. Fur-
thermore, an inherent limitation of Z is that it provides no
mechanism for distinguishing parameters from decision vari-
ables, a distinction that is central to the notion of a problem.
A further shortcoming of speciﬁcations in a language like
Z is that they are far less natural than those in ESSENCE.
To observe this, compare the equivalent speciﬁcations, avail-
able at [RGU Web, 2006], of the SONET problem in the
two languages. Figure 2 shows part of that Z speciﬁcation,
which is equivalent to the ESSENCE statement “minimising
|rings-nodes|”.

The Alloy [Jackson, 2006] language avoids some of these
shortcomings of Z by restricting itself to ﬁrst-order logic. Al-
loy gives a natural and expressive way of specifying problems
in terms of relations and atoms and maps these speciﬁcations
to efﬁcient SAT models. Without a more expressive type sys-
tem, however, it is not obvious how Alloy could be mapped
to constraint languages, and in particular make good use of
global constraints, which are vital to efﬁcient constraint mod-
els.

8 Conclusion
ESSENCE is a formal language that is natural in that it accessi-
ble to someone with an understanding of discrete mathemat-
ics but not constraint programming. ESSENCE allows combi-
natorial problems to be speciﬁed at a high level of abstrac-

5Frisch and Miguel [2006] argue that the sets of unnamed objects
provided by ESRA are a different facility that does not yield all the
beneﬁts of unnamed types.

IJCAI-07

86

[Fuchs and Schwitter, 1996] Norbert Fuchs and Rolf Schwitter. At-
tempto controlled English (ACE). In Proc. of 1st International
Workshop on Controlled Language, 1996.

[Garey and Johnson, 1979] Michael R. Garey and David S. John-

son. Computers and Intractability. W. H. Freeman, 1979.

[Gent et al., 2006] Ian Gent, Christopher Jefferson, and Ian Miguel.
Minion: Lean, fast constraint solving. In Proceedings of the 17th
European Conference on Artiﬁcal Intelligence, 2006.

[Gervet, 1994] Carmen Gervet. Conjunto: Constraint logic pro-
gramming with ﬁnite set domains. In Maurice Bruynooghe, edi-
tor, Logic Programming — Proc. of the 1994 International Sym-
posium, pages 339–358. The MIT Press, 1994.

[Hnich, 2003] Brahim Hnich. Function Variables for Constraint
Programming. PhD thesis, Computer Science Division, Dept. of
Information Science, Uppsala University, 2003.

[Jackson, 2006] Daniel Jackson.

Software Abstractions: Logic,

Language, and Analysis. The MIT Press, 2006.

[Lauriere, 1978] Jean-Louis Lauriere. ALICE: A language and a
program for stating and solving combinatorial problems. Artiﬁ-
cial Intelligence, 10(1):29–127, 1978.

[Marriott et al., 2006] Kim Marriott, Reza Rafeh, Mark Wallace,
Maria Garcia de la Banda, and Nicholas Nethercote. Zinc 0.1:
Language and libraries. Technical report, Monash University,
2006.

[Michel and Van Hentenryck, 2000] Laurent Michel and Pascal

Van Hentenryck. Localizer. Constraints, 5(1/2):43–84, 2000.

[Renker and Ahriz, 2004] Gerrit Renker and Hatem Ahriz. Build-
ing models through formal speciﬁcation.
In Proc of the First
Int. Conf. on the Integration of AI and OR Techniques in Con-
straint Programming for Combinatorial Optimization Problems,
volume 3011 of Lecture Notes in Computer Science, pages 395–
401. Springer, 2004.

[RGU Web, 2006] www.comp.rgu.ac.uk/staff/ha/ZCSP/, 2006.
[Simons, 1987] R.V. Simons. Mathematical programming model-
ing using MGG. IMA Journal of Mathematics in Management,
1:267–276, 1987.

[Spivey, 1989] J. M. Spivey. An introduction to Z and formal spec-

iﬁcations. Software Engineering Journal, 4(1):40–50, 1989.

[Van Hentenryck, 1999] P. Van Hentenryck. The OPL Optimization

Programming Language. The MIT Press, 1999.

[Wallace et al., 1997] M. G. Wallace, S. Novello, and J. Schimpf.
ICL

ECLiPSe: A platform for constraint logic programming.
Systems Journal, 12(1):159–200, 1997.

[York Web, 2006] www.cs.york.ac.uk/aig/constraints/AutoModel,

2006.

tion. The result is that problems can be speciﬁed without
(or almost without) modelling them. The central, unique fea-
ture of ESSENCE is that it supports complex, arbitrarily-nested
types. Consequently, a problem that requires ﬁnding a com-
plex combinatorial object can be directly speciﬁed by using a
decision variable whose type is precisely that combinatorial
object.

We plan to continue the development of ESSENCE by spec-
ifying a much wider range of problems in the language and
using this to guide the design of further features and enhance-
ments. among other developments, we expect that this will
lead to the incorporation of additional operators for construct-
ing expressions and additional type constructors such as lists,
trees and graphs.

Acknowledgements
Ian Miguel is supported by a UK Royal Academy of En-
gineeering/EPSRC Research Fellowship. We thank Andy
Grayland for his useful comments on the syntax of ESSENCE.

References
[Brooke et al., 1988] Anthony Brooke, David Kendrick,

and
Alexander Meeraus. GAMS: A Users’ Guide. The Scientiﬁc
Press, Danvers, Massachusetts, 1988.

[Cadoli et al., 2000] Marco Cadoli, Giovambattista Ianni, Luigi
Palopoli, Andrea Schaerf, and Dominico Vasile. NP-SPEC: An
executable speciﬁcation language for solving all problems in NP.
Computer Languages, 26:165–195, 2000.

[de la Banda et al., 2006] Maria Garcia de la Banda, Kim Marriot,
Reza Rafeh, and Mark Wallace. The modelling language Zinc. In
Principles and Practice of Constraint Programming — CP 2006,
volume 4204 of Lecture Notes in Computer Science, pages 700–
705. Springer, 2006.

[Flener et al., 2004] Pierre Flener, Justin Pearson, and Magnus
Agren. Introducing ESRA, a relational language for modelling
combinatorial problems.
In Proceedings of LOPSTR ’03: Re-
vised Selected Papers, volume 3018 of Lecture Notes in Com-
puter Science, 2004.

[Frisch and Miguel, 2006] Alan M. Frisch and Ian Miguel. The
concept and provenance of unnamed, indistinguishable types.
Available
at www.cs.york.ac.uk/aig/constraints/AutoModel/,
September 2006.

[Frisch et al., 2005a] Alan M. Frisch, Matthew Grum, Christopher
Jefferson, Bernadette Mart´ınez Hern´andez, and Ian Miguel. The
essence of ESSENCE: A language for specifying combinatorial
problems. In Proc. of the 4th Int. Workshop on Modelling and
Reformulating Constraint Satisfaction Problems, pages 73–88,
2005.

[Frisch et al., 2005b] Alan M. Frisch, Brahim Hnich, Ian Miguel,
Barbara M. Smith, and Toby Walsh. Transforming and reﬁn-
ing abstract constraint speciﬁcations. In Proceedings of the Sixth
Symposium on Abstraction, Reformulation and Approximation,
volume 3607 of Lecture Notes in Computer Science, pages 76–
91. Springer, 2005.

[Frisch et al., 2005c] Alan M. Frisch, Christopher

Jefferson,
Bernadette Mart´ınez Hern´andez, and Ian Miguel. The rules of
constraint modelling. In Proc. of the Nineteenth Int. Joint Conf.
on Artiﬁcial Intelligence, pages 109–116, 2005.

IJCAI-07

87

