CONCEPTS  AND  METHODS  FOR  HEURISTIC  SEARCH 

E r ik  J  S a n d e w a ll 

Computer  S c i e n c es  Department 

U p p s a la  U n i v e r s i t y-
Sweden 

U p p s a l a, 

0.  Summary 

The 

t r ee 

" p r o b l e m - s o l v i n g"  a re 

t r a n s f o r m a t i on  or  d e r i v a t i on  p r o b l em 
is 

r e v i e w e d.  The  c o n v e n t i o­

" p r o b l e m - s o l v i n g"  programs 
f o r m al  n o t a t i o n,  and  v a r i o us  methods 

t r e a t ed  by  most 
e x p r e s s ed 
in  a 
f or 
n al  s e a r ch 
l a t t i ce  w h i ch  can  accomodate  m u l t i p l e - i n p ut  o p e r a­
t o r s,  e . g. 
d e s c r i p t i o ns  of  h e u r i s t ic  methods  can  be  s i g n i­
f i c a n t ly  compacted 
t i on 
p r a c t i c al  e x a m p l e s. 

r e s o l u t i o n.  The  paper  argues 

if  a  h i g h er  degree  of 

is  u s e d.  T h is  p o i nt 

i l l u s t r a t ed  w i th 

is  g e n e r a l i z ed 

i n to  a  s e a r ch 

f o r m a l i z a­

t h at 

two 

is 

1. 

I n t r o d u c t i on 

T h is  p a p er 

is  an  a t t e m pt  at  a  s u r v ey  and 

s y n t h e s is  of  p a st  work  on  h e u r i s t ic  s e a r ch  m e t h o d s. 
F o l l o w i ng  Feigenbaum  and  Feldman 
( 1 9 6 3 ),  we  d e f i ne 
a  h e u r i s t ic  method  as  a  d e v i ce  w h i ch  d r a s t i c a l ly 
l i m i ts  s e a r ch 
s p a c e s.  As  can  be  seen 
l i st  of  r e f e r e n c e s, 
much  w o rk  on  h e u r i s t ic  methods  has  been  p e r f o r m ed 
d u r i ng 

l a r ge  p r o b l em 

f or  s o l u t i o ns 

few  y e a r s. 

f r om  t he 

l a st 

t he 

in 

in 

In 

t h is 

,  Moses  c h a r a c t e r i z es 

Two  approaches  have  been  c o m p e t i ng 
In  h is  r e p o rt  on  SIN 

to  w r i te  a  g e n e r al  program  w h i ch  can  s o l ve 

w o r k. 
them  as  e m p h a s i z i ng  g e n e r a l i ty  and  e x p e r t i s e, 
r e s p e c t i v e l y. 
t he  g e n e r a l i ty  a p p r o a c h,  one 
t r i es 
a ll  k i n ds  of  p r o b l e m s,  p r o v i d ed  o n ly 
( a d e q u a t e ly  p h r a s e d) 
" p r o b l em  e n v i r o n m e n t"  of  each  p r o b l em 
p a r t i c u l ar 
is  p r o v i d e d.  The 
( s i c ! ), 
DEDUCOM,  and  t he  Graph  T r a v e r s er  a re  examples  of 
t h is  a p p r o a c h. 

" G e n e r al  Problem  S o l v e r" 

i n f o r m a t i on  about 

t h at 

t he 

In 

t he  a p p r o a ch 

i n s t e ad  on  w r i t i ng  a  good  p r o g r am 

t h at  s t r e s s es  e x p e r t i s e,  one 
f or 
in  one  g i v en  p r o b l em  e n v i r o n m e n t. 

c o n c e n t r a t es 
s o l v i ng  p r o b l e ms 
SIN 
as  a re  g a m e - p l a y i ng  programs  (Samuel'  s,  G r e e n b l a t f s ), 
and  some  programs  w h i c h,  a c c o r d i ng 
b e i ng  used 
i n d u s t r i al  p u r p o s e s. 

t y p i c al  example  of 

t h at  a p p r o a c h, 

to  r u m o u r,  a re 

i t s e lf 

is  a 

f or 

T h is 

r e s e a r ch  was  s u p p o r t ed 

in  p a rt  by 

t he 

( c o n t r a c ts 

The  advantages  and  disadvantages  of  each 

approach  are  obvious:  generality  has  to  be  paid 
f or  by  a  decrease  in  program  e f f i c i e n c y.  An 
advantage  w i th  the  generality  approach  is  that 
one  single  h e u r i s t ic  method  can  quickly  be  put  to 
use 

in  a  v a r i e ty  of  problem  domains. 

It  would  seem,  however,  t h at  methods  which 
have  been  developed  in  one  "expertise"  program 
can  be  c a r r i ed  over  to  another  problem  environment 
and  another  program.  The  only  problem  is  to  p u ll 
out  the  abstract  h e u r i s t ic  methods  from  the  program 
d e s c r i p t i o n s,  which  are  often  quite  technical  and 
d e t a i l e d. 

t h is 

theory  it 

is  shown  t h at 

One  example  of  t h is  w i ll  s u f f i c e.  The  SIN 
program  contains  an  important  h e u r i s t i c,  which 
Moses  describes  as  f o l l o w s:  "The  Edge  h e u r i s t ic 
is  based  on  the  L i o u v i l le  theory  of  i n t e g r a t i o n. 
In 
is 
integrable  in  closed  form, 
then  the  form  of  the 
i n t e g r al  can  be  deduced  up  to  c e r t a in  c o e f f i c i e n t s. 
A  program  which  employs  the  Edge  h e u r i s t i c,  called 
Edge,  uses  a  simple  analysis  to  guess  at  the  form 
of  the 
to  obtain 
c o e f f i c i e n t s ."  (page  8 ).  The  Edge  h e u r i s t ic  is 
f u r t h er  described  on  seventeen  pages  in  chapter  5-

i n t e g r al  and  then 

if  a  function 

it  attempts 

to 

( i . e. 

f a i ls 

the  author 

Unfortunately, 
formulate 
important  h e u r i s t ic  method  in  abstract  terms. 

the  set  of  a ll  expressions  where  the 

t h is 
Such  an  abstract  formulation  could  e.g.  run  as 
f o l l o w s:  The  purpose  of  the  i n t e g r a t i on  program 
is  to  s t a rt 
i n i t i al  o b j e c t,  and  to 
from  a  g i v e n, 
apply  the  r i g ht  operators 
(from  a  given  set  of 
operators) 
in  the  r i g ht  order,  u n t il  the  given 
object  has  been  transformed  i n to  a  given  target 
set 
i n t e g r al  sign(s)  have  been  eliminated).  The  Edge 
h e u r i s t ic  r e l i es  on  information  which 
is  l o c al  to 
t h is  p a r t i c u l ar  problem  environment,  and  which 
makes 
it  possible  to  say,  during  the  search  of 
the  s o l u t i on  t r e e,  where  in  the  target  set  we  w i ll 
eventually  l a n d.  The  Edge  program  u t i l i z es  t h is 
information  to  get  a  b e t t er  estimate  of  the 
remaining  "distance"  to  the  target  set 
from  each 
node.  -  With  such  a  description,  it  becomes  clear 
t h at  the  same  h e u r i s t ic  may  w e ll  be  applicable  to 
other  problem  environments, 
oriented  programs. 

in  other  e x p e r t i s e-

Swedish  N a t u r al  S c i e n ce  Research  C o u n c il 
Dnr  2 7 1 1 - 5,  2 7 1 1 - 6)  and  by  t he  Swedish  Research 
I n s t i t u te  of  N a t i o n al  Defense 
( b e s t a l l n.  714257, 
7 1 5 4 1 1 ). 
** 

.. 

.

.

We  s h a ll  r e f er  to  previous  work  in  h e u r i s t i cs 
by  i ts  acronym  and/or  the  author's  name.  For  exact 
references,  use  tables  at  the  end  of  the  paper. 

Abstract  method  descriptions,  as  o u t l i n ed 

here,  can  of  course  not  serve  as  substitutes  f or 
conventional  ones.  A  concrete  d e s c r i p t i o n,  l i ke 
the  one  Moses  has  given  f or  SIN,  w i ll  always  be 

-199-

needed  by  the  user  of  the  program,  or  the 
researche  who  attempts  to  improve  on  previous 
work.  By  c o n t r a s t,  the  abstract  description  is 
u s e f ul  f or  the  man  who  wants 
methods  to  other  problem  environments,  and  (of 
course) 
f or  the  t h e o r e t i c i an  who,  some  time  in 
the  f u t u r e,  w i ll  attempt  to  b u i ld  a  mathematical 
theory  of  h e u r i s t i c s. 

to  carry  over 

The  morale  i s,  t h e r e f o r e,  t h at  we  need  an 
abstract  frame  of  reference,  a  set  of  concepts 
f or  describing  and  analysing  h e u r i s t ic  methods. 
Such  concepts  would  help  in  the  dissemination  of 
know-how; 
they  would  also  make  it  possible  to 
compare  the  e f f i c i e n cy  of  various  methods  and 
programs,  expertise-oriented  as  w e ll  as  g e n e r a l i t y-
o r i e n t e d. 

In  t h is  r e p o r t,  we  s h a ll  attempt  to  set  up 

In  sections  3-4, 

In  section  2,  we 

such  a  "frame  of  reference". 
formulate  a  general  "transformation  problem",  and 
discuss  some  of  i ts  cases. 
various  commonly  used  h e u r i s t ic  techniques  are 
formulated  and  discussed.  Since  we  argued,  in 
section  2, 
operators  must  be  c a r e f u l ly  d i s t i n g u i s h e d,  we  use 
section  5  to  extend  the  conventional  search  tree 
i n to  a  search  l a t t i c e.  Our  stock  of  concepts 
tested  in  sections  6-7,  where  abstract  descriptions 
of  some  well-known  programs  and  h e u r i s t ic  methods 
are  given. 

that  one-input  and  m u l t i p l e - i n p ut 

is 

2.  Heuristic  search:  rules  of  the  game 

The  problem  environments 

f or  h e u r i s t ic  search 

methods  always  include  a  set  P  of  objects  and  a 
set  Q  of  operators  on  these  objects.  The  f o l l o w i ng 
problem  has  often  been  s t u d i e d, 
(see  e . g.  {Newell 
1960c}  and  {Doran  1967a}),  and  has  sometimes  been 
r e f e r r ed  to  as  the  problem-solving  problem: 

Basic  transformation  problem. 

Given  an  i n i t i al  set 

Q  such  t h at 

determine 

r 

in  R 

and 

q, , q2, . .. q 

in 

e x i s ts  and  is  a  member  of  the  t a r g et  set  M.  We 
c a ll  t h is  a  transformation  problem  from  R 

to  M. 

A  method  f or  solving  basic  transformation 
problems 
is  called  a  h e u r i s t ic  search  method  if 
it  searches  the  t r e e ( s)  of  a ll  possible  operator 
a p p l i c a t i o n s,  and  the  order  in  which  the  nodes  of 
t h is  tree  are  inspected, 
is  governed  in  some  ways 
by  properties  of  the  nodes  which  have  already  been 
created.  H e u r i s t ic  methods  r e q u i r e, 
that 
the  objects  in  P  are  known  as  symbolic  expressions 
or  otherwise  have  a  n o n - t r i v i al  information  content. 
They  cannot  simply  be  non-informative  tokens  of  the 
form  " p . ".  The  f o l l o w i ng  v a r i a t i o ns  to  the  basic 
transformation  problem  occur 

f r e q u e n t l y: 

t h e r e f o r, 

Operators  w i th  several  outputs. 

The  problem  s p e c i f i c a t i on  is  changed  as 

f o l l o w s.  A p p l i c a t i on  of  an  operator  can  r e t u rn  a 

set  of  o b j e c t s,  rather  than  a  single  o b j e c t. 
In 
the  transformation  process,  each  output  of  the 
operator  must  then  be  transformed  i n to  the  t a r g et 
set. 

In  a n a l y t ic  i n t e g r a t i o n,  the  t a r g et  set  M 

Example: 
consists  of  the  set  of  a ll 
i n t e g r a t i on  sign  does  not  occur.  The  r u le 

formulae  where  the 

can  be  used  as  an  operator  q  defined  by 

q 

t e l ls  us  to  integrate  A  +  B 

In  other  words, 
by  i n t e g r a t i ng  A  and  B  separately. 
task  of  j o i n i ng  together  the  solutions 
two  i n t e g r a t i on  problems  with  a  +  sign  is  a 
t r i v i al  m a t t e r ). 

(The  f i n al 
to  those 

Operators  w i th  several 

i n p u t. 

The  problem  s p e c i f i c a t i on  is  changed  as 

I n i t i a l l y,  each  member  of  R 
a v a i l a b l e.  At  each  cycle  o f . t he  s o l u t i on  process, 
one  selects  one  operator 
i 
arguments,  and 

available  objects 

which  requires 

is  considered 

i 

f o l l o w s. 
/ 

is  defined, 
is 
objects.  Problem: 
is  also  a  member  of  M 

it 

. 

included  among  the  available 
f i nd  some  available  object  which 

in 

in  the  r e s u l u-

frequently  occurs 

It  has  been  common  practice 

Exemple:  This  v a r i a t i on 
"forward"  l o g i c al  inference,  e . g. 
t i on  l o g ic  environment. 
in  h e u r i s t ic  research  to  consider  the  cases  of 
several  inputs  or  several  outputs  as  t r i v i al 
extensions  of  the  one-input/one-output  case.  For 
example,  the  General  Problem  Solver  is 
formulated 
in  terms  of  one  input  operators,  and  then 
immediately  applied  to  a  problem  environment  where 
a  two-input  operator  (Modus  Ponens  in  forward  proof) 
is  e s s e n t i a l.  S i m i l a r l y,  Slaglers  group  have 
attempted  to  use  t h e ir  MULTIPLE  program  (which  is 
designed  f or  one-input,  m u l t i p l e - o u t p ut  operators) 
to  the  r e s o l u t i on  l o g ic  environment,  where  the  most 
important  operator  has  two  inputs  and  one  output. 

The  f a ct  t h at  an  operator  requires  several 

as 

In  the  case 

inputs  can  be  "hidden"  in  various  ways. 
of  Modus  Ponens,  which  takes  A  and 
i n p u t s,  one  can  say  t h at  the  operator  " e s s e n t i a l l y" 
takes 

as  i n p u t,  so  that  the  merit  of  an 
formula  determines  whether  the  operator  -
If  the  system  decides  to 

it  checks 
is  n o t, 

s h a ll  be  applied  or  n o t. 
apply  Modus  Ponens  to  a  formula 
whether  the  formula  A 
the  output  is  " f a i l u r e ",  -  Another,  and  more  general 
way  of  h i d i ng  m u l t i p le 
to  consider  the  set 
of  a ll  available  objects  as  a  "higher  l e v e l"  o b j e c t. 
S i m i l a r l y, 
the  operators  are  redefined  to  accept  one 
higher  l e v el  object  as  i n p u t,  and  to  emit  an 
incremented  object  as  output.  The  disadvantage  of 
a ll  such  t r i c ks 
information  gets 
l o st  to  the  system.  For  example,  w i th  the 

is  a v a i l a b l e. 

important 

inputs 

t h at 

If  it 

is 

is 

200-

i n t r o d u c t i on  of  "higher  l e v e l"  objects  and 
operators,  one  w i ll  have 

q(p)  -  p 

is  essential 

(  except  when 
a p p l i c a t i on  of  q,  or 
the  a p p l i c a t i on  of 
t r a d i t i o n al  tree-search  routines  "aware"  of  such 
commutativity. 
In  our  opinion,  one  should  instead 
face  the  f a ct  that  some  operators  take  m u l t i p le 
i n p u t s,  and  study  then  separately. 

It  is  hard  to  make 

is  essential  f or 

f or  the 

q' 

). 

( e . g. 

l ed  to  i n e f f i c i e nt  programs. 

Thus  the  f a i l u re  to  recognize  m u l t i p l e - i n p ut 
operators  has 
It  has 
also  l ed  to  a  regrettable  lack  of  communication: 
techniques  which  have  been  designed  f or  handling 
m u l t i p l e - i n p ut  operators 
" s t r a t e g i e s"  f or  the  resolution  method)  have  not 
been  recognized  as  h e u r i s t ic  methods.  People  seem 
to  t h i nk  t h at  they  are  technical  d e t a i ls 
handling  r e s o l u t i o n,  whereas 
examples  of  quite  general  h e u r i s t ic  p r i n c i p l e s. 
One  can  make  a  p a r a l l e ll  with  the  "Edge"  h e u r i s t ic 
discussed  in  section  1:  general  p r i n c i p l es  have 
gone  unnoticed  f or  lack  of  abstract  concepts  to 
phrase  them  i n. 

in  f a ct  they  are 

the  various 

f or 

As  a  f i r st  step  to  remedy  t h is  s i t u a t i o n, 

l et 
us  introduce  separate  names  f or  the  various  kinds 
of  operators.  The  following  terms  are  believed  to 
be  i l l u s t r a t i v e: 

number  of  inputs 

number  of  outputs 

name 

one 
one 

m u l t i p le 
m u l t i p le 

one 

one 

m u l t i p le 

m u l t i p le 

perporator 
diporator 
conporator 
fociporator 

Our  second  step  is  to  introduce  a  formalism  and  a 
vocabulary  which  enables  us  to  deal  w i th  these 
d i f f e r e nt  kinds  of  operators.  The  formalism  is 
based  on  l a t t i ce  theory,  and  requires  a  section 
(section  5)  of  i ts  own. 

Our  t h i rd  step  w i ll  be  to  i l l u s t r a te  these 

general  concepts  and  p r i n c i p l es  by  r e - i n t e r p r e t i ng 
some  current  h e u r i s t ic  methods 
(including  the  u n it 
preference  strategy  in  r e s o l u t i o n ).  This 
in  sections  6  and  7. 

is  done 

Some  other  complications  which  may  occur  in 

the  basic  transformation  problem,are: 

Operators  w i th  or-connected  outputs. 

One  often  encounters  operators  which, 

l i ke 

i n t r i n s i c a l l y , " in  order 

d i p o r a t o r s,  y i e ld  a  set  of  objects  of  outputs,  but 
which  merely  require  that  one  of  the  outputs 
is  to 
be  transformed  to  the  target  set.  Such  o r-
connections  may  occur 
(a) 
prove 
(b)  because  the  operator  is  ambigous,  e.g. 
in 
r e s o l u t i on  l o g i c,  where  the  r e s o l u t i on  operator 
takes  two  clauses  as  input  and  gives  one  clause  as 
output.  Each  of  the  two  clauses  is  a  set  of 

a,  or  prove 

to  prove 

( in  a 

l i t e r a l s,  and  the  operator  " a n n i h i l a t e s" 
c e r t a in  sense) 
two  l i t e r a l s,  one  from  each  i n p u t. 
The  operator  has  one  output  f or  each  combination 
of  l i t e r a ls  in  the  two  i n p u t s,  and  is  therefore 
ambiguous. 
(c)  because  the  operator  requires  a  parameter, 
which  may  or  may  not  be  in  the  set  of  objects. 
For  example, 
predicate  calculus, 
and 
We  s h a ll  r e f er  to  a ll  operators  which  y i e ld  or-
oonnected  outputs,  as  ambiguous.  Thus  (a) 
exemplifies  an  ambigous  perporator,  (b)  an 
ambiguous  conporator,  and  (c)  an  ambiguous 
d i p o r a t o r. 

is  s u f f i c i e nt  to  prove  A 

in  order  to  prove  B 

it 
,  where  A 

is  a r b i t r a r y. 

in  conventional 

S t i ll  another  complication 

is 

Operators  w i th  r e s t r i c t ed  domain, 
which  is  a  proper  subset  of  the  set  P.  Some 
possible  ways  of  dealing  w i th  t h is  complication 
are  discussed  in  section  3. 

i . e.  a  domain 

Example: 
operator  is  not  always  applicable. 

In  i n t e g r a t i o n, 

the  p a r t i al  i n t e g r a t i on 

A  f i n al  complication  is 

No  back-up. 

In  t y p i c al  problem-solving,  application  of  an 

operator  is  never  i r r e v o c a b l e:  we  are  always 
permitted  to  back  up  in  the  s o l u t i on  tree  and  t ry 
some  other  operator  on  a  previously  used  object. 
In  some  s i t u a t i o ns 
( e . g.  the  Edinburgh  studies  of 
h e u r i s t ic  automata),  one  encounters  s i m i l ar 
problems  where  back-up  is  not  permitted.  The 
transformation  problem  the*  b o i ls  down  to  the 
problem  of  s e l e c t i ng  the  best  operator  in  each 
step. 

Sometimes,  e . g. 

in  planning,  a  back-up  problem 
can  be  transformed  to  a  no-back-up  problem,  or  vice 
versa.  We  therefore  consider  both  kinds  as  variants 
of  the  same  basic  problem. 

Summing  up,  transformation  problems  can  be 

characterized  by  a  couple  of  features, 
(1)  what  kinds  of  operators?  (per-,  con-,  d i -, 

i . e. 

f o c i - p o r a t o r s) 
are  operators  ambiguous? 
are  there  r e s t r i c t i o ns  to  the  domain  of 
operators? 
is  back-up  permitted? 

(2) 
(3) 

(4) 

3.  Approaches  to  h e u r i s t ic  search 

In  t h is  s e c t i o n,  we  s h a ll  attempt  to  c l a s s i fy 

and  name  some  methods  of  h e u r i s t ic  search.  Our 
c l a s s i f i c a t i on  w i ll  be  put  to  use  in  the  next  few 
sections,  where  some  previously  published  methods 
f or  h e u r i s t ic  search  are  reviewed. 

In  example  ( b ),  we  assume  forward  proof,  and 

in  (a)  and  (c)  backward  proof. 

- 2 0 1-

In  each  cycle  of  the  h e u r i s t ic  search  process, 
the  program  should  select  one  operator  to  use,  and 
one  object 
it  on. 
Object  s e l e c t i on  seems  to  be  performed  in  most 
cases  by  e i t h er  of  the  f o l l o w i ng  two  methods: 

( v i z.  set  of  objects) 

to  use 

(Al)  Labyrinthic  methods  proceed  doan  the  search 

t r e e,  and  have  an  e x p l i c it  mechanism  f or 
deciding  d i r e c t i on  in  the  t r e e .*  This 
mechanism  t e l ls  the  program  " t h is  is  a  good 
branch,  go  on  the  same  d i r e c t i o n ",  or  " t h is 
is  a  bad  branch,  back  up  —  steps  and  select 
another  branch". 

(A2)  Best  bud  methods  use  an  evaluation  function 

in  the  t r e e.  At  each 

which  assigns  a  p r i o r i ty  or  merit  to  each 
growth  d i r e c t i on  (bud) 
c y c l e,  the  program  takes  a  global  look  at 
a ll  the  buds,  selects  the  best  one,  sprouts 
i t,  and  i t e r a t es  the  cycle. 
the  best  bud  from  l a st  cycle  is  no  longer  a 
candidate,  but 
buds.  A ll  other  buds  from  l a st  cycle  are 
candidates  anew.  Back-up  occurs  automatically 
if  the  new  buds  are  unable  to  compete  w i th 
the  stand-by  buds 

it  has  yielded  several  new 

In  the  new  c y c l e, 

from  l a st  cycle. 

Methods  (Al)  and  (A2)  have  been  formulated 

it 

It 

is  sometimes  a 

is  easy  to  extend  them  to 

f or  perporators. 
d i p o r a t o r s.  For  conporators, 
good  idea  to  select  one  input  to  the  operator 
according  to  a  l a b y r i n t h ic  or  best-bud  method, 
and  then  to  select  "best  companions"  to  the 
selected  f i r st  i n p u t.  We  consider  t h is  the 
generalization  of  (Al)  and  (A2) 
operators.  A  t h i rd  method  cathegory  f or  them  would 
be 

to  m u l t i p l e - i n p ut 

(A3)  Best  bud  bundle  methods,  which  use  an 

evaluation  function  which  assigns  a  p r i o r i ty 
to  each  combination  ("bundle")  of  "buds", 
and  selects  the  best  one  in  each  step. 

GPS  and  SIN  use  l a b y r i n t h ic  methods,  whereas 
SAINT,  the  Graph  t r a v e r s e r,  MULTIPLE,  and  PPS  use 
best-bud  methods.  The  u n it  preference  h e u r i s t i cs 
(strategy) 
in  r e s o l u t i on  is  an  example  of  a  best 
bud  bundle  method. 

Another  (and  at 

least 

in  p r i n c i p l e, 

independent)  basis  of  c l a s s i f i c a t i on  is  how  the 
program  selects  the  operator  in;  each  cycle.  The 
f o l l o w i ng  methods  have  often  been  used  in  p r a c t i c e: 

(Bl)  Object(s) 

f i r s t,  one  operator  afterwards 
method;  F i r st  select  the  most  promising 
object(s) 
to  work  upon,  according  to  a 
l a b y r i n t h ic  or  best-bud  method.  After  t h a t, 
f i nd  a  good  operator  to  apply  to  it 
(them). 

(B2)  Exhaustive  method:  Select  object(s) 

( B l)  and  apply  a ll  operators  to  i t. 

l i ke  in 

(B3)  Object(s) 

f i r s t,  a  few  operators  afterwards 
method:  A  compromise  between  (Bl)  and  (B2): 

As  we  s h a ll  see  l a t e r,  we  sometimes  have  a 

l a t t i ce  rather  than  a  simple  t r e e. 

-202-

a  few  (but  not  a l l)  operators  are  selected 
and  applied  to  the  o b j e c t ( s ). 

(Bk)  Object  and  operator  together  method:  Consider 
a ll  possible  object-operator  combinations  and 
select  one  of  them,  using  a  p r i o r i ty  f u n c t i o n. 
(This 
in  other  words  a  best-bud  method, 
where  each  object-operator  combination  is 
considered  as  a  "bud".) 

is 

The  MULTIPLE  program  is  an  example  of  (B2), 
GPS  and  SAINT  are  examples  of  (B3),  whereas  u n it 
preference  and  PPS  are  examples  of  (B4).  The 
version  of  the  Graph  Traverser  described  in  {  Doran 
1966a} 
version  described  in  {Michie  1967a} 

is  an  example  of  (B2),  whereas  the  l a t er 

is  of  type 

( B l ). 

In  methods 

(B2)  and  (B3),  object  s e l e c t i on  in 

is  e f f e c t i v e ly  a  choice  of  operator  in 

one  cycle 
the  previous  cycle.  Therefore,  they  can  be 
considered  as  special  cases  of  ( B l ),  w i th  a  very 
careful  and  timeconsuming  method  f or  operator 
s e l e c t i o n. 

The  four  cases  above  are  c l e a r ly  not 

it 

is 

l a b y r i n t h ic 

in  p r i n c i p le  quite  possible 

exhaustive,  as 
to  run  an  operator  f i r s t,  object  afterward  method. 
Also, 
instead  of  best-bud  s e l e c t i on  of 
operators 
same  operator  u n t il  a  "back-up"  or  "change  operator" 
c r i t e r i on  is  s a t i s f i e d ).  However, 
these  p o s s i b i l i t i es 
are  probably  useless 

(one  would  keep  using  the 

f or  p r a c t i c al  problems. 

is  possible 

If  the  number  of  operators 

is  very  l a r g e,  or 

it 

then 

is  not  possible  to  search 
(B2)  and 

if  some  operators  are  ambiguous  w i th  a  large  number 
of  a l t e r n a t i v e s, 
through  a ll  possible  cases.  This  excludes 
(B4)  methods.  One  must  f i r st  select  the  proper 
o b j e c t ( s ),  and  then  use  a  f u n c t i on  which  selects 
one  or  a  few  operators  (and  ways  of  applying  them, 
if  ambiguous).  Usually, 
features 
determine  what  operators  may  be  s u i t a b l e. 

t h is 
in  the  given  o b j e c t, 

f u n c t i on  recognizes 
features  which 

In  many  p r a c t i c al  problem  environments,  one 
encounters  operators  which  are  only  defined  on  a 
subset  of  the  set  P  of  objects.  This  r e s t r i c t i on 
has  been  dealt  w i th  in  at  least  two  ways,  which 
provides  us  w i th  a  c l a s s i f i c a t i on  in  s t i ll  another 
dimension: 

(Cl)  Consider  as  f a i l u r e. 

If  we  have  h e u r i s t i c a l ly 

selected  an  object  and  an  operator,  and  it 
in  the  domain 
turns  out  t h at  the  object 
of  the  operator,  then  give  up  t h is  branch  and 
t ry  something  e l s e. 

is  not 

(C2)  Solve  sub-problem.  Let  Mr  be  the  domain  of  the 

operator.  Solve  the  transformation  problem 
from  the  given  object  to  M1,  and  apply  the 
given  operator  to  the  r e s u l t.  Formally,  we 
extend  the  d e f i n i t i on  of  our  operators,  so 
t h at  q(p)  ■  Q.(Pi)  >  vhere  p1 
(possibly  ambiguous I)  s o l u t i on  to 
formation  problem  from  p 
0.  • 

the  trans-
to  the  domain  of 

is  the 

SAINT  uses  a  type  (Cl)  method,  whereas  GPS  and 

PPS  use  type  (C2)  methods. 

In  conclusion,  we  have  pointed  out  three 

features 
in  h e u r i s t ic  methods.  These  features  can 
be  used  to  c l a s s i fy  and  characterize  the  methods. 
They  are: 
(A)  Mode  of  object  selection 
(B)  Mode  of  operator  selection 
(C)  Way  of  handling  r e s t r i c t ed  domains 

f or 

operators. 

k.  Some  frequent  techniques 

in  h e u r i s t i c s. 

In  t h is  s e c t i o n,  we  s h a ll  discuss  the  use  of 

"merit  orderings",  plans,  and  feature  vectors 
("images") 

in  h e u r i s t ic  methods. 

Use  of  merit  orderings. 

D e f i n i t i o n w i s e,  best-bud  methods  require  that 

In  a ll  best-bud-type  methods 

there  exists  a  way  of  selecting  the  "best"  one 
from  a  set  of  buds. 
known  to  the  author,  t h is  selection  is  based  on  an 
( e x p l i c it  or  i m p l i c i t)  p a r t i al  ordering  > 
on  the 
set  P  of  objects.  Some  maximal  bud  according  to  > 
( i . e.  some  bud  b 
s a t i s f i es 
and  is  sprouted. 

such  that  no  other  bud 
is  then  selected  as  "best  bud", 

In  some,  but  not  in  a ll  cases,  the  merit 

is  implemented  as  an  e x p l i c it  merit 
,  i . e.  a  mapping  from  P 

ordering  > 
assignment  function  e 
to  the  set  of  r e al  numbers. 
an  obvious  manner  through 

> 

is  then  defined  in 

The  problem  of  f i n d i ng  a  suitable  merit 

it  is  thought  about  as  an 

ordering  f or  a  given  problem  environment  is  of 
course  c r u c i a l.  Often, 
estimate  of  distance.  One  attempts  to  define  a 
f u n c t i on  d  ,  where 
of  the  work  (the  number  of  operator  applications) 
required  to 
one  attempts  to  compute 

i n t o.  S i m i l a r l y, 

transform 

is  a  rough  estimate 

f or  reasonable  sets  B 
then  defined  e.g.  as 

.  The  merit  function  e 

is 

The  use  of  merit  orderings 

is  not  r e s t r i c t ed 

to  best-bud  methods. 
c r i t e r i on  f or  abandoning  a  path  and  t r y i ng  another 
may  be  t h at 
The  GPS  u t i l i z es  exactly  t h is  h e u r i s t i c s. 

by  some  merit  ordering. 

In  l a b y r i n t h ic  methods, 

the 

is  n a t u r al  to  c a ll  a  h e u r i s t ic  method  g o a l-

The  name  "General  Problem  Solver"  has  some­
times  been  c r i t i c i z ed  as  being  too  uninformative. 
It 
d i r e c t ed 
function  is  defined  through 
D.  The  v a r i a nt  of  GPS  described  in  {Newell  196la} 
can  then  be  characterized  as  a  Goal-directed 
Perporator  Search  method. 

i ts  merit 

if 

At  f i r st  s i g h t,  the  idea  of  using  a  merit 
ordering  has  much  appeal.  On  closer  s c r u t i n y, 
turns  out  to  be  less  than  obvious. 
on  what  kind  of  economy  we  desire. 

it 
It  a ll  depends 

Suppose  we  are  solving  a  transformation 

problem  f or  perporators,  and  t h at  we  have  already 
searched  part  of  the  t r e e.  Then  which  of  the 
f o l l o w i ng  quantities  do  we  want  to  minimize  in  our 
next  step: 

(Dl)  The  number  of  steps 

( i . e.  operator  applications) 

in  the  " s o l u t i on  path"  from  the  i n i t i al  set  R 
to  the  target  set  M  ? 

(D2)  The  remaining  number  of  steps 

in  the  " s o l u t i on 
path"  from  the  selected  bud  to  a  member  of  the 
target  set  M  ? 

(D3)  The  (remaining)  number  of  steps, 

including 

steps  t h at  are  performed  in  b l i nd  alleys 
the  t o t al  number  of  arcs 
the  way  it  looks  when  we  have  reached  M)? 

( i . e. 
in  the  s o l u t i on  t r ee 

(DM  The  quantity  mentioned  in  (D3),  except  t h at 

trodden,  abandoned  through  back-

if  a  path  is 
up,  and  then  resumed,  the  steps  which  are 
trodden  several  times  s h a ll  be  counted  aB 
m u l t i p le  steps? 

If  the  path  to  the  s o l u t i on  of  the  transforma­

if  we  are  i n t e r e s t ed  in  a  member  of  M, 
if  we 

t i on  problem  is  to  be  used  as  a  plan  for  a  more 
expensive  a c t i v i ty  in  another  environment, 
then 
is  of  course  the  correct  c r i t e r i o n.  On  the 
(Dl) 
other  hand, 
rather  than  in  the  path  to  t h is  member 
are  searching  f or  a  s o l u t i on  to  an  i n t e g r a t i on 
problem),  then  (D3)  or  (D4)  would  be  the  correct 
quantity  to  minimize. 
(D3)  should  be  used  if  the 
e n t i re  search  t r ee  is  stored  in  memory,  and  (D4) 
should  be  used  if  the  search  t r ee 
i m p l i c i t ly  on  the  push-down-list,  so  that  abandoned 
paths  are  garbage-collected  and  a ll  work  there  has 
to  be  re-performed. 
s i t u a t i o n s, 

l i ke  Doran's  h e u r i s t ic  automaton. 

is  sound  in  no-back-up 

is  stored 

( e . g. 

(D2) 

If  c r i t e r i on  ( D l ), 

(D3),  or  (D4) 

is  to  be  used, 

then  the  " m e r i t"  of  a  bud  is  not  simply  a  function 
of  that  bud  and  the  t a r g et  s e t,  but  instead  a 
f u n c t i on  of  the  srhole  "stump"  of  the  solution  tree 
that  has  been  searched  up  to  now.  For  example, 
if 
is  used,  then  the  remaining 
the  c r i t e r i on  (D3) 
work  from  a  bud  is  affected  if  there  exists  some 
other  bud  which  has  almost  as  much  m e r i t,  and  which 
in  the  f u t u re  may  a t t r a ct 
a t t e n t i on 
idea  of  a  merit  ordering  is  sound  only  if  we  want 
to  use  c r i t e r i on 

f or  b l i n d - a l l ey  work. 

the  problem-solver's 

that  the 

follows 

(D2). 

It 

Although  t h e o r e t i c a l ly  shaky, 

If  c r i t e r ia  (D3)  or  {D4)  are  relevant 

the  use  of  merit 
orderings  seems  to  be  the  only  available  technique 
today. 
(which 
is  usually  the  case),  then  the  use  of  a  distance 
estimate  as  a  merit  function  is  even  more  question­
able.  We  s h a ll  t r e at  t h is  question  in  a  l a t er  paper. 
But  again,  the  distance  estimate  seems  to  be  the 
only  technique  we  have. 

-203-

Use  of  plans. 

Let  P,  1  Q,  R,  and  M  define  a  transformation 

problem  f or  which  a  s o l u t i on  is  known,  and  l et  P', 
Q'  =  Q,  R'  ,  and  M'  define  a  transformation  problem 
which  is  to  be  solved.  Assume  also  that  there 
e x i s ts  some  mapping  h  which  maps  P1  onto  P,  R' 
onto  R,  e t c. 
in  such  a  way  t h at  if  p  and  q(p) 
are  steps 
then 
h  maps  solutions 
we  can  c l e a r ly  f i nd  a  s o l u t i on  in  P'  by  j u st  r e­
t r a c i ng  the  s o l u t i on  in  P  *.  The  s o l u t i on  in  P 
w i ll  be  r e f e r r ed  to  as  a  plan  f or  the  s o l u t i on  in 
P'. 

in  the  known  s o l u t i o n,  and  if  p  =  h ( p ' ), 
the  f u n c t i on 
in  P.  Then 

In  other  words, 
in  P'  onto  solutions 

q(p)  =  h ( q ( p ' ) ). 

This 

i d e al  s i t u a t i on  probably  never  e x i s t s, 

is  the  i d e n t i ty  f u n c t i o n.  However, 

except  when  h 
q ( p ')  = 
it  may  be  the  case  t h at  the  requirement 
h(q(p)) 
often  (though  not  always)  holds.  Then  it 
can  s t i ll  be  a  good  strategy  to  t ry  to  f o l l ow  the 
p l a n. 
If  it  does  not  work,  we  have  to  take  resort 
in  another  p l a n,  or  in  the  object-operator 
s e l e c t i on  methods  mentioned  above, 
use  of  plans  may  be  considered  as  yet  another 
method, 

(B5),  of  operator  s e l e c t i o n ). 

( in  other  words, 

Plans  can  be  generated  in  several  ways,  e.g. 
by  memorization  of  previous,  successful  solutions 
(Doran's  h e u r i s t ic  automaton),  by  human  advice, 
or  by  "look-ahead":  s o l u t i on  of  an  analogous 
problem  in  an  a u x i l i a ry  problem  space  ( e . g. 
the  Planner  system  and  the  PPS). 

in 

When  the  problem  environment 

is  predicate 

c a l c u l u s,  the  " a b s t r a c t i on  f u n c t i o n"  h 
can  e.g. 
be  selected  so  as  to  throw  away  everything  except 
the  variables 
to  throw  away  everyting  except  the  boolean 
connectives 

(planning  GPS)  or 

in  the  formulas 

(Planner). 

A  t h i rd  technique  is 

Use  of  images. 

in  the  o b j e c t,  or  ( in  the  case  of  a 
the  t o p - l e v ei  s t r u c t u re  of 

By  an  image,  we  mean  an  item  which  expresses 
some,  but  not  a ll  the  information  of  an  object  in 
the  set  P.  The  image  may  be  f or  example,  a  vector 
of  features 
LISP-type  f o r m u l a ), 
the  o b j e c t,  w i th  lowerlevel  sub-expressions  being 
replaced  by  a s t e r i s k s.  Although  they  r a r e ly  t a lk 
about 
h e u r i s t ic  programs  do  in  f a ct  use  such  images. 
Images  are  used  f or  several  purposes, 
( l) 

i n c l u d i n g: 
functions  (a  numerical 

in  abstract  terms,  many  creators  of 

as  a  basis  f or  merit 
value  is  assigned  to  each  f e a t u r e,  and  merit 
is  computed  as  a  weighted  average  of  the 
feature  values)  or  distance  functions 
computed  as  a  wighted  average  of  d i s t a n c e" 

it 

To  insure  t h at  we  have  a  s o l u t i o n,  we  must 

assume  t h at  only  members  of  M'  are  mapped  i n to  M, 
i . e. 

n ( pf)  ( M o p'  £  M' 
it  is  e s s e n t i al  t h at  R1 

Moreover, 
is  mapped  onto 
(rather  than  i n t o)  R,  and  t h at  M'  is  mapped  onto 
M. 

(2) 

(3) 

between  f e a t u r e s ); 
as  objects  in  an  a u x i l i a ry  problem  space  used 
f or  planning; 
in  methods  of  type 
operators  t h at  should  be  applied  to  a  given 
o b j e c t. 

f or  the  s e l e c t i on  of 

(B3), 

( l)  game-playing  programs  and  (with 

Examples: 
c e r t a in  modifications)  Doran's  h e u r i s t ic  automaton; 
(2)  planning  GPS,  Planner,  PPS;  (3)  GPS. 

In  t h is  s e c t i o n,  we  have  described  and 
c l a s s i f i ed  general  h e u r i s t ic  techniques,  and 
given  references 
programs  which  u t i l i z es  i t. 
s h a ll  b u i ld  an  inverse  system  of  references.  Each 
section  w i ll  review  one  h e u r i s t ic  program  in  terms 
of  the  c l a s s i f i c a t i on  and  concepts  above. 

from  each  technique  to  actual 
In  sections  6-7,  we 

5.  L a t t i ce 

instead  of  t r e e s. 

Heuristic  search  is  often  r e f e r r ed  to  as  t r ee 
search.  However,  the  t r ee  model  is  only  applicable 
to  cases  where  a ll  operators  are  perporators  or 
(with  some  extra  conventions)  d i p o r a t o r s.  With 
conporators, 
a r i s e s. 
possible  way  of  performing  the  g e n e r a l i z a t i o n. 

In  t h is  s e c t i o n,  we  s h a ll  suggest  one 

the  need  for  a  more  general  s t r u c t u re 

Instead  of  a  s o l u t i on  t r e e,  we  s h a ll  introduce 

a  s o l u t i on  l a t t i c e.  For  perporators,  but  not  f or 
d i p o r a t o r s, 
i n to 
a  t r ee  as  usually  drawn.  -  For  a  good  i n t r o d u c t i on 
to  l a t t i ce  theory,  see  {Rutherford  1965a}. 

the  s o l u t i on  l a t t i ce  degenerates 

F i r st  some  general  n o t a t i o n.  Let  q  be  an 
unambiguous  operator  which  is  defined  w i th  one 
set  P1  C  P  as  i n p u t s,  and  which  y i e l ds  P"C  P 
as  outputs.  We  then  w r i te  P"  c  q(P') 
moment,  we  forget  about  ambiguous  operators. 

.  For  the 

The  ordered  k-tuple  whose  elements  are 

. ..  a,  w i ll  be  w r i t t en  < a1,  a2, 
is  a 

a  ,  a2, 
. ..  a.>. 
a  and  <  a>  are  considered  as  d i s t i n ct  items*. 
If  b 
is 
w r i t t en 
of  l a st  elements  of  members  of  B 

k - t u p l e,  the  l a st  element  of  b 

is  a  set  of  t u p l e s,  the  set 

is  w r i t t en 

. If  B 

a)(b) 

ft(B) 

. 

We  now  define  the  set  S 

(the  s o l u t i on  l a t t i c e) 

as  f o l l o w s: 
(1) 
(2) 

if  p 
if 
s 
and 
see  below. 

(3) 

is  an  o b j e c t,  then  <p> 
and 

are  members  of  S 

is  a  member  of  S; 
sv  t 

,  then 

t 

s  A  t  are  also  members  of  S; 

Following  Rutherford,  we  define 

to 
mean  x  ■  x  A  y  .  Also,  we  assume  commutative, 
a s s o c i a t i v e,  and  absorptive  laws  f or  VJ  and  o  . 
D i s t r i b u t i ve  and  idempotent  (  x 
laws  f or  ^  and 
t h at  the  C 

r e l a t i on  is  t r a n s i t i v e,  and  t h at 

f o l l ow  e a s i l y.  Also,  we  f i nd 

X  ■  x  e t c .) 

x cy 

r\ 

x  C  y  A  y  C  x 

x  =  y 

I n s t e a d,  we  s h a ll  f r e q u e n t ly  w r i te  a  when 

we  mean  {a}  • 

-204-

- 2 0 5-

i n f e r r ed  from  the  others,  and  is  c r u c i a l. 

Let  us 

f i n a l ly  t u rn  to  the  case  of  ambiguous 
in  example  2  ( f i g u re  5)  that 

is  an  ambiguous  perporator,  and  t h at 

operators.  Suppose, 
q 
s u f f i c i e nt 
transform  e i t h er 
set  M.  We  then  simply  redefine 
w i th  unchanged  notation  otherwise.  See  f i g u re  8,^ 
and  compare  f i g u re  5. 

to 

is 

it 

If  desired,  the  n o t a t i on  can  of  course  be 
f u r t h er  extended  to  a r b i t r a r i ly  complex  and/or 
s t r u c t u r e s: 

Example  4.  A f t er  applying  operator 
p 

,  we  f i nd  t h at 

is  s u f f i c i e nt  to  transform 

to  object 

q 

it 

to  the  target  set  M.  With 
simply  define 

s. 

as  before,  we  then 

Using  the  obvious  d i s t r i b u t i ve  e t c. 

laws, 
t h is  expression  can  be  reduced  to  the  canonical 
form  of  an  ambiguous  d i p o r a t o r. 

In  summary  of  t h is  s e c t i o n,  we  have  suggested 
a  formal  and  p i c t o r i al  representation  of  the  search 
" t r e e s" 
f or  a r b i t r a ry  operators.  Our  search  l a t t i ce 
S  is  the  set  of  a ll  possible  nodes 
in  search  space. 
In  the  search  f or  a  s o l u t i o n,  we  gradually  extend 
the  searched  poset,  which  is  a  subset  of  S,  u n t il 
it  has  been  proved  t h at 

6.  Heuristics 

in  the  SAINT  program 

In  sections  1-5,  some  aspects  of  h e u r i s t ic 
programs  have  been  discussed.  As  an  exercise  in 
the  use  of  these  concepts,  we  s h a ll  now  give  a 
d e s c r i p t i on  of  Slagle's  program  SAINT.  We  wish 
to  demonstrate  t h a t,  w i th  the  concepts  t h at  have 
been  introduced,  the  d e s c r i p t i on  can  be  more 
abstract  and  involve  less  programming  d e t a i ls 
than  before. 

Problem  environment. 

The  set  P  of  objects  consists  of  a ll  formulas 
from  r e al  numbers,  v a r i a b l e s,  various 
,  and  one  f u n c t i o n a l: 

b u i lt 
arithmetic  functions 
the 
i n t e g r a t i on  operator.  The  t a r g et  set  M  consists 
of  a ll  objects  which  do  not  use  the  i n t e g r a t i on 
operator.  The  i n i t i al  set  R  consists  of  one  single 
o b j e c t,  which  is  given  to  the  program  on  each 
occasion  of  use. 

f or  the  i n t e g r al  of  a  sum.  Some  of  the  perporators 
( e . g. 
the  s u b s t i t u t i on  operator)  are  ambiguous  and 
governed  by  a  parameter.  Most  operators  have  a 
r e s t r i c t ed  domain. 

Discussion  of  h e u r i s t ic  method. 

It 

is  n a t u r al  to  sort  up  the  operators 

f o l l o w i ng  d i s j o i nt  cathegories: 

i n to  the 

in  Q 

a.  Standard  forms  (26  operators).  These  are 
in  the 

perporators  whose  output 
target  set  M  ( if  the  input  contains  only  one 
occurrence  of  the  i n t e g r al  o p e r a t o r ).  An  example 
of  such  a  perporator 

is  always 

is 

the  p o s s i b i l i ty  to  single  out  those 

Remark: 
operators  which  land  in  the  t a r g et  set 
p a r t i c u l ar  f or  t h is  problem  environment,  and 
does  not  occur  in  e.g. 

l o g i c al  inference. 

is 

b.  A l g o r i t h m - l i ke  transformations 

(8  operators). 
These  are  operators  which, 
if  a p p l i c a b l e,  are 
usually  appropriate.  The  diporator  is  one  of 
them. 

c.  Heuristic  transformations 

(10  operators).  These 

are  operators  which  may  or  may  not  be  appropriate. 
S u b s t i t u t i on  is  one  of  them. 

Let  us  c a ll  these  sets  
and  define: 

a n d r e s p e c t i v e l y, 

PI  the  set  of  a ll  objects 

in  P  which  are  in  the 

domain  of  some  operator  in  Q l; 

P2  the  set  of  a ll  objects 

in  P-Pl  which  are  in  the 

domain  of  some  operator 

in 

Objects 

in  PI  have  a  s o l u t i on  j u st  around  the 
corner,  and  should  of  course  be  given  top  p r i o r i t y. 
For  objects  in  P2,  we  know  which  operator  should 
be  applied  ( it  turns  out  t h at  there 
is  never  more 
than  one),  so  such  objects  are  given  higher  p r i o r i ty 
than  objects 
operators  may  be  a p p l i c a b l e,  so  a  h e u r i s t ic  search 
has  to  be  performed. 

in  P3.  For  objects 

in  P3,  several 

Each  object  p 

stands 

f or  an  expression  b u i lt 

f or  the 

f o l l o w i ng  reasons: 

is  s i g n i f i c a nt 

the  members  of  PI  (usually)  have  small  maximum 

(2)  operators  often  perform  only  a  small 

w i th  f u n c t i o n s.  The  "maximum  depth"  of  t h is 
expression 
( l) 
depth; 
change  (one  or  a  few  u n i t s) 
of  t h e ir  i n p u t.  Under  such  conditions, 
reasonable  to  use  the  depth  of  an  expression  as  a 
i ts  "distance"  to  the  t a r g et  s e t, 
gross  measure  of 
and  (therefore  7) 
to  use  it  as  a  merit  f u n c t i o n. 

in  the  maximum  depth 

is 

it 

The  set  Q  consists  of  44  operators.  A ll  are 

perporators,  except 

f or  one  d i p o r a t o r,  the 

formula 

a d d i t i o n,  s u b t r a c t i o n,  m u l t i p l i c a t i o n,  power 
l o g a r i t h m i c,  t r i g o n o m e t r i c,  and  inverse 

f u n c t i o n, 
trigonometric 

f u n c t i o n s. 

With  t h is  background,  the  h e u r i s t ic  method 

used  by  SAINT  can  be  o u t l i n e d. 

-206-

Images. 

The  SAINT  program  uses  images  =  feature 

vectors  w i th  eleven  components.  Maximum  depth  of 
expression  is  one  of  them. 
three  purposes: 
(a) 

Images  are  used  f or 

s e l e c t i on  of  best  bud  (only  maximum  depth 
component  used); 
s e l e c t i on  of  appropriate  operators 
given  object 
selection  of  parameters 
operators. 

f or  ambiguous 

in  P3; 

(b) 

(c) 

f or  a 

Handling  of  r e s t r i c t ed  domain. 

h e u r i s t ic  search  need  only  span  objects  in  P3  and 
operators 

in  Q3. 

Like  most  h e u r i s t ic  programs,  SAINT  maintains 

i . e.  a  l i st  of  objects  to  which  no 

a  bud  l i s t, 
operator  has  yet  been  applied.  This  l i st  contains 
members  of  P3  ordered  according  to  (the  merit 
order)  > 

. 

Somewhat  i d e a l i z e d,  the  cycle  in  the  SAINT 

program  runs  as  f o l l o w s: 

(1)  Take  the  f i r st  object  on  the  bud  l i s t. 

is  a  maximum  bud  in  P3). 

(This 

If  a  selected  operator 

a  selected  o b j e c t,  SAINT  j u st  gives  up. 
not  t ry  to  solve  a  sub-problem. 

is  not  applicable  to 
It  does 

Object  and  operator  s e l e c t i o n. 

Abstractly  speaking,  the  SAINT  program  uses 

an  "object  f i r s t,  a  few  operators  afterwards" 
selection  system,  where  objects  are  selected  with 
a  best  bud  method  based  on  a  merit  ordering. 
However,  there  are  c e r t a in  complications  to  t h is 
simple  scheme. 

The  f o l l o w i ng  merit  ordering  is  used: 

i ff  p  is  a  member  of  PI  and  

is  not, 

or  p  is  a  member  o f a nd  

is  a 

member  of  P3, 

or  both  p  and  p'  are  members  of  P3,  but 

p  has  less  maximum  depth  than  p'  has. 

In  each  step,  SAINT  selects  some  maximal  bud 
in  the  search  tree  according  to  t h is  p a r t i al  order, 
and  applies  suitable  operators  to  i t.  The  operators 
are  selected  according  to  the  f o l l o w i ng  t a b l e: 

in  p a r t i c u l ar  that 

In  P2,  only  one  operator  is  usually  applicable; 
image  determines  which  operators 

in  P3,  the  o b j e c t 's 
s h a ll  be  selected.  Notice 
object  is  in  P2,  then  an  operator  from  Q3  is  never 
selected,  even  if  the  object 
in  i ts  domain.  The 
reason  is  that  an  object  in  P2  can  be  transformed 
one  or  more  steps  by  operators  in  Q2,  and  then  the 
desired  operator  in  Q3  can  be  applied  to  the  r e s u l t. 
This 
technique),  since  operators  in  Q2  only  e f f e ct 
t r i v i al  modifications  on  the  objects. 

in  f a ct  a  good  pruning 

is  s u f f i c i e nt 

(and  is 

is 

if 

Programming 

Since  only  one  operator  is  applied  to  objects 

in  PI  and  P2,  these  objects  and  operators  can  be 
given  a  separate  and  " a l g o r i t h m i c"  treatment.  The 

-207-

(2)  Select  suitable  operators 

f or  t h is  object. 

Apply  them.  The  set  or  results  is  called  P". 

(3)  For  each  member  of  P",  check  if  some  member 

of  Ql  or  Q2  is  applicable. 
If  it  was  a  member  of  Q l, 
wise, 
(3)  on  i t. 

include  the  r e s u lt  in  P"  and  reperform 

If  so,  apply  i t. 
terminate.  Other­

(k) 

Let  P+  be  the  modified  P"  a f t er  a ll  Ql  or  Q2 
operators  have  been  applied.  By  hypothesis, 
P+  is  a  subset  of  P3.  Merge  P+  i n to  the  bud 
l i st  according  to  > 

. 

The  cycling  s t a r ts 

in  step  3  w i th  the  bud 

l i st  empty,  and  w i th  P"  =  the  given, 
("the  given  i n t e g r a t i on  problem"). 

i n i t i al  object 

The  occurrence  of  a  diporator  in  the  problem 
environment  is  a  complication.  To  handle  t h i s,  the 
program  maintains  a  "goal  t r e e ",  which  is 
equivalent  to  the  search  poset  of  l a st  s e c t i o n, 
but  u t i l i z es  a  s l i g h t ly  d i f f e r e nt  n o t a t i o n.  On 
discovery  of  a  member  of  Ql  (step  (3) 
routine)  SAINT  does  not  a c t u a l ly  terminate,  but 
u t i l i z es 
from 
the  bud  l i st  those  buds  that  need  no  longer  be 
transformed  to  the 
target  s e t. 
if  SAINT  has  proved  f or  a  node 
poset  that 

In  l a t t i ce  terms, 
is  the  search 
from  the  bud 

instead  the  "goal  t r e e"  to  remove 

then  it  removes 

f | M _ t, 

in  the 

t 

t!

l i st  a ll  nodes  t1  such  t h at 
b  .  Also,  and 
f or  the  same  reason,  such  members  of  P"  (P  )  are 
thrown  away.  SAINT  then  continues  the  above  cycle 
( s t a r t i ng  in  step  ( l ))  as  long  as  there  is  anything 
l e ft  on  the  bud  l i s t. 
Remarks 

 

This  terminates  our  description  of  the  SAINT 
program. 
It  is  based  on  a  rather  short  summary  of 
the  work  on  SAINT,  { Slagle  1963a},  rather  than  the 
f u ll  t h e s i s.  There  may  therefore  be  mistakes  in 
d e t a i ls  of  our  d e s c r i p t i o n.  However, 
t h at  the  i n t e n t i on  with  t h is  section  was 
demonstrate  how  exactly  the  same  material  may  be 
described 
is 
to  be  used  f or  another  purpose. 

in  completely  d i f f e r e nt 

terms  when  it 

l et  us  repeat 

to 

To  f a c i l i t a te  comparison, 

l et  us  f i n a l ly  give 

a  short  d i c t i o n a ry  that  translates  between  Slagle's 
terminology  and  ours: 

it 

is  reasonable  to  take  the  image  of  an 

images, 
object  as  a  crude  estimate  of  i ts  merit 
search  towards  the  t a r g e t,  w i th  small  images  having 
a  higher  m e r i t.  Therefore,  operations  which  decrease 
the  image  can  be  expected  to  b r i ng  us  closer  to  a 
s o l u t i o n.  This  gives  us  a  preference  f or  f a c t o r i n g, 
and  f or  r e s o l u t i on  when  one  input  has  image  1. 

in  the 

A  t r i v i al  strategy  would  be  to  reduce  the 

image  to  zero  through  successive 
However,  we  run  i n to  problems  w i th  the  r e s t r i c t ed 
domains  of  the  operators: 
of  the 
p o s s i b l e,  and  in  a ll  reasonable  problems  we  would 
f a il 

f a c t o r i ng  when  the  image 

the  l a st  step) 

f a c t o r i n g s. 

f ar  before 

is  1  ( i . e. 

is  never 

input 

t h a t. 

Resolution  when  the  p a r t n e r 's 

image  is  1 

("unit  resolution")  seems  to  be  a  b e t t er  s t r a t e g y, 
adn  is  what  our  h e u r i s t i cs  prefers  as 
choice.  When  it  cannot  be  had,  we  perform  other 
resolutions  or 
hope  of  achieving  u n it  r e s o l u t i on 

f a c t o r i ng  a  couple  of  steps, 

l a t e r. 

f i r st 

in  the 

Handling  of  r e s t r i c t ed  domain. 

If  a  desired  operator 

is  not  a p p l i c a b l e, 

u n it  preference  method  j u st  gives  up. 

the 

Object  and  operator  s e l e c t i o n. 

Unit  preference  u t i l i z es  a  best  bud  bundle 

method,  where  a  suitable  operator  and  i ts  i n p u t ( s) 
are  selected  together.  The  system  makes  i m p l i c it 
use  of  a  merit  ordering  >  defined  as  follows  on 
I  ^  12 

: 

numerical 
r e l a t i o n s h ip 
(  <  means  "less  than") 

merit  ordering 
(  >  means  " b e t t er  than") 

T>  The  u n it  preference  h e u r i s t i cs 

in  r e s o l u t i on 

The  purpose  of  t h is  section  is  the  same  as 

i . e. 

t h at  of  section  6, 
to  demonstrate  the 
usefulness  of  abstract  h e u r i s t ic  concepts. 
a d d i t i o n,  we  s h a ll  t ry  to  show  t h at  the  so-called 
strategies  used  in  r e s o l u t i on  are 
h e u r i s t ic  methods,  and  amenable  to  the  same 
treatment  as  other  such  methods 
have  selected  to  make  a  description  of  the  u n it 
preference  strategy 

.  Therefore,  we 

f or  r e s o l u t i o n. 

in  f a ct 

In 

Problem  environment 

Each  object  in  the  set  P  is  a  set  of  l i t e r a l s, 

)) 

or 

a  l i t e r al  being  a  symbolic  expression 
(NOT  (Ri 
t a r g et  set  M  has  one  member:  the  n u ll  set  ( i . e. 
the  set  of  no  l i t e r a l s ).  The  i n i t i al  set  R 
consists  of  a  r e l a t i v e ly  small  number  of  objects 
and  is  given  to  the  program  on  each  occasion  of 
i ts  use. 

.  The 

(% 

) 

Notice  that  in  t h is  case,  R  is  given  as 

input 

to  the  program,  and  M  is  f i x e d. 
SAINT,  ve  had  the  opposite  s i t u a t i o n. 

In  the  case  of 

The  set  Q  consists  of  a  two-input  conporator 

( " r e s o l u t i o n ")  and  a  perporator  ( " f a c t o r i n g " ). 
Both  have  a  r e s t r i c t ed  domain,  and  both  are 
ambiguous.  The  ambiguities  are  moderate:  the 
number  of  a l t e r n a t i v es 
f i n i te  and  so  small 
t h at  a ll  can  be  t r i e d. 

is 

Images 

Unit  preference  uses 

images 

f or  o b j e c t-

the  number  of 

operator  s e l e c t i o n.  The  image  of  an  object  is  an 
l i t e r a ls 
i n t e g e r,  v i z. 
Operators  can  be  extended  to  images 
f o l l o w i ng  manner: 
operator  have  images 
( if 
the  input  to  the  f a c t o r i ng  operator  has 
then  the  output, 
j -1 
image**. 

inputs 
to  the  r e s o l u t i on 
and  k.  ,  then  the  output 

.  S i m i l a r l y, 
image 
as 

in  the  o b j e c t. 
in  the 

if  it  e x i s t s,  has 

it  e x i s t s)  has 

if  the 

image 

if 

Discussion  of  h e u r i s t ic  method. 

Since  the  t a r g et  object  has  image  zero,  and 
the  operators  e f f e ct  a  r e l a t i v e ly  small  change  on 

Feigenbaum, 

in  his  IFIP  68  paper  {  Feigenbaum 

1968a},  argues  a  s i m i l ar  standpoint. 
** 

It  may  a c c i d e n t a l ly  happen  t h at  the  image  of 

is  less 

than  (but  never  greater  than) 
.  Such  accidents  are  rare  and  do 

the  output 
j+k-2 
v i z. 
not  a f f e ct 

the  h e u r i s t i c s. 

The  r e l a t i on  > 
obvious  way. 

is  extended  to  P w  P 

in  the 

-208-

to 

to  i t. 

the  correct  operator  ( f a c t o r i ng 

In  each  c y c l e,  u n it  preference  uses 

> 
select  one  maximal  object  or  o b j e c t - p a ir  and 
applies 
in  the 
case  of  an  o b j e c t,  resolution  in  the  case  of  an 
o b j e c t - p a i r) 
a l t e r n a t i v es  are  treated  with  the  same  p r i o r i t y. 
If  operator  a p p l i c a t i on 
is 
successful,  and  the  output  has  higher  p r i o r i ty 
than  the 
(and  t h e r e f o r e,  higher  p r i o r i ty 
than  the  other  a l t e r n a t i v es  processed  together 
w i th  t h is  one), 
honored 

In  case  of  ambiguity,  a ll 

then 
immediately. 

in  some  a l t e r n a t i ve 

the  higher  p r i o r i ty 

input 

is 

Programming. 

Although  our  reference  says 

l i t t le  about  the 
actual  program  that  performs  the  unit  preference 
h e u r i s t i c s,  the  following  are  some  suggestions 
f or  such  a  program. 

The  program  u t i l i z es  l i s ts  L 
,  where  L. 

. ..  L., 
contains  a ll  generated  objects 

,  LQ, 

together  with  the 

j, 
f or  each  object: 

following 

. .. 
w i th  image 
information 

determine  a p p l i c a b i l i t y.  This  "semi-deterministic" 
property  has  otherwise  been  c h a r a c t e r i s t ic  of 
planning  methods,  notably  planning  GPS,  and  PLANNER. 
As  a  r e s u lt  of  some  present  work,  we  believe  that 
semi-deterministic 
p r o p e r t i e s. 

i n t e r e s t i ng  t h e o r e t ic 

images  have 

Pruning  c r i t e r i a. 

The  unit  preference  h e u r i s t i cs  should  only  be 
used  in  combination  w i th  various  pruning  c r i t e r i a, 
such  as: 

(1)  Restriction_on_.-Search  Pth'  Tne  depth  of  an 
is  the  number  of  resolutions  that  was 

object 
required  to  construct 
>_  K( 
r e j e c t e d; 

(where  kQ 

i t.  Objects  of  depth 

is  a  fixed  parameter)  are 

(2)  Set  _of  sjijyoort  strategy..  A  subset  T  of  R  is 
singled  out  as  " e s s e n t i al  i n i t i al  o b j e c t s ", 
and  nodes  p  in  the  search  poset  which  s a t i s fy 

p «= U( I~¥) 

has  f a c t o r i ng  been  attempted  on  t h is  object? 

are  given  zero  m e r i t; 

(3)  Rejection:1  by  Pattern..  Objects  p  which  conform 
to  c e r t a in  patterns  ( e . g.  contain  two  l i t e r a ls 
of  the  form  A  v i z.  (NOT  A)  )  are  r e j e c t e d. 

We  have  then  made  a  d i s t i n c t i on  between 

rules  which  govern  the  order  in 

h e u r i s t i cs  ( i . e. 
which  the  s o l u t i on  l a t t i ce  is  searched)  and 
pruning  c r i t e r ia  (which  are  extreme  cases  of 
h e u r i s t ic  rules  since  they  cut  o ff  some  "branches" 
a l t o g e t h e r ). 
h e u r i s t i cs  and  pruning  c r i t e r ia  are  called 
s t r a t e g i e s. 

In  the  r e s o l u t i on 

l i t e r a t u r e,  both 

Pruning  c r i t e r ia  can  formally  be  treated  as  4 

f i r st  two  pruning  c r i t e r ia  above  can 

f u r t h er  r e s t r i c t i on  on  the  domains  of  operators. 
The 
( a l t e r n a t i v e l y)  be  implemented  by  using  images 
<.j,d,s> 

,  defined  as  f o l l o w s: 

If  p 

image  is 

p's 

is  a  member  of  the  i n i t i al  set  R 

, 

^ j , d , s> 

,  where 

j 
d 
s 

is  the  number  of  l i t e r a ls  in  p 
is  zero; 
is  the  t r u t h - v a l ue  of  p  £  T 

; 

If 

p  was  derived  through  r e s o l u t i o n,  and 

the  images  of  the  inputs  were  <  Ji 
<J2 
»  then  the' image  of  p 
where 

d2 

and 
d1s1 
is  <j,d,s> 

, 

j  =  j 

+  j 

-  2 

(the  number  of  l i t e r a ls  in  p) 

d  =  max(d.,dp)  +  1 

F i n a l l y, 

and  the  image  of  the  input  was  < j , d , s> 

if  p  was  derived  through  f a c t o r i n g, 
,  then  the 

-209-

(1) 

(2) 

if 
has 

f a c t o r i ng 

is  ambiguous, 

for  which  cases 

it  been  attempted? 

(3)  w i th  what  other  objects  has  r e s o l u t i on  been 

attempted? 

(U) 

if  r e s o l u t i on  is  ambiguous, 
has 

it  been  attempted? 

for  which  cases 

The  answers  to  these  questions  can  be 

represented  as  f o l l o w s: 

(1) 

(2) 

f or  each  l i st  L-  where 
indicate  how  far  down  the  l i st 
proceeded; 

j  ^  2,  a  pointer 

f a c t o r i ng  has 

f or  the  pointed-at  element  of  each 
the  attempted  alternatives  are 
(For  a ll  other  alternatives  of 
none  or  a ll  a l t e r n a t i v es  have  been  attempted); 

l i s t e d. 
L j,  e i t h er 

l i st  L-, 

and  s i m i l a r l y, 

f or  each  object  p. 

on  each  l i st 

(3) 

{h) 

f or  each  l i st  L 
indicates  how 
p. 

has  been  attempted; 

where  k  _<  j ,  a  pointer 
far  down  Lk  r e s o l u t i on  w i th 

f or  the  pointed-at  element  of  each  l i st  Lk, 
the  attempted  a l t e r n a t i v es  are  l i s t e d. 

With  these  conventions,  programming  is  s t r a i g h t-
forward. 

Remark. 

The  images  used  by  the  unit  preference  method 
the  image  of  the  output 
image(s)  of  the 

have  a  noteworthy  property: 
of  an  operator  is  a  function  of  the 
i n p u t ( s ), 
is  applicable;  but 
image  does  not  contain  enough  information  to 

if  the  operator 

the 

image  of  t he  o u t p ut 

is 

Graph 
{Doran  1 9 6 6 a }, 

t r a v e r s er 

{Doran  1 9 6 7 a }, 

{ M i c h ie  1967a} 

When 

t he  p a r t i al  o r d er 

> 

is  e x t e n d ed  to 

t r i p l es 
f o l l o w i ng 
<  a ll  o t h er 

and  p a i rs  of  such 

t r i p l e s, 

t he 

i t e ms  a re  c o n s i d e r ed  as  zeroes 

( i . e. 

i t e m s)  and 

t h e r e f o re 

r e j e c t e d: 

W i th 

t h e se  e x c e p t i o n s, 

t he  o r d er 

> 

t r e a ts 

N o t i ce 
in 

t h at 
t he 

if  we 
t he  a c c i d e n ts 
f o o t n o te  on  page  2 8,  b o th 

i g n o re 

m e n t i o n ed 
o p e r a t o rs  a re  s e m i - d e t e r m i n i s t ic  on 
i m a g e s. 

t h e se  e x t e n d ed 

M o d i f i c a t i o n: 
h e u r i s t i c s. 

t he 

f e w e s t - c o m p o n e nt  p r e f e r e n ce 

S l a g le  has  p r o p o s ed 

to  s t r e a m l i ne 

t he  u n it 

i n to  a 
i d ea 

t he  m e r it  o r d er  so 

p r e f e r e n ce  h e u r i s t i cs 
p r e f e r e n ce  m e t h o d.  The 
d e f i n i t i on  of 
s p e c i al  p r e f e r e n ce 
The  d e t a i ls  a r e: 
in 
d r op  r u l es 
t h r o u gh 
o n e.  For  t he  r e d e f i n ed 

( 6)  even 

t h r o u gh 

( l) 

fewest-component 
is 

to  change 
t he 
is  d r o p p e d. 
, 

t h at 

t he 

( l 1 j) 

f or  p a i rs 
t he  above  d e f i n i t i on  of  > 
( 4) 

( 3 ),  and  use  r u l es 
or  m 
,  we  have  e . g. 

i , j ,k 

> 

if  some  of 

e q u a ls 

H e u r i s t ic  automaton 
{Doran  1968a} 

L o g ic 
{ S t e f f e r ud  1 9 6 3 a }, 

t h e o ry  machine 

{ M i l l s t e in  ?a} 

MULTIPLE 
{ S l a g le  1968a} 

P l a n n er 
{ H e w i tt  1967a} 

P l a n n i ng  GPS 
{ N e w e ll  1 9 6 0 c }, 

{ N e w e ll  1964a} 

( P l a n n i ng  Problem  S o l v e r) 

PPS 
{ S a n d e w a ll  1968b} 

SAINT 
{ S l a g le  1963a} 

SIN 
{Moses  1967a) 

U n it  p r e f e r e n ce  h e u r i s t i cs 
{Wos  1964a} 

R e f e r e n c es 

Comm  Processes  1963 

Communication  Processes 
P r o c e e d i n gs  of  a  symposium  h e ld 
1963 
Pergamon  Press  196U 

in  W a s h i n g t o n, 

8.  C o n c l u s i on 

We  have  d e f i n ed  a  number  of  c o n c e p ts  w h i ch 

to 

f or 

i l l u s t r a t i o n, 

t he  compact  and  a b s t r a ct  d e f i n i t i on 

t h e se 
t wo  w e l l - k n o wn 
t h e ir  compactness  can  be 

are  u s e f ul 
or  h e u r i s t ic  m e t h o d s.  F or 
c o n c e p ts  have  been  a p p l i ed 
m e t h o d s.  Examples  of 
f o u nd  on  pages  9 
11 
component  p r e f e r e n ce  h e u r i s t i c s ).  We  have  a r g u ed 
t h at  a b s t r a ct  d e s c r i p t i o ns  of  s i m i l ar  k i nd  w i ll 
be  u s e f ul  as  complements 
d e s c r i p t i o ns  of  h e u r i s t ic  programs  and  m e t h o d s. 

( s et  of  s u p p o rt  s t r a t e g y)  and  12 

( S l a g l e 's  AND/OR 

to  c o n v e n t i o n al 

t r ee  p r u n i n g ), 

( f e w e s t-

I n d ex  of  h e u r i s t ic  methods  and  p r o g r a m s. 

A r r ow  method 
{ H a rt  1 9 6 7 a }, 

DEDUCOM 
{ S l a g le  1965a} 

{ N i l s s on  1968a} 

Fewest-component  p r e f e r e n ce  h e u r i s t ic 
{ S l a g le  1965b} 

( G e n e r al  P r o b l em  S o l v e r) 

GPS 
{ N e w e ll  1 9 6 0 c }, 

{ N e w e ll  1 9 6 l a} 

- 2 1 0-

Doran  1966a 

J  E  D o r a n,  D  M i c h ie 
E x p e r i m e n ts  w i th 
Proc  R  Soc. 
(A)  

p. 

t he  g r a ph 

t r a v e r s er  program 

Doran  1967a 

J  E  Doran 
An  approach 
in 

{Mach 

I nt  1 }, 

to  a u t o m a t ic  p r o b l e m - s o l v i ng 

Doran  1968a 

f o rm  of  g o al  s e l e c t i on  and  achievement 

J  E  Doran 
A 
h e u r i s t ic  automaton 
U n iv  of  E d i n b u r g h,  D e p t.  of  Machine 
and  P e r c e p t i o n,  memo  MIP-R-34 

in  a 

I n t e l l i g e n ce 

Feigenbaum  1963a 

E  F  Feigenbaum,  J  Feldman 
Computers  and 
M c G r a t - H i l l,  1963 

t h o u g ht 

H a rt  1967a 

f o r m al  b a s is 

P  E  H a r t,  N  J  N i l s s o n,  B  Raphael 
A 
of  minimum  c o st  p a t hs 
S t a n f o rd  Research 
June  1967 

f or 

t he  h e u r i s t ic  d e t e r m i n a t i on 

I n s t i t u t e,  Menlo  P a r k,  C a l ., 

Samuel  1967a 
A  L  Samuel 
Some  studies 
of  checkers 
Stanford  A . I.  Project,  memo  52 

II  -  Recent  progress 

in  machine  learning  using  the  game 

Sandewall  1968b 

E  J  Sandewall 
A  planning  problem  solver  based  on  look-ahead 
in  stochastic  game-trees 
Uppsala  univ.  Comp.  S c i.  Dept.,  Report  13, 
A p r il  1968 

Slagle  1963a 
J  R  Slagle 
A  h e u r i s t ic  program  that  solves  symbolic 
i n t e g r a t i on  problems 
in  freshman  calculus 
in  Comm  ACM  _b,  Oct.  1963  _or  {Feigenbaum  1963a} 

Slagle  1965a 
J  R  Slagle 
Experiments  w i th  a  deductive  question-answering 
program 
i\n  Coram  ACM  8_,  Pec.  1965,  p.  792 

Slagle  1965b 
J  R  Slagle 
A  proposed  preference  strategy  using  s u f f i c i e n c y-
r e s o l u t i on 
Lawrence Rad Labs, memo UCRL-14361e 1968a 

f or  answering  questions 

J  R  Slagle,  P  H  Bursky 
Experiments  with  a  multi-purpose,  theorem-
proving  h e u r i s t ic  program 
in  Journ  ACM  I_5,  Jan.  1968 

Stefferud  1963a 
E  Stefferud 
The  logic  theory  machine  -  a  model  h e u r i s t ic 
program 
Rand,  memo  RM-3731-CC,  June  1963 

Wos  1964a 

L  Wos,  I)  Carson,  G  Robinson 
The  unit  preference  strategy 
in  Proc.  FJCC,  1964  p.  6l5 

in  theorem  proving 

Hewitt  1967a 
C  Hewitt 
Planner,  a  language  for  proving  theorems 
MIT/MAC  A  I  Group,  memo  137,  July  1967 

1F1P  1959 

Proceedings  of  an  i n t e r n a t i o n al  conference  on 
information  processing 
UNESCO  House,  Paris  1959 

Mach  I nt  1 

N  L  C o l l i n s,  D  Michie,  eds. 
Machine 
Oliver  &  Boyd,  London  1967 

i n t e l l i g e n ce  1 

Mach  I nt  2 

E  Dale,  D  Michie,  eds. 
Machine  i n t e l l i g e n ce  2 
Oliver  &  Boyd,  London  1968 

Michie  1967a 
D  Michie 
Strategy-building  with  the  graph 
in  {Mach  I nt  1} 

traverser 

M i l l s t e in  QA 

M i l l s t e in  R 
The 
Lawrence  Rad  Labs,  memo  UCRL-70037 

l o g ic  t h e o r i st 

in  LISP 

Moses  1967a 
J  Moses 
Symbolic 
MIT  Math  Dept,  Ph  D  Thesis,  September  1967 

i n t e g r a t i on 

Newell  1960c 

A  Newell  et  til 
Report  on  a  general  problem  solving  program 
for  a  computer  information  processing  system 
_in  { I F ir  3 959),  p.  256 

Newell  1961a 

A  Newell,  H  Simon 
GPS,  a  program  that  simulates  human  thought 
in 

IFeigenbaum  19b3a) 

Newell  1961+a 

A  Newell 
The  p o s s i b i l i ty  of  planning  languages 
computer  communication 
in 

tComin  Processes  1963) 

in  man-

Nilsson  1968a 
N  J  Nilsson 
Searching  problem-solving  and  game-playing 
trees 
in.  {IFIP  1968} 

f or  minimal  cost  solutions 

Rutherford  1965a 

D  E  Rutherford 
I n t r o d u c t i on 
to 
Oliver  &  Boyd,  1965 

l a t t i ce  theory 

Samuel  1959a 
A  L  Samuel 
Some  studies 
of  checkers 
in  {Feigenbaum  1963a} 

in  machine  learning  using  the  game 

- 2 1 6-

