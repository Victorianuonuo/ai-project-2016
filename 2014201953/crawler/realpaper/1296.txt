Session  8  Formalisms  for 
A r t i f i c i al 

Intelligence 

A  MODEL  FOR  CONTROL  STRUCTURES 

FOR  ARTIFICIAL  INTELLIGENCE  PROGRAMMING  LANGUAGES 

by 

Daniel  G.  Bobrow 

Computer  Science  Division 

Xerox  Palo  Alto  Research  Center 

Palo  Alto,  California  94304 

Ben  Wegbreit 

Harvard  University 

Center  for  Research  in  Computing  Technology 

Cambridge,  Massachusetts  02138 

Abstract 

Newer  programming  languages  for  artificial  intel(cid:173)
ligence  extend  the  class  of  available  control  regimes 
beyond  simple  hierarchical  control.  In  so  doing,  a  key 
issue  is  using  a  model  that  clearly  exhibits the  relation 
between  modules,  processes,  access  environments, 
and  control  environments. 
This  paper  presents  a 
model  which  is  applicable  to  diverse  languages  and 
presents  a  set  of  control  primitives  which  provide  a 
concise  basis  on  which  one  can  define  almost  all  known 
regimes  of  control. 

1. 

Introduction 

In  this  paper,  we  present  an 

Newer  programming  languages!  for  artificial 
intelligence  ( e . g .,  PLANNER9^  CONNIVER,18  BBN-
LlSP.ly  QA4.1' 1  extend  the  nature  of  control  regimes 
available  to  the  user. 
information  structure  model20  which  deals  with control 
and  access  contexts  in  a  programming  language;  it  is 
based  on  consideration  of the  form  of  run-time  data 
structures  which  represent  program  control  and  v a r i(cid:173)
able  bindings.  The  model  is  designed  to  help  clarify 
some  relationships  of hierarchical  function  calls, 
backtracking,  co-routines,  and  multiprocess  structure. 
We  present  the  model  and  its  small  set  of  primitive 
operations,  then  define  several  control  regimes  in 
terms  of the  primitives,  and  then  consider  extensions 
to  handle  cooperating  sequential  processes. 

2.  The  Basic  Environment  Structure 

In  a  language  which  has  blocks  and  procedures, 

new  nomenclature  (named  variables)  can  be  introduced 
either  by  declarations  in  block  heads  or  through  named 
parameters  to  procedures.  Since  both  define  access 
environments,  we  call  the  body  of  a  procedure  or block 
a  uniform  access  module.  Upon  entry to  an  access 
module,  certain  storage  is  allocated  for  those  new 
named  items  which  are  defined  at  entry.  We  call  this 
named  allocated  storage  the  basic  frame  of the  module. 
In  addition,  certain  additional  storage  for  the  module 
may be  required  for  temporary  intermediate  results  of 
computation;  this  additional  allocated  storage  we  call 
the  frame  extension.  The  total  storage  is  called  the 
total  frame  for  the  module,  or  usually  just  the  module 
frame. 

A"  frame  contains  other  information,  in addition to 
named  variables  and  temporaries. 
It  is  often  useful  to 
reference  a  frame  by  symbolic  nomenclature.  For  this 
purpose,  each  frame  has  a  framename  (usually  the  pro(cid:173)
cedure  name).  When  a  module  is  entered,  its  frame 
extension  is  initialized  with  two  pointers  (perhaps  i m(cid:173)
plicitly);  one,  called  A  LINK,  is  a  linked  access 
pointer  to  the  frame(s)  which  contains  the  higher  level 
free  variable  and  parameter  bindings  accessible  within 

246 

this  module.  The  other,  called  CLINK,  is  associated 
with  control  and  is  a  generalized  return  which  points to 
the  calling  frame. 
In  Algol,  these  are  called  the static 
and  dynamic  links,  respectively. 
pointers  usually  reference  the  same  frame,  since  bind(cid:173)
ings  for  variables  free  in  a  module  are  found  by 
tracing up  the  call  structure  chain. 
the  use  of functional  arguments,  and  we  illustrate  that 
below.) 

In  L I S pH  the  two 

(An  exception  is 

At  the  time  of  a  call  (entry  to  a  lower  module),  the 

caller  stores  in  his  frame  extension  a  continuation 
point  for  the  computation.  Since  the  continuation  point 
is  stored  in  the  caller,  the  generalized  return  is 
simply  a  pointer  to  the  last  active  frame. 

The  size  of  a  basic  frame  is  fixed  on  module entry. 

It  is  just  large  enough  to  store  the  parameters  and 
associated  information.  However,  during  one  function 
activation,  the  required  size  of  the  frame  extension 
can  vary  widely  (with  a  computable  maximum),  since 
the  amount  of temporary  storage  used  by  this  module 
before  calling  different  lower  modules  is  quite  v a r i(cid:173)
able.  Therefore,  the  allocation  of these  two  frame 
segments  may  sometimes  (advantageously)  be  done 
separately  and  n  on  contiguously.  This  requires  a  link 
(BLINK)  from  the  frame  extension  to  the  basic  frame 
which  contains  the  bindings. 

When  a  frame  is  exited,  either by  a  normal  exit 

or by  a  non-local  goto which  skips  the  frame  (e. g.  , an 
error  condition),  it  is  often  useful  to  perform  clean-up 
action  for  the  frame.  Examples  include:  close  files 
opened  by  the  frame  which  are  no  longer  needed, 
restore  the  state  of more  global  structures  which  have 
been  temporarily  modified  by  the  frame,  etc.  T e r m i(cid:173)
nal  action  for  a  frame  is  carried  out  by  executing  an 
exit  function  for  the  frame,  passing  it  as  argument  the 
nominal  value  which  the  frame  is  returning  as  its 
result;  the  value  returned  by  the  exit  function  is  the 
actual  value  of  the  frame.  The  variable  values  and  the 
exit  function  are  the  only  components  of the  frame 
which  can be  updated by the  user;  all  the  others  are 
fixed  at  the  time  of frame  allocation.  Figure  1  sum(cid:173)
marizes  the  contents  of the  frame. 

Figure  2a  shows  a  sketch  of an  algorithm  pro(cid:173)

grammed  in  a  block  structure  language  such  as  Algol 
60  with  contourslO  drawn  around  access  modules.  Bl 
has  locals  N  and  P,  P  has  parameter N,  and  B3  locals 
Q  and  L.  Figure  2b  is  a  snapshot  of the  environment 
structure  after  the  following  sequence:  Bl  is  entered; 
P  is  called  (just  above  P I,  the  program  continuation 
point  after  this  outer  call);  B3  is  entered;  and  F  is 
called  from  within  B3.  For  each  access  module  there 
are  two  separate  segments  —  one  for  the  basic  frame 
(denoted  by  the  module  name)  and  one  for  the  frame 
extension  (denoted  by  the  module  name*).  Note  that 
the  sequence  of access  links  (shown  with  dotted  lines) 
goes  directly  from  P  to  B l*  and  is  different  from  the 
control  chain  of  calls.  However,  each  points  higher 

( e a r l i e r)  on  the  stack. 

A  point  to  note  about  an  access  module  is  that  it 
If  an  a p p r o(cid:173)

has  no  knowledge  of  any  module  below  i t. 
priate  value  ( i . e .,  one  whose  type  agrees  w i th  the 
stored  r e t u rn  type)  is  provided,  continuation 
in  that 
access  module  can  be  achieved  w i th  only  a  pointer  to 
the  continued  f r a m e.  No  i n f o r m a t i on  stored  outside 
this  f r a me  is  necessary. 

F i g u re  3  shows  two  examples  in  which  m o re  than 
one  independent  environment  s t r u c t u re  is  maintained. 
In  F i g u re  3a,  two  coroutines  are  shown  which  share 
common  access  and  control  environment  A.  Note  that 
the  f r a me  extension  of  A  has  been  copied  so  that 
r e t u r ns  f r om  B  and  Q  may  go  to  different  continuation 
points.  This  is  a  key  point  in  the  model;  whenever  a 
f r a me  extension  is  r e q u i r ed  f or  conflicting  purposes, 
a  copy  is  made.  Since  f r a me  A  is  used  by  two  p r o(cid:173)
cesses, 
if  either  coroutine  were  deleted,  the  basic 
f r a me  f or  A  should  not  be  deleted.  However,  one 
f r a me  extension  A*  could  be  deleted  in  that  case, since 
f r a me  extensions  are  never  referenced  d i r e c t ly  by 
m o re  than  one  process.  Since  the  basic  f r a me  A 
is 
s h a r e d,  either  process  can  update  the  variable  b i n d(cid:173)
ings  in  i t;  such  changes  are  seen  both  by  B  and  Q, 
In 
F i g u re  3b,  coroutine  Q  is  shown  calling  a  function  D 
w i th  external  access  chain  through  B,  but  with  control 
to  r e t u rn  to  Q. 

3.  P r i m i t i ve  Functions 

In  this  model  for  access  module  activation,  each 
f r a me  is  generally  released  upon  exit  of  that  module. 
Only  if  a  f r a me  is  s t i ll  referenced  is  it  retained.  A ll 
non-chained  references  to  a  f r a me  (and  to  the  e n v i r o n(cid:173)
ment  s t r u c t u re  it  heads)  are  made  through  a  special 
protected  data  type  called  an  environment  d e s c r i p t o r, 
abbreviated  ed.  The  heads  of  a ll  environment  chains 
are  referenced  only  f r om  this  space  of  d e s c r i p t o r s. 
(The  one  exception  is  the  i m p l i c it  ed  f or  the  c u r r e n t ly 
active  process.)  The  p r i m i t i ve  functions  create  an  ed 
f or  a  specified  f r a me  and  update  the  contents  of  an  ed; 
create  a  new  f r a me  w i th  specified  contents,  and  allow 
execution  of  a  computation  in  that  context;  and  access 
and  update  the  exit  function  f or  a  f r a m e.  Note  that 
none  of  the  p r i m i t i v es  manipulate  the  links  of  existing 
f r a m e s; 
exist  ( i . e .,  no  r i ng  s t r u c t u r e s ). 
1)  environ(pos)  —  creates  an  environment  d e s c r i p t or 

t h e r e f o r e,  only  w e l l - f o r m ed  f r a me  chains 

f or  the  f r a me  specified  by  pos. 

2)  setenv(olded,  pos)  --  changes  the  contents  of  an 
existing  environment  d e s c r i p t or  olded  to  point  to 
the  f r a me  specified  by  pos.  As  a  side  effect,  it 
releases  storage  referenced  only  through  previous 
contents  of  olded. 

3)  m k f r a m e ( e p o s , a p o s,  epos,bpos,bcopflg)  --  creates 
a  new  f r a me  and  returns  an  ed  f or  that  f r a m e.  The 
f r a me  extension  is  copied  f r om  the  f r a me  specified 
by  epos,  and  the  A L I NK  and  C L I NK  are  specified 
by  apos  and  epos,  respectively.  The  B L I NK  points 
to  the  basic  f r a me  specified  by  bpos,  or  to  a  copy 
of  the  basic  f r a me  if  bcopflg=TRUE. 
In  use,  a r g u(cid:173)
ments  may  be  o m i t t e d;  bcopflg  is  defaulted  to 
F A L S E;  apos,  bpos  and  epos  are  defaulted  to  the 
corresponding  f i e l ds  of  the  f r a me  specified  by epos. 
Thus  mkframe(epos)  creates  a  new  f r a me  extension 
identical  to  that  specified  by  epos. 

4)  enveval(forrA,apos,cpos)  —  creates  a  new  f r a me 
and  initiates  a  computation  w i th  this  environment 
s t r u c t u r e.  A L I NK  and  C L I NK  point  to  f r a m es 
specified  by  apos  and  epos,  respectively;  and  f o rm 
specifies  the  code  to  be  executed,  or  the  ex(cid:173)
pression  to  be  evaluated  in  this  new  environment. 
If  apos  or  cpos  a re  o m i t t e d,  they  are  defaulted  to 
the  A L I NK  or  C L I NK  of  this  invocation  of  enveval. 
T h u s,  enveval(form)  is  the  usual  c a ll 

an 

to 

i n t e r p r e t e r,  and  has  the  same  effect  as  if  the  value  of 
f o rm  had  appeared  in  place  of  the  simple  c a ll  to 
enveval. 
5)  setexfn(pos,fn)  —  places  a  pointer  to  a  user  defined 

function  in  the  exitfn  field  of  the  frame  pos. 
system  is  using  the  e x i t f n,  this  w i ll  create  a  new 
function  which  is  the  composition  of  the  user 
function  (applied  f i r s t)  and  the  system  function.  On 
f r a me  exit,  the  exitfn  w i ll  be  called  w i th  one  a r g u(cid:173)
the 
ment,  the  value  returned  by  the  f r a me  code; 
value  returned  by  fn  w i ll  be  the  actual  value 
r e(cid:173)
turned  to  the  f r a me  specified  by  C L I N K. 

If  the 

6)  getexfn(pos)  —  gets  the  user  set  function  stored  in 
exitfn  of  f r a me  pos.  Returns  N IL  if  none  has  been 
e x p l i c i t ly  stored  there. 
framenm(pos)  --  returns  the  framename  of  f r a me 
pos. 

7) 

A  f r a me  specification  ( i . e.  ,  pos,  apos,  bpos,  epos, 
epos  above}  is  one  of  the  following: 
1.  An  integer  N: 

a.  N=0  specifies  the  f r a me  allocated  on  activation 

of  the  function  e n v i r o n,  setenv,  etc. 
of  e n v i r o n,  setenv  and  m k f r a m e,  the  continu(cid:173)
ation  point  is  set  up  so  that  a  value  returned  to 
this  f r a me  (using  enveval)  is  returned  as  a 
value  of  the  o r i g i n al  c a ll  to  e n v i r o n,  setenv  or 
m k f r a m e. 

In  the  case 

b.  N>0  specifies  the  f r a me  N  links  down  the  control 

l i nk  chain  f r om  the  N=0  f r a m e. 

c.  N<0  specifies  the  f r a me  INI  links  down  the 

access  link  chain  f r om  the  N=0  f r a m e, 

2.  A  l i st  of  two  elements  ( F , N)  where  F  is  a  f r a m e-

name  and  N  is  an  integer.  This  gives  the  Nth 
f r a me  with  name  F,  where  a  positive  (negative) 
value  for  N  specifies  the  control  (access)  chain 
environment. 

3.  The  distinguished  constant  N I L.  As  an  a c c e s s - l i nk 
specification,  N IL  specifies  that  only  global  values 
are  to  be  used  f r e e.  A  process  which  returns 
along  a  N IL  c o n t r o l - l i nk  w i ll  halt. 
setenv(ed,NIL)  releases  f r a me  storage  f o r m e r ly 
referenced  only  through  ed,  without  tying  up  any 
new  storage. 

Doing  a 

4.  An  ed  (environment  d e s c r i p t o r ).  When  given  an  ed 

argument  created  by  a  p r i or  call  on  e n v i r o n, 
environ  creates  a  new  d e s c r i p t or  with 
contents  as  ed;  setenv  copies  the  contents  of  ed 
into  olded. 

the  same 

5.  A  l i st  "(ed)"  consisting  of  exactly  one  ed. 

The 
contents  of  the  listed  ed  are  used  identically  to 
that  of  an  unlisted  ed.  However,  after  this  value 
is  used  in  any  of  the  functions,  setenv(ed.NIL)  is 
done,  thus  releasing  the  f r a me  storage  f o r m e r ly 
referenced  only  through  ed.  This  has  been  c o m(cid:173)
bined  into  an  argument  f o rm  rather  than  allowing 
the  user  to  do  a  setenv  e x p l i c i t ly  because  in  the 
c a ll  to  enveval  the  contents  are  needed,  so  it  can(cid:173)
not  be  done  before  the  c a l l; 
it  cannot  be  done  ex(cid:173)
p l i c i t ly  after  the  enveval  since  control  might  never 
r e t u rn  to  that  point. 

4.  N o n - P r i m i t i ve  C o n t r ol  Functions 

To  i l l u s t r a te  the  use  of  these  p r i m i t i ve  control 

functions,  we  explain  a  number  of  control  regimes 
which  differ  f r om  the  usual  nested  function  c a l l - r e t u rn 
h i e r a r c h i c al  s t r u c t u r e,  and  define  t h e ir  control  s t r u c(cid:173)
ture  routines  in  t e r ms  of  the  p r i m i t i v e s.  We 
include 
stack  j u m p s,  function  c l o s u r e,  and  several  m u l t i p r o(cid:173)
cessing  disciplines. 
In  p r o g r a m m i ng  examples,  we 
use  the  syntax  and  semantics  of  a  L I S P - l i ke  s y s t e m. 
In  an  o r d i n a ry  h i e r a r c h i c al  control  s t r u c t u re 

247 

system,  if module  F  calls  G,  G  calls  H,  and  H  calls  J, 
it  is  impossible  for J  to  return  to  F  without  going  back 
through  G  and  H.  Consider  some  program  in which  a 
search  is  implemented  as  a  series  of  such  nested 
function  calls.  Suppose J  discovered  that the  call to  G 
was  inappropriate  and  wanted  to  return  to  F  with  such 
a  message. 
In  a  hierarchical  control  structure,  H  and 
G  would both  have  to be  prepared  to  pass  such  a  mes(cid:173)
sage back.  However,  in general,  the  function J  should 
not  have  to  know  how  to  force  intermediaries;  it  should 
be  able  to  pass  control  directly to  the  relevant  module. 
Two  functions  may be  defined  to  allow  such  jumpbacks. 
(These  are  implemented  in  BBN-LISP;19  experience 
has  shown  them  to  be  quite  useful.)  The  first  function, 
retfrom(form,pos),  evaluates  form  in  the  current  con(cid:173)
text,  and  returns  its  value  from  the  frame  specified  by 
pos  to  that  frame's  caller;  in  the  above  example,  this 
returns  a  value  to  G's  caller,  i . e .,  P,  The  second 
function,  retevaKform, pos),  evaluates  form  in  the  con(cid:173)
text  of the  caller  of  pos  and  returns  the "value  of the 
form  to  that  caller.  These  are  easily  defined  in  terms 
of  enveval: 

retfrom(form,pos)  =  enveval{form,2,pos) 
retevalform, pos)  = envevalform, pos, pos) 

(The  second  argument  to  retfrom  establishes  that  the 
current  environment  is  to  be  used  for  the  evaluation  of 
form.) 

As  another  example  of  the  use  of  retfrom,  con(cid:173)

sider  an  implementation  of the  LISP  error  protection 
mechanism.  The  programmer  "wraps  a  form  in 
errorset",  i . e .,  errorset(form)  which  is  defined  as 
cons(eval(form),NIL).  This  "wrapping"  indicates  to 
the  system  the  programmer's  intent  that  any  errors 
which  arise  in  the  evaluation  of form  are  to  be  handled 
by the  function  containing the  errorset.  Since  the 
value  of  errorset  in  the  non-error  case  is  always  a 
list  consisting  of  one  element  (the  value  of form),  an 
error  can  be  indicated  by forcing  errorset  to  return 
any  non-list  item.  Hence,  the  system  function  error 
can  be  defined  as  retfrom(NIL,(ERRORSET  1))  where 
uppercase  items  are  literal  objects  in  LISP.  This 
jumps  back  over  all  intermediary  calls  to  return  NIL 
as  the  value  of  the  most  recent  occurrence  of  errorset 
in  the  hierarchical  calling  sequence. 

In  the  following,  we  employ  envapply  which  takes 
as  arguments  a  function  name  and  list  of  (already  eval(cid:173)
uated)  arguments  for that function.  Envapply  simply 
creates  the  appropriate  form  for  enveval. 
envapply(fn,args,aframe, cframe)  = 

enveval(list(APPLY , list(QUOTE, fn), 

list(QUOTE, args)), aframe, cframe) 
A  central  notion  for  control  structures  is  a  pair(cid:173)

ing  of  a  function  with  an  environment  for  its  evaluation. 
Following  LISP,  we  call  such  an  object a  funarg. 
Funargs  are  created  by  the  procedure  function,  defined 

function(fn)=list(FUNARG, fn, environ(2)) 

(The  argument  to  en(cid:173)

That  is,  in  our  implementation,  a  funarg  is  a  list  of 
three  elements: 
the  indicator  FUNARG,  a  function, 
and  an  environment  descriptor. 
viron  makes  it  reference  the  frame  which  called 
function.)  A  funarg  list,  being  a  globally  valid  data 
structure,  can be  passed  as  an argument,  returned  as 
a  result,  or  assigned  as  the  value  of appropriately 
typed  variables.  When  the  language  evaluator  gets  a 
form  (fen  arg1  arg2  . ..  argn)  whose  functional  object 
fen  is  a  funarg,  i. e.  ,  a  list  (FUNARG  fn-name  ed),  it 
creates  a  list,  args,  of  (the  values  of)  a r g l,  arg2,  . . .. 
argn  and  does 

envapply(second(fcn),args,third(fcn), 1) 

The  environment  in  this  case  is  used  exactly  like  the 
original  LISP A-list.  Moses 12  and Weizenbaum25 
have  discussed  the  use  of function  for  preserving  bind(cid:173)
ing  contexts.  Figure  4  illustrates  the  environment 

structure  where  a  functional  has  been  passed  down:  the 
function  foo  with  variables  X  and  L  has  been  called;  foo 
called  mapcar(X,function(fie))  and  fie  has  been  entered. 
Note  that  along  the  access  chain  the  first  free  L  seen 
in  fie  is  bound  in  foo,  although there  is  a  bound  v a r i(cid:173)
able  L  in  mapcar  which  occurs  first  in  the  control 
chain.  Since  frames  are  retained,  a  funarg  can be 
returned  to  higher  contexts  and  still  work. 
(Burge3 
gives  examples  of the  use  of  funargs  passed  up  as 
values.) 

In  the  above  description,  the  environment  pointer 
is  used  only  to  save  the  access  environment. 
In  fact, 
however,  the  pointer  records  the  state  of  a  process  at 
the  instant  of  some  call,  having both  access  and 
control  environments.  Hence,  such an  environment 
pointer  serves  as  part  of a  process  handle. 
It  is  con(cid:173)
venient  to  additionally  specify  an  action  to  take  when 
the  process  is  restarted  and  some  information 
to  be 
passed  to  that  process  from  the  one  restarting  it.  The 
funarg  can  be  reinterpreted  to  provide  these  features. 
The  function  component  specifies  the  first  module  to 
be  run  in  a  restarted  process,  and the  arguments 
(evaluated  in  the  caller)  provided  to  that  function  can 
be  used  to  pass  information.  Hence,  a  funarg  can be 
used  as  a  complete  process  handle. 
venient  for  a  running  process  to  be  able  to  reference 
its  own  process  handle.  To  make  this  simple,  we 
adopt  the  convention  that  the  global  variable  curproc 
is  kept  updated  to  the  current  running  process. 

It  proves  con(cid:173)

With  this  introduction,  we  now  define  the  routines 
start  and  resume,  which  allow  control  to  pass  among  a 
set  of  coordinated  sequential  processes,  i.e.  ,  co(cid:173)
routines,  in  which  each  maintains  its  own  control  and 
access  environment  (with  perhaps  some  sharing).  A 
coroutine  system  consists  of  n  coroutines  each  of 
which  has  a  funarg handle  on  those  other  coroutines  to 
which  it  may  transfer  control.  To  initiate  a  process 
represented  by  the  funarg  fp,  use  start  (we  use 
brackets  below  to  delimit  comments): 

start(fp.args)  =  curproc  —  fp; 

[  curproc  is  a  global  variable  set  to 
the  current  process  funarg ]  ; 
envapply(second(fp),args,third(fp),third(fp)) 
Once  the  variable  curproc  is  initialized,  and  any  co(cid:173)
routine  started,  resume  will  transfer  control  between 
n  coroutines.  The  control  point  saved  is  just  outside 
the  resume,  and  the  user  specifies  a  function  (backfn) 
to  be  called  when  control  returns,  i . e .,  the  process  is 
resumed.  This  function  is  destructively  inserted  in 
the  funarg  list.  The  args  to this  function  are  specified 
by  the  coroutine  transferring  back  to  this  point. 
resume(fnarg,args,backfn)  = 

second( curproc)  — backfn; 

[save  the  specified  backfn  for  a  subsequent 
resume  back  here] 
setenv(third(curproc), 2); 

[environment  saved  is  the  caller  of  resume] 

curproc  —  fnarg; 

[set  up  curproc  for  the  coroutine  to  be 
activated] 

envapply(second(fnarg),args,third(fnarg), 

third (fnarg)) 

[activate  the  specified  coroutine  by  applying 
its  backfn  to  args] 

We  call  a  funarg used  in this  way  a  process 

funarg.  The  state  of a  "process"  is  updated by  de(cid:173)
structively  modifying  a  list  to  change  its  continuation 
function,  and  similarly  directly  modifying  its  environ(cid:173)
ment  descriptor  in  the  list.  A  pseudo-multiprocessing 
capability  can  be  added  to the  system  using these 
process  funargs  if  each  process  takes  responsibility 
for  requesting  additional  time  for  processing  from  a 
supervisor  or  by  explicitly  passing  control  as  in 
CONNIVER,18  A  more  automatic  multiprocessing 
control  regime  using  interrupts  is  discussed  later. 

248 

B a c k t r a c k i ng  is  a  technique  by  which  c e r t a in  e n(cid:173)

v i r o n m e n ts  are  saved  before  a  function  r e t u r n,  and 
l a t er  r e s t o r ed  if  needed.  C o n t r ol  is  r e s t o r ed  in  a 
s t r i c t ly  last  saved, 
f i r st  r e s t o r ed  o r d e r.  As  an  ex(cid:173)
ample  of  its  u s e,  consider  a  function  which  r e t u r ns 
one  (selected)  value  f r om  a  set  of  computed  values  but 
can  effectively  r e t u rn  an  alternative  selection  if  the 
f i r st  selection  was  inadequate.  That  i s,  the  c u r r e nt 
process  can  f a il  back  to  a  previously  specified  f a il set 
point  and  then  redo  the  computation  w i th  a  new 
selection.  A  sequence  of  different  selections  can  lead 
to  a  stack  of  failset  points,  and  successive  fails  can 
r e s t a rt  at  each  in  t u r n.  Backtracking  thus  provides  a 
way  of  doing  a  d e p t h - f i r st  search  of  a  t r ee  with  r e t u rn 
to  previous  branch  points. 

We  define  f a il  and  failset  below.  We  use 

to  the  front  of  L,  and  pop(L) 
p u s h ( L , a)  which  adds  a 
which  removes  one  element  and  r e t u r ns  the  f i r st  e l e(cid:173)
ment  of  L.  F a i l i st 
is  the  stack  of  failset  points.  As 
defined  b e l o w,  f a il  can  reverse  certain  changes  when 
r e t u r n i ng  to  the  previous  failset  point  by  explicit 
d i r e c t i on  at  the  point  of  f a i l u r e. 
(To  automatically  u n(cid:173)
do  certain  side  effects  and  binding  changes,  we  could 
define  "undoable"  functions  which  add  to  f a i l i st  f o r ms 
whose  evaluation  w i ll  reset  appropriate  c e l l s.  F a il 
could  then  eval  a ll  f o r ms  through  the  next  ed  and  then 
call  enveval.) 

failset{  ) =  push(failist,environ(2)) 

[2  means  environment  outside  failset] 

fail(message)  =  enveval(message,list(pop(failist))) 

The  function  select  defined  below  returns  the  f i r st 

element  of  its  argument  set  when  f i r st  called;  upon 
subsequent  f a i ls  back  to  select,  successive  elements 
f r om  set  are  r e t u r n e d. 
If  set  is  exhausted,  f a i l u re  is 
propagated  back.  The  code  uses  the  fact  that  the  b i n d(cid:173)
ing  environment  saved  by  f a i l s et  shares  the  v a r i a b le 
f ig  w i th  the  instance  of  select  which  calls  f a i l s e t.  The 
test  of  f ig  is  reached  in  two  ways:  after  a  c a ll  on  f a i l-
set  (in  which  case  fig  is  false)  and  after  a  f a i l u re  (in 
which  case  f ig  is  t r u e ). 
select(set,undolist)  = 

progt 
if  null(set)  then  fail(undolist)  [leave  here  and 

(fig) 

s1: 

undo  as  specified] 

false; 
f ig  — 
failsetOT 
[ f ig  is  true  i ff  we  have  failed  to  this  point; 

then 

set  has  been  popped] 

if  f ig  then  go(sl); 
f ig  —  t r u e; 
returnTpop(set)); 
end 

Floyd,"7  Hewitt,9  and  Golomb  and  B a u m e r t8  have  d i s(cid:173)
cussed  uses  f or  backtracking  in  p r o b l em  solving. 
S u s s m a nl8  has  discussed  a  number  of  problems  w i th 
b a c k t r a c k i n g. 
In  general,  it  proves  to  be  too  simple 
a  f o rm  of  switching  between  environments.  Use  of  the 
m u l t i p le  process  feature  described  above  provides 
much  m o re  f l e x i b i l i t y. 

5.  Coordinated  Sequential  Processes 

and  P a r a l l el  P r o c e s s i ng 

It  should  be  noted  that  in  the  model  above,  control 

must  be  e x p l i c i t ly  t r a n s f e r r ed  f r om  one  active  e n(cid:173)
v i r o n m e nt  to  another  (by  means  of  enveval  or  resume). 
We  use  the  t e r m,  coordinated  sequential  p r o c e s s,  to 
describe  such  a  control  r e g i m e.  T h e re  are  situations 
in  which  a  p r o b l em  statement  is  s i m p l i f i ed  by  taking  a 
quite  different  point  of  view  -  assuming  p a r a l l el  (co-
operating  sequential)  processes  which  synchronize  only 
when  r e q u i r ed  (e. g.  ,  by  means  of  D i j k s t r a ' s4  P  and  V 
operations).  Using  our  coordinated  sequential  p r o(cid:173)
cesses  w i th  i n t e r r u p t s,  we  can  define  such  a  control 
r e g i m e. 

249 

In  our  model  of  environment  s t r u c t u r e s,  there  is 

a  t r ee  f o r m ed  by  the  control  l i n k s,  a  dendrarchy_  of 
f r a m e s.  One  t e r m i n al  node  is  m a r k ed  f or  a c t i v i ty  by 
the  c u r r e nt  control  bubble  (the  point  where  the 
language  evaluator  is  operating).  A ll  other  t e r m i n al 
nodes  are  referenced  by  environment  d e s c r i p t o rs  or 
by  an  access  l i nk  pointer  of  a  frame  in  the  t r e e.  To 
extend  the  model  to  m u l t i p le  p a r a l l el  processes 
in  a 
single  processor  s y s t e m,  k  branches  of  the  t r ee  must 
be  simultaneously  m a r k ed  active.  Then  the  control 
bubble  of  the  processor  must  be  switched  f r om  one 
active  node  to  another  according  to  some  scheduling 
a l g o r i t h m. 

To  implement  cooperating  sequential  processes  in 

it  is  simplest  to  think  of  adjoining  to  the 

our  m o d e l, 
set  of  processes  a  distinguished  process,  PS,  which 
acts  as  a  s u p e r v i s or  or  m o n i t o r. 
ules  processes  f or  service  and  maintains  several 
p r i v i l e g ed  data  s t r u c t u r es  ( e . g.  ,  queues  for  sema(cid:173)
phores  and  active  processes). 
used  by  P r e m i e r ,14  ) 

(A  related  technique  is 

This  m o n i t or  sched(cid:173)

The  basic  functions  necessary  to  manipulate 

p a r a l l el  processes  allow  process  a c t i v a t i o n,  stopping, 
continuing,  synchronization  and  status  querying. 
In  a 
single  processor  coordinated  sequential  process 
m o d e l,  these  can  all  be  defined  by  calls  (through 
enveval)  to  the  m o n i t or  PS.  Specifications  f or  these 
functions  a r e; 
1) 

process(form ,apos,  cpos)  --  this  is  s i m i l ar  to 
enveval  except  that  it  creates  a  new  active  p r o-
cess  P'  f or  the  evaluation  of  f o r m,  and  returns 
to  the  creating  process  a  process  d e s c r i p t or  (pd) 
which  acts  as  a  handle  on  P '. 

In  this  m o d e l,  the  pd  could  be  a  pointer  to  a  l i st  which 
has  been  placed  on  a  " r u n n a b l e"  queue  in  PS,  and 
which  is  i n t e r p r e t ed  by  PS  when  the  scheduler  in  PS 
gives  this  process  a  t i me  quantum.  One  element  of 
the  process  d e s c r i p t or  gives  the  status  of  the  p r o c e s s, 
e . g.  ,  RUNNING  or  STOPPED.  Process  is  defined 
using  environ  (to  obtain  an  environment  d e s c r i p t or 
used  as  part  of  the  pd)  and  enveval  (to  call  PS), 
2) 

stop(pd)  —  halts  the  execution  of  the  process 
specified  by  pd  —  PS  removes  the  process  f r om 
runnable  queue.  The  value  returned  is  an  ed  of 
the  c u r r e nt  environment  of  pd. 
continue(pd)  --  returns  pd  to  the  runnable  queues. 
status(pd)  —  value  is  an  indication  of  status  of  pd. 
obtain(semaphore)  —  this  D i j k s t ra  P  operator 
t r a n s f e rs  control  to  PS  (by  enveval)  which  de(cid:173)
t e r m i n es  if  a  resource  is  available  ( i.  e ,,  s e m a(cid:173)
phore  count  positive).  PS  either  hands  control 
back  to  PI  (with  enveval)  having  decremented  the 
the  semaphore  count,  or  enters  P1  on  that  sema(cid:173)
phore's  queue  in  PS's  environment  and  switches 
control  to  a  runnable  process. 
release(semaphore) 
i n c r e m e n ts  the  semaphore  count; 
if  the  count 
goes  positive,  one  process  is  moved  f r om  the 
semaphore  queue  (if  any  exist)  onto  the  runnable 
queue  and  the  count  is  decremented. 
hands  control  back  to  the  calling  p r o c e s s. 

this  Dijkstra  V  operator 

It  then 

-- 

3) 
4) 
5) 

6) 

We  emphasize  that  these  six  functions  can  be  d e(cid:173)
fined  in  t e r ms  of  the  control  p r i m i t i v es  of  section  3. 

Scheduling  of  runnable  processes  could  be  done  by 

i . e .,  obtain(time),  at  appropriate  i n t e r v a l s. 

having  each  process  by  agreement  ask  f or  a  t i me 
r e s o u r c e, 
In  this  scheduling  m o d e l,  control  never  leaves  a  p r o(cid:173)
cess  without  its  knowledge,  and  the  m o n i t or  s i m p ly 
acts  as  a  bookkeeping  m e c h a n i s m.  A l t e r n a t i v e l y, 
o r d i n a ry  t i m e - s h a r i ng  among  processes  on  a  t i me 
quantum  basis  could  be  implemented  through  a  t i m er 
i n t e r r u pt  m e c h a n i s m. 

I n t e r r u p ts  are  treated  as  forced 

calls  to  environ  (to  obtain  an  ed  for  the  current  state), 
and  then  an  enveval  to the  monitor  process.  The  only 
problem  which  must  be  handled  by  the  system  in  forc(cid:173)
ing  the  call  to  environ  is  making  sure  the  interrupted 
process  is  in  a  clean  state;  that  is,  one  in which  basic 
communication  assumptions  about  states  of  pointers, 
queues,  buffers,  etc.  are  true  ( e . g .,  no  pointers  in 
machine  registers  which  should  be  traced  during  gar(cid:173)
bage  collection).  This  can  be  ensured  if asynchronous 
hardware  interrupts  perform  only  minimal  necessary 
operations,  and  set  a  software  interrupt  flag.  Soft(cid:173)
ware  checks  made  before  procedure  calls,  returns  and 
backward  jumps  within  program  will  ensure  that  a 
timely  response  in  a  clean  state  will  occur. 

The  ed  of the  interrupted  process  is  sufficient  to 

restart  it,  and  can be  saved  on  the  runnable  queue 
within  a  process  descriptor.  Because  timer  inter(cid:173)
rupts  are  asynchronous  with  other  processing  in  such 
a  simulated  multiprocessor  system,  evaluation  of 
forms  in  the  dynamic  environment  of  another  running 
process  cannot  be  done  consistently;  however,  the  ed 
obtained  from  stopping a  process  provides  a  consistent 
environment.  Because  of this  interrupt  asynchrony,  in 
order  to  ensure  system  integrity,  queue  and  sema(cid:173)
phore  management  must  be  uninterruptible,  e . g .,  at 
the  highest  priority  level. 

Obtaining  a  system  of  cooperating  sequential  pro(cid:173)
cesses  as  an  extension  of the  primitives  has  a  number 
of desirable  attributes.  Most  important,  perhaps,  it 
allows  the  scheduler  to  be  defined  by  the  user.  When 
parallel  processes  are  used  to  realize  a  breadth-first 
search  of an  or-graph,  there  is  a  significant  issue  of 
how  the  competing  processes  are  to  be  allotted  time. 
Provision  for  a  user  supplied  scheduler  establishes  a 
framework  in  which  an  intelligent  allocation  algorithm 
can be  employed. 

Once  a  multi-process  supervisor  is  defined,  a 

variety  of additional  control  structures  may  be  readily 
created.  As  an  example,  consider  multiple  parallel 
returns  — the  ability  to  return  from  a  single  activation 
of a  module  G  several  times  with  several  (different) 
values.  For  G  to  return  to  its  caller  with  value  given 
by  val  and  still  continue  to  run,  G  simply  calls 
process(val, 1,2).  Then the  current  G  and  the  new 
process  proceed  in  parallel. 

6.  Conclusion 

In  providing  linguistic  facilities  more  complex 

than  hierarchical  control,  a  key  problem  is  finding  a 
model  that  clearly  exhibits  the  relation  between  pro(cid:173)
cesses,  access  modules,  and  their  environment.  This 
paper has  presented  a  model  which  is  applicable  to 
languages  as  diverse  as  LISP,  APL  and P L /I  and  can 
be  used  for  the  essential  aspects  of  control  and  access 
in  each.  The  control  primitives  provide  a  small  basis 
on  which  one  can  define  almost  all  known  regimes  of 
control. 

Although  not  stressed  in  this  paper,  there  is  an 

implementation  for  the  model  which  is  perfectly 
general,  yet  for  several  subcases  ( e . g .,  simple  re(cid:173)
cursion  and  backtracking)  this  implementation  is  as 
efficient  as  existing  special  techniques.  The  main 
ideas  of the  implementation are  as  follows  (cf.  [2]  for 
details).  The  basic  frame  and  frame  extension  are 
treated  as  potentially  discontiguous  segments.  When 
a  frame  extension  is  to be  used  for  running,  it  is 
copied  to  an  open  stack  end  if  not  there  already,  so 
that  ordinary  nested  calls  can  use  simple  stack  disci(cid:173)
pline  for  storage  management.  Reference  counts  are 
combined  with  a  count  propagation  technique  to  ensure 
that  only  those  frames  are  kept  which  are  still  in use. 
Thus,  the  model  provides  both  a  linguistic  frame-
work  for  expressing  control  regimes,  and  a  practical 
basis  for  an  implementation. 
It  is  being  incorporated 
intoBBN-LISP.19 

7.  Acknowledgments 

This  work  was  supported  in  part  by the  Advanced 
Research  Projects  Agency  under  Contracts  DAHC  15-
71-00088  and  F19628-68-0-0379,  and  by  the  U.S.  A ir 
Force  Electronics  Systems  Division  under  Contract 
F19628-71-C-0173.  Daniel  Bobrow  was  at  Bolt 
Beranek  and  Newman,  Cambridge,  Massachusetts, 
when  many  of the  ideas  in  this  paper  were  first  de(cid:173)
veloped. 

[l] 

[2l 

[3] 

[41 

[5] 

[6] 

[7] 

[8t 

[9! 

References 

Bobrow,  D . G .,  "Requirements  for  Advanced 

Programming  Systems  for  List  Processing," 
CACM,  Vol.  15,  No.  6,  June  1972. 

Bobrow,  D.G.  and  Wegbreit,  B. 

"A  Model  and 

Stack  Implementation  of  Multiple  Environ(cid:173)
ments,"  BBN  Report No.  2334,  Cambridge, 
Mass.,  March  1972,  to appear  in  CACM. 

Burge,  W.H. 

"Some  Examples  of the  Use  of 

Function  Producing  Functions,"  Second  Sym(cid:173)
posium  on  Symbolic  and  Algebraic  Manipu(cid:173)
lation,  AC:M,  1971. 

Dijkstra,  E.W. 

"Co-operating Sequential  Pro(cid:173)

cesses,"  in  Genuys  (Ed.),  Programming 
Languages,  Academic  Press,  1967. 

Dijkstra,  E.W. 

"Recursive  Programming," 

Numerische  Mathematik  2  (I960),  312-318. 
Also  in  Programming  Systems  and  Languages, 
S.  Rosen  (Ed.),  McGraw-Hill,  New York,  1967. 

Fenichel,  R. 

"On Implementation  of  Label  Vari(cid:173)

ables,  CACM,  Vol.  14,  No.  5 (May  1971), 
pp.  349-350. 

Floyd,  R.W. 

"Non-deterministic  Algorithms," 

J_.  ACM,  14  (October  1967),  pp.  638-644. 

Golomb,  S.W.  and  Baumert,  L.D. 

"Backtrack 
Programming,"  J.  ACM,  12  (October  1965), 
pp.  516-524. 

Hewitt,  C. 
lating  Models  and  Proving  Theorems  in  a 
Robot," 
Washington,  D.C.,  May  1969. 

"PLANNER:  A  Language  for Manipu(cid:173)
in  Artificial  Intelligence, 

[10]  Johnston,  J . B. 

"The  Contour  Model  of  Block 

Structured  Processes,"  in  Tou  and  Wegner, 
Proc.  Symposium  on  Data  Structures  in 
Programming  Languages.  SIGPLAN  Notices, 
Vol.  6,  No.  2,  pp.  55-82. 

[11]  McCarthy,  J .,  et  al.  Lisp  1. 5  Programmer's 

Manual,  T h e M . I . T.  Press,  Cambridge, 
Massachusetts  (1962). 

[12]  Moses,  J. 

"The  Function  of  FUNCTION  in 

LISP,"  SIGSAM  Bulletin,  No.  15,  (July  1970), 
pp.  13-27. 

[13j  Prenner,  C ,,  Spitzen,  J.  and  Wegbreit,  B. 

"An  Implementation  of  Backtracking  for  Pro(cid:173)
gramming  Languages,"  submitted  for  publi(cid:173)
cation,  ACM-72. 

[14J  Prenner,  C. 

"Multi-path  Control  Structures  for 

Programming  Languages,"  Ph.D.  Thesis, 
Harvard  University,  May  1972. 

[151  Quam,  L.  LISP  1. 6 Reference Manual,  Stanford 

AI  Laboratory. 

250 

[16]  Reynolds,  J. 

"GEDANKEN  - A  Simple  TypelesS 
Language  Based  on  the  Principle  of Complete(cid:173)
ness  and  the  Reference  Concept,"  CACM, 
Vol.  13,  No.  5  (May  1970),  pp.  308-319. 

[17]  Rulifson,  J.  et  al. 

" Q A 4- A  Language for 

Writing  Problem-Solving  Programs,"  SRI 
Technical  Note  48,  November  1970. 

[18]  Sussman,  G.J. 

"Why  Conniving  is  Better  than 

Planning,"  FJCC  1972,  pp.  1171-1179. 

[19]  Teitelman,  W.,  Bobrow,  D.  ,  Murphy,  D.,  and 

Hartley,  A.  BBN-LISP  Manual.  BBN, 
July  1971. 

[20]  Tou,  J,  andWegner,  P.  (Eds.),  SIGFLAN 

Notices — Proc. Symposium on  Data 
Structures  in  Programming  languages. 
Vol.  6,  No.  2  (February 1971) 

[ 2 ll  van  Wijngaarden,  A.  (Ed.).  Report on the 

Algorithmic  Language  ALGOL  68,  MR  101, 
Mathematisch  Centrum,  Amsterdam 
(February  1969). 

[22]  Wegbreit,  B, 

"Studies  in  Extensible  Program(cid:173)

ming  Languages" Ph.D.  Thesis,  Harvard 
University,  May  1970. 

[23]  Wegbreit,  B, 

"The  ECL  Programming  System," 

Proc.  AFIPS  1971  FJCC,  Vol.  39,  AFIPS 
Press,  Montvale,  N . J .,  pp.  253-262. 

[24]  Wegner,  P. 

"Data  Structure  Models  for  Pro-

gramming  Languages,"  in  Tou  and  Wegner, 
pp.  55-82. 

[25]  Weizenbaum,  J. 

"The  Funarg  Problem 

Explained,"  M . I . T .,  Cambridge,  Mass., 
March  1968. 

251 

252 

253 

