Decidable Reasoning in a Modiﬁed Situation Calculus
Mikhail Soutchanski

Yilan Gu

Dept. of Computer Science

University of Toronto
10 King’s College Road

Toronto, ON, M5S 3G4, Canada

Email: yilan@cs.toronto.edu

Department of Computer Science

Ryerson University

245 Church Street, ENG281

Toronto, ON, M5B 2K3, Canada

Email: mes@scs.ryerson.ca

Abstract

We consider a modiﬁed version of the situation cal-
culus built using a two-variable fragment of the
ﬁrst-order logic extended with counting quantiﬁers.
We mention several additional groups of axioms
that can be introduced to capture taxonomic rea-
soning. We show that the regression operator in this
framework can be deﬁned similarly to regression in
the Reiter’s version of the situation calculus. Using
this new regression operator, we show that the pro-
jection and executability problems are decidable in
the modiﬁed version even if an initial knowledge
base is incomplete and open. For an incomplete
knowledge base and for context-dependent actions,
we consider a type of progression that is sound with
respect to the classical progression. We show that
the new knowledge base resulting after our progres-
sion is deﬁnable in our modiﬁed situation calculus
if one allows actions with local effects only. We
mention possible applications to formalization of
Semantic Web services.

Introduction

1
The situation calculus is a popular and well understood pred-
icate logic language for reasoning about actions and their ef-
fects [Reiter, 2001]. It is used to provide a well-deﬁned se-
mantics for Web services and a foundation for a high-level
programming language Golog [Reiter, 2001; McIlraith and
Son, 2002]. However, because the situation calculus is for-
mulated in a general predicate logic, reasoning about effects
of sequences of actions is undecidable (unless some restric-
tions are imposed on the theory that axiomatizes the initial
state of the world). The ﬁrst motivation for our paper is
intention to overcome this difﬁculty. We propose to use a
two-variable fragment FO2 of the ﬁrst-order logic (FOL) as a
foundation for a modiﬁed situation calculus. Because the sat-
isﬁability problem in this fragment is known to be decidable
(it is in NEXPTIME), we demonstrate that by reducing rea-
soning about effects of actions to reasoning in this fragment,
one can always guarantee decidability. The second motiva-
tion for our paper comes from description logics. Description
Logics (DLs) [Baader et al., 2003] are a well-known family

of knowledge representation formalisms, which play an im-
portant role in providing the formal foundations of several
widely used Web ontology languages including OWL in the
area of the Semantic Web. Many expressive DLs can be trans-
lated to FO2 and offer considerable expressive power going
far beyond propositional logic, while ensuring that reasoning
is decidable [Borgida, 1996]. DLs have been mostly used to
describe static knowledge bases. However, several research
groups consider formalization of actions using DLs or exten-
sions of DLs. Following the key observation that reasoning
about complex actions can be carried in a fragment of the
propositional situation calculus, [Giacomo et al., 1999] give
an epistemic extension of DLs to provide a framework for the
representation of dynamic systems. However, the representa-
tion and reasoning about actions in this framework are strictly
propositional, which reduces the representation power of this
framework. In [Baader et al., 2005], Baader et al. provide
another proposal for integrating description logics and ac-
tion formalisms. They take the well known description logic
ALCQIO (and its sub-languages) as foundation and show that
the complexity of executability and projection problems (two
basic reasoning problems for possibly sequentially composed
actions) coincides with the complexity of standard DL rea-
soning. However, actions (services) are represented in their
paper meta-theoretically, not as ﬁrst-order (FO) terms. This
can potentially lead to some complications when speciﬁca-
tions of other reasoning tasks (e.g., planning) will be consid-
ered because it is not possible to quantify over actions in their
framework. In our paper, we take a different approach and
represent actions as FO terms, but achieve integration of tax-
onomic reasoning and reasoning about actions by restricting
the syntax of the situation calculus and by introducing addi-
tional axioms to represent a taxonomy.

Because after doing longer and longer sequences of ac-
tions, solving projection problems becomes increasingly
more difﬁcult, it is beneﬁcial to progress the initial incom-
plete knowledge base (KB) to represent the current state of
the world. Then, the subsequent projection problems can be
solved with respect to a new progressed KB. The task of com-
puting a progressed KB is called the progression problem.
Our paper is structured as follows. In Section 2, we brieﬂy
review the Reiter’s situation calculus and the extension of
FO2 with counting quantiﬁers. In Section 3 we discuss de-
tails of our proposal: a modiﬁed situation calculus. In Section

IJCAI07

1891

4 we consider an extension of regression (the main reasoning
mechanism in the situation calculus). Finally, in Section 5 we
discuss the progression problem and in Section 6 we discuss
brieﬂy other related approaches to reasoning about actions.

2 Background
The situation calculus (SC) Lsc is a predicate language for
axiomatizing dynamic systems. All dialects of the SC Lsc
include three disjoint sorts: actions, situations and objects.
Actions are FO terms consisting of an action function sym-
bol and its arguments. Actions change the world. Situa-
tions are FO terms which denote world histories. A distin-
guished constant S0 is used to denote the initial situation,
and function do(a, s) denotes the situation that results from
performing action a in situation s. Every situation corre-
Objects are
sponds uniquely to a sequence of actions.
FO terms other than actions and situations that depend on
the domain of application. Fluents are relations or func-
tions whose values may vary from one situation to the next.
Normally, a ﬂuent is denoted by a predicate or function sym-
bol whose last argument has the sort situation. For example,
F ((cid:2)x, do([α1,··· , αn], S0)) represents a relational ﬂuent in
the situation do(αn, do(··· , do(α1, S0)··· ) resulting from
execution of ground action terms α1,··· , αn in S0. We do
not consider functional ﬂuents in this paper.
The SC includes the distinguished predicate P oss(a, s) to
characterize actions a that are possible to execute in s. For
any SC formula φ and a term s of sort situation, we say φ is
a formula uniform in s iff it does not mention the predicates
P oss, it does not quantify over variables of sort situation, it
does not mention equality on situations, and whenever it men-
tions a term of sort situation in the situation argument position
of a ﬂuent, then that term is s (see [Reiter, 2001]). If φ(s) is a
uniform formula and the situation argument is clear from the
context, sometimes we suppress the situation argument and
write this formula simply as φ, and also introduce a notation
φ[s] to represent the SC formula obtained by restoring situa-
tion s back to all the ﬂuents and/or P oss predicates (if any)
in φ. It is obvious that φ[s] is uniform in s.
A basic action theory (BAT) D in the SC is a set of axioms
written in Lsc with the following ﬁve classes of axioms to
model actions and their effects [Reiter, 2001]: action precon-
dition axioms Dap, successor state axioms (SSAs) Dss, initial
theory DS0, unique name axioms Duna, domain independent
foundational axioms for situations Σ.
Suppose that D = Duna ∪ DS0 ∪ Dap ∪ Dss ∪ Σ is a BAT,
α1,··· , αn is a sequence of ground action terms, and G(s) is
a uniform formula with one free variable s. One of the most
important reasoning tasks in the SC is the projection problem,
that is, to determine whether D |= G(do([α1,··· , αn], S0)).
Another
executabil-
task
executable(do([α1,··· , αn], S0))
(cid:2)n
ity problem.
formula P oss(α1, S0) ∧
be
the
an abbreviation of
i=2 P oss(αi, do([α1,··· , αi−1], S0)).
the
executability
whether
D |= executable(do([α1,··· , αn], S0)).
Planning and
high-level program execution are two important settings
where the executability and projection problems arise natu-

reasoning
Let

problem is

determine

Then,

to

basic

is

the

rally. Regression is a central computational mechanism that
forms the basis for automated solution to the executability
and projection tasks in the SC [Reiter, 2001]. A recursive
deﬁnition of the regression operator R on any regressable
formula φ is given in [Reiter, 2001]. We use notation R[φ] to
denote the formula that results from eliminating P oss atoms
in favor of their deﬁnitions as given by action precondition
axioms and replacing ﬂuent atoms about do(α, s) by logically
equivalent expressions about s as given by SSAs repeatedly
until it cannot make such replacement any further.
The
formula G(do([α1,··· , αn], S0)) is a particularly simple
example of a regressable formula because it is uniform in
do([α1,··· , αn], S0)), but generally, regressable formulas
can mention several different ground situation terms. The re-
gression theorem shows that one can reduce the evaluation of
a regressable formula φ to a FOL theorem proving task in the
initial theory together with unique names axioms for actions:

D |= φ iff DS0 ∪ Duna |= R[φ].

This fact is the key result for our paper:
it demonstrates
that an executability or a projection task can be reduced to
a FOL theorem proving task. However, because DS0 is an
arbitrary FO theory, this type of reasoning is undecidable.
Two of the most common ways to overcome this difﬁculty
is to introduce the closed world assumption or introduce
the domain closure assumption (i.e., assume the domain
is ﬁnite).
In many application domains these assumptions
are unrealistic. Therefore, we consider a version of the SC
formulated in FO2, or in C 2.

Two-variable FO logic FO2 is the fragment of ordinary
FO logic (with equality), whose formulas only use no more
than two variable symbols x and y (free or bound). Two-
variable FO logic with counting C 2 extends FO2 by allowing
FO counting quantiﬁers ∃≥m and ∃≤m for all m ≥ 1.
[Pa-
cholski et al., 1997] show that satisﬁability problem for C 2
is decidable and recently [Pratt-Hartmann, 2005] proves that
this problem is in NEXPTIME even when counting quantiﬁers
are coded succinctly. See additional background on DLs and
discussion of connections between DLs with C 2 in [Baader
et al., 2003; Borgida, 1996; Gu and Soutchanski, 2006].

3 Modeling Dynamic Systems in a Modiﬁed

Situation Calculus

In this section, we consider dynamic systems formulated in a
modiﬁcation of the language of the SC so that it can be con-
sidered as an extension to C 2 (with an additional situation ar-
gument).1 The key idea is to consider a syntactic modiﬁcation
of the SC such that the executability and projection problems
are guaranteed to be decidable as a consequence of the de-
cidability of the satisﬁability problem in C 2. Moreover, since
the modiﬁed SC has strong connections with description log-
ics, which will be explained in detail below, we will denote
this language as LDL
sc .
(i.e., actions, situations
and objects) are the same as those in Lsc, except that they
1The reason that we call it a ”modiﬁed” SC rather than a ”re-
stricted” SC is that we extend the SC with other features, such as
adding acyclic TBox axioms to basic action theories.

First of all, the three sorts in LDL

sc

IJCAI07

1892

obey the following restrictions: (1) all terms of sort object
are variables (x and y) or constants, i.e., object functional
symbols are not allowed; (2) all action functions include no
more than two arguments. Each argument of any term of sort
action is either a constant or an object variable (x or y); (3)
variable s of sort situation and/or variable a of sort action are
the only additional variables being allowed in D − Σ − Duna
in addition to variables x, y.
Second, any ﬂuent in LDL
sc

is a predicate either with two
or with three arguments (including the one of sort situation).
We call ﬂuents with two arguments (dynamic) concepts, and
In LDL
sc ,
call ﬂuents with three arguments (dynamic) roles.
(static) concepts (i.e., unary predicates with no situation ar-
gument) and (static) roles (i.e., binary predicates with no sit-
uation argument), if any, are considered as unchangeable tax-
onomic properties and unchangeable classes of an application
domain. Moreover, each concept (static or dynamic) can be
either primitive or deﬁned.
Third, apart from the standard FO logical symbols ∧, ∨
and ∃, with the usual deﬁnition of a full set of connectives
sc also includes counting quantiﬁers ∃≥m
and quantiﬁers, LDL
and ∃≤m for all m ≥ 1. Equality = is allowed in LDL
sc .

sc

For
there is one axiom of

The dynamic systems we are dealing with here sat-
isfy the open world assumption (OWA): what
is not
stated explicitly is currently unknown rather than false.
In this paper,
the dynamic systems we are interested
in can be formalized as a basic action theory (BAT) D
using the following seven groups of axioms in LDL
sc :
D = Σ ∪ Dap ∪ Dss ∪ DT ∪ DR ∪ Duna ∪ DS0. Five of
them (Σ,Dap,Dss,Duna,DS0) are similar to those groups
in a BAT in Lsc, and the other two (DT ,DR) are introduced
to axiomatize description logic related facts and properties
(see below). However, because LDL
allows only two
object variables, all axioms must conform to the following
additional requirements.
Action precondition axioms Dap:
each ac-
tion A in LDL
sc ,
the form
P oss(A, s) ≡ ΠA[s] (or P oss(A(x), s) ≡ ΠA(x)[s],
or P oss(A(x, y), s) ≡ ΠA(x, y)[s], respectively), if A is an
action constant (or unary, or binary action term, respectively),
where ΠA (or ΠA(x), or ΠA(x, y), respectively) is a C 2
formula with no free variables ( or with at most x, or with at
most x, y as the only free variables, respectively). This set of
axioms characterize the preconditions of all actions.
Successor state axioms Dss: There are two types of
ﬂuents in LDL
sc : primitive dynamic concepts of the form
F (x, s) (ﬂuents with exactly one non-situation argument)
and primitive dynamic roles of the form F (x, y, s) (ﬂuents
with exactly two non-situation arguments). Let variable
vector (cid:2)x to be x, or y, or (cid:8)x, y(cid:9); a SSA is speciﬁed for each
ﬂuent F ((cid:2)x, do(a, s)). According to the general syntactic
form of the SSAs provided in [Reiter, 2001], without loss of
generality, we can assume that the axiom has the form

F ((cid:2)x, do(a, s)) ≡ ψF ((cid:2)x, a, s),
(cid:3)m0
(cid:3)m1
i=1[∃x][∃y](a= A+
F ((cid:2)x, s) ∧ ¬(
j=1[∃x][∃y](a= A−

where the general structure of ψF ((cid:2)x, a, s) is as follows:
i ((cid:2)x(i,1,+))[s]) ∨

j ((cid:2)x(j,0,−)) ∧ φ−

i ((cid:2)x(i,0,+)) ∧ φ+

j ((cid:2)x(j,1,−))[s])),

where each variable vector (cid:2)x(i,n,b) (or (cid:2)x(j,n,b) respectively)
(i = 1..m0, j = 1..m1, n ∈ {0, 1}, b ∈ {+,−}) represents a
vector of object variables, which can be empty, x, y, (cid:8)x, y(cid:9) or
(cid:8)y, x(cid:9). Moreover, [∃x] or [∃y] represents that the quantiﬁer
i ((cid:2)x(i,1,+)), i = 1..m0
included in [ ] is optional; and each φ+
(φ−
i ((cid:2)x(j,1,−)), j = 1..m1, respectively), is a C 2 formula
with variables (both free and quantiﬁed) among x and y.
Note that when m0 (or m1 respectively) is equal to 0, the
corresponding disjunctive subformula is equivalent to f alse.
Acyclic TBox axioms DT : Similar to the TBox axioms in
DL, we may deﬁne new concepts using TBox axioms. Any
group of TBox axioms DT may include two sub-classes:
static TBox DT,st and dynamic TBox DT,dyn. Every formula
in static TBox is a concept deﬁnition formula of the form

G(x) ≡ φG(x),

G(x, s) ≡ φG(x)[s],

R1(x, y)[s] ⊃ R2(x, y)[s],

where G is a unary predicate symbol and φG(x) is a C 2 for-
mula in the domain with free variable x, and there is no ﬂuent
in it. Every formula in dynamic TBox is a concept deﬁnition
formula of the form
where φG(x) is a C 2 formula with free variable x, and there
is at least one ﬂuent in it. All the concepts appeared in the
left-hand side of TBox axioms are called deﬁned concepts.
We also require that the set of TBox axioms must be acyclic
(acyclicity in DT is deﬁned exactly as it is deﬁned for TBox ).
RBox axioms DR: Similar to the idea of RBox in DL, we
may also specify a group of axioms, called RBox axioms be-
low, to support a role taxonomy. Each role inclusion axiom is
represented as
where R1 and R2 are primitive roles (either static or dy-
namic). If these axioms are included in the BAT D, then it
is assumed that D is speciﬁed correctly in the sense that the
meaning of any RBox axiom included in the theory is cor-
rectly compiled into SSAs. That is, one can prove by induc-
tion that (D − DR) |= ∀s.R1(x, y)[s] ⊃ R2(x, y)[s]. Al-
though RBox axioms are not used by the regression operator,
they are used for taxonomic reasoning in the initial theory.
Initial theory DS0: It is a ﬁnite set of C 2 sentences (assum-
ing that we suppress the only situation term S0 in all ﬂuents).
It speciﬁes the incomplete information about the initial prob-
lem state and also describes all the facts that are not change-
able over time in the domain of an application. In particular,
it includes static TBox axioms DT,st as well as RBox axioms
in the initial situation S0 (if any). In addition, DS0 also in-
cludes all unique name axioms for object constants.
The remaining two classes (foundational axioms for situ-
ations Σ and unique name axioms for actions Duna) are the
same as those in the BATs of the usual SC. Note that these
axioms (as well as Dap and Dss) use more than two variables
(e.g., Dss use action and situation variables in addition to ob-
ject variables), but we will see in the next section, that these
axioms will be eliminated in the process of regressing a re-
gressable formula to a sentence that will use no more than
two object variables and no other variables.

4 Modiﬁed Regression with Lazy Unfolding
After giving the deﬁnition of what the BAT in LDL
turn our attention to the reasoning tasks.

sc

is, we

(1)

IJCAI07

1893

sc

sc

sc

sc

Given a formula W of LDL

in the domain D, the deﬁni-
tion of W being regressable (called LDL
regressable below)
is slightly different from the deﬁnition of W being regress-
able in Lsc (see [Reiter, 2001]) by adding the following two
conditions: (i) any variable (free or bounded) in W is either
x or y; (ii) every term of sort situation in W is ground. More-
over, in LDL
sc we have to be more careful with the deﬁnition of
the regression operator R for two main reasons. First, to deal
with TBox we have to extend regression. For a LDL
regress-
able formula W , we extend below the regression operator de-
ﬁned in [Reiter, 2001] with the lazy unfolding technique (see
[Baader et al., 2003]) to expand deﬁned dynamic concepts.
We still denote such operator as R. Second, LDL
sc uses only
two object variables and we have to make sure that after re-
gressing a ﬂuent atom we still get a LDL
formula, i.e., that
we never need to introduce new (free or bound) object vari-
ables. To deal with the two-variable restriction, we modify
our regression operator R in comparison to the conventional
operator deﬁned in [Reiter, 2001]. For example, when replac-
ing P oss atom or ﬂuent atoms about do(α, σ), the deﬁnition
of the conventional regression operator in [Reiter, 2001] has
the assumption that the quantiﬁed variables in the right-hand
side of the corresponding axioms should be renamed to new
variables different from the free variables in the atoms that to
be replaced. This assumption of using new variables for re-
naming assures equivalence of original formula and the for-
mula after regression. To avoid introducing new variables (as
required by the Reiter’s regression operator) and to assure de-
ﬁned dynamic concepts being handled, we modify the regres-
sion operator for each LDL
regressable formula. Possibility
of reusing variables is guaranteed by the general format of the
SSAs given in the previous section and the additional condi-
tion (ii) in the deﬁnition of the LDL
The complete formal deﬁnition of our R is as follows,
where σ denotes the term of sort situation, and α denotes the
term of sort action.
If W is not atomic, i.e. W is of the form W1 ∨ W2,
•
W1 ∧ W2, ¬W (cid:4), Qv.W (cid:4) where Q represents a quantiﬁer (in-
cluding counting quantiﬁers) and v represents a variable sym-
bol, then
R[W1 ∨ W2] = R[W1] ∨ R[W2],
R[¬W (cid:2)] = ¬R[W (cid:2)],
R[W1 ∧ W2] = R[W1] ∧ R[W2],R[Qv.W (cid:2)] = Qv.R[W (cid:2)].
• Otherwise, W is atom. There are several cases.
If W is of the form A1((cid:2)t) = A2((cid:2)t(cid:4)) for some action
a.
function symbols A1 and A2, then by using axioms in Duna,2
we deﬁne the regression of W as

regressable formula.

sc

sc

if A1 (cid:14)= A2,
otherwise.

(cid:4) ⊥
(cid:2)|(cid:2)t|
i=1 ti = t(cid:4)

i

R[W ] =

Otherwise, if W is situation independent atom (including
equality between object constants or variables), or W is a
concept or role uniform in S0, then
R[W ] = W.

b.

If W is a regressable P oss atom, so it has the form

2Notice that the action functions with different number of argu-
ments always use different function symbols (i.e., different names).

R[W ] =

8>>>><
>>>>:

P oss(A((cid:2)t), σ), for terms of sort action and situation respec-
tively in LDL
sc . Then there must be an action precondition
axiom for A of the form P oss(A((cid:2)x), s) ≡ ΠA((cid:2)x, s), where
the argument (cid:2)x of sort object can either be empty (i.e., A is
an action constant), a single variable x or two-variable vector
(cid:8)x, y(cid:9). Because of the syntactic restrictions of LDL
sc , each
term in (cid:2)t can only be a variable x, y or a constant C. Then,
if (cid:3)t = (cid:5)x, x(cid:6),
else if (cid:3)t = (cid:5)y, y(cid:6),
else if (cid:3)t = (cid:5)x, C(cid:6) or
(cid:3)t = (cid:5)x, y(cid:6) or (cid:3)t = x,
otherwise,

R[(∃y)(x = y ∧ ΠA(x, y, σ))]
R[(∃x)(y = x ∧ ΠA(x, y, σ))]
R[ΠA((cid:3)t, σ)]
R[fΠA((cid:3)t, σ)]

formula φ obtained by replacing every variable symbol x
(free or quantiﬁed) with variable symbol y and replacing
every variable symbol y (free or quantiﬁed) with variable

where C is a constant and (cid:5)φ denotes a dual formula for
symbol x in φ, i.e., (cid:5)φ = φ[x/y, y/x].
c.
If W is a deﬁned dynamic concept, so it has the form
G(t, σ) for some object term t and situation term σ, and there
must be a TBox axiom for G of the form G(x, s) ≡ φG(x, s).
Because of the restrictions of the language LDL
sc , term t can
only be a variable x, y or a constant. Then, we use lazy
unfolding technique as follows:
R[W ] =

j R[φG(t, σ)]
R[fφG(y, σ)]

if t is not variable y,
otherwise.

so it has

d.
If W is a primitive concept (a primitive role,
the form F (t1, do(α, σ)) or
respectively),
F (t1, t2, do(α, σ)) for some terms t1 (and t2) of sort
object, term α of sort action and term σ of sort situation.
There must be a SSA for ﬂuent F such as Eq. (1). Because
of the restriction of the language LDL
sc , the term t1 and t2 can
only be a variable x, y or a constant C and α can only be
an action function with no more than two arguments of sort
object. Then, when W is a concept,
R[W ] =

if t1 is not variable y,
otherwise, i.e., if t1 = y;

j R[ψF (t1, α, σ)]
R[fψF (y, α, σ)]
8>>><
R[(∃y)(x = y ∧ ψF (x, y, α, σ))]
R[fψF (y, x, α, σ)]
R[(∃x)(y = x ∧ ψF (x, y, α, σ))]
>>>:
R[ψF (t1, t2, α, σ)]

and, when W is a role,

if t1 = x, t2 = x;
if t1 = y, t2 = y;
if t1 = y, t2 = x;
or t1 = y, t2 = C;
otherwise.

R[W ] =

sc

Based on the above deﬁnition, we are able to prove the

following theorems.
Theorem 1 Suppose W is a LDL
regressable formula, then
the regression R[W ] deﬁned above terminates in a ﬁnite num-
ber of steps.
Proof:
Immediately follows from conditions (i) and (ii) of
the deﬁnition of LDL
regressable formula, acyclicity of the
TBox axioms, and from the assumption that RBox axioms
are compiled into the SSAs and consequently do not partici-
(cid:2)
pate in regression.
Theorem 2 Suppose W is a LDL
regressable formula with
the background basic action theory D. Then, R[W ] is a LDL
sc
formula uniform in S0 with no more than two variables (x

sc

sc

IJCAI07

1894

and y). Moreover,

D |= W iff DS0 |= R[W ].

D |= W ≡ R[W ],

and

sc

According to Theorem 2, D |= W iff DS0

Proof: According to the deﬁnition of the modiﬁed regres-
sion operator, prove by induction over the structure of W .
The ﬁrst statement holds because all replacements done by
R transform W to logically equivalent formula. The sec-
ond statement follows from the regression theorem in [Reiter,
(cid:2)
2001].
Theorem 3 Suppose W is a LDL
regressable formula with
the background basic action theory D. Then, the problem
whether D |= W is decidable.
|=
Proof:
R[W ], where R[W ] and the axioms in DS0 are C 2 formu-
las. Therefore, the problem whether D |= W is equivalent
to whether DS0 ∧ ¬R[W ] is unsatisﬁable or not, which is a
decidable problem, according to the fact that the satisﬁability
(cid:2)
problem in C 2 is decidable.
This theorem is important because it guarantees that the
projection and executability problems in LDL
sc are decidable
even if the initial KB DS0 is incomplete. [Gu and Soutchan-
ski, 2006] give some detailed examples that illustrate the ba-
sic reasoning tasks described above and reduction techniques
for dealing with properties that need more than two variables,
and show that using LDL
sc , one can model realistic dynamic
domains such as school enrollment services and on-line shop-
ping services.

We say that the SSA for a ﬂuent F is context-free if the
SSA for F has the form
F ((cid:2)x, do(a, s)) ≡ γ+

F ((cid:2)x, a) ∨ F ((cid:2)x, s) ∧ ¬γ−

F ((cid:2)x, a).

Then, we have the following theorem about the complexity
analysis for reasoning about projection problem.
Theorem 4 Given a basic action theory D in LDL
sc , suppose
that the SSA for a ﬂuent F is context-free, then the com-
putational complexity of answering the queries of the form
F ( (cid:2)X, σ) is co-NEXPTIME, where (cid:2)X is a vector of object
constants and σ is a ground situation term.
Proof:
The result follows from the complexity analysis of
projection problem in [Reiter, 2001] (Chapter 4), Theorem 3,
and the theorem in [Pratt-Hartmann, 2005] that the satisﬁa-
(cid:2)
bility problem in C 2 is decidable in NEXPTIME.

5 Progression of CN F -based KBs
The progression problem (also known as ﬁltering and update)
is how to compute the new theory in response to a given se-
quence of actions. In this section, we consider the progres-
sion problem for KBs in language LDL
sc . In this section, let
D = Dss ∪ Dap ∪ Σ ∪ Duna.
A formal deﬁnition of (classical) progression is given in
[Reiter, 2001]. A set of sentences DSα is the (classical) pro-
gression of the initial KB DS0 (wrt basic action theory D) af-
ter performing a ground action α in the situation S0 iff DSα is
uniform in do(α, S0), D |= DSα, and for every model Mα of
D ∪DSα, there is a model M of D such that M and Mα have
the same domain and interpret situation independent predi-
cates, function symbols, P oss and all ﬂuents about the future
of do(α, S0) identically (in the sequel, we say that M and Mα

sc

sc

sc

have a progression relationship). The progression can be iter-
atively repeated if the progressed KB has the same format as
the initial KB and we can consider the computed progression
as the new initial KB at the next iteration. [Lin and Reiter,
1997] shows that the (classical) progression of a ﬁnite FO
KB is not always FOL deﬁnable (but it is always deﬁnable in
the second-order logic). By using an example similar to [Lin
and Reiter, 1997], one can prove
Theorem 5 Progression of a theory in LDL
is not always FO
deﬁnable, therefore it is deﬁnitely not deﬁnable in LDL
sc .
We consider the theory D1 obtained by modify-
Proof:
ing the theory D given in [Lin and Reiter, 1997] as follows:
(1) replace one constant symbol 0 in D by an inﬁnite set of
constant symbols {0, 1, 2,···}; (2) replace function symbol
succ(x) = y in D by predicate succ(x, y) which will be true
iff y is the successor of x; (3) replace the empty initial KB
by the new DS0 which includes inﬁnitely many axioms of the
form c1 (cid:14)= c2 for any non-identical constant symbols c1 and
c2 given above and of the form succ(c, c(cid:4)) where constant c(cid:4)
is the successor of constant c in the sense of natural numbers.
The rest of the proof is exactly the same as the proof given in
(cid:2)
[Lin and Reiter, 1997].
theory D1 is
inﬁnite. The problem whether progression of a ﬁnite theory
in LDL

Notice that the proof assumes that an LDL

is always FO deﬁnable remains open.

Now, we consider a (weaker than classical) modiﬁed pro-
gression for certain type of incomplete KBs only. For this
special case of incomplete KBs, we show below that a mod-
iﬁed progression of a KB is in LDL
and it is sound wrt a
classical progression of this KB.

First, we restrict the syntactic form of the KBs that are al-
lowed. We use e to range over ewffs, that is, quantiﬁer-free
boolean formulas with equalities and inequalities only. For
any vector (cid:2)x that is (cid:8)x, y(cid:9) (or a variable x, or y) and any vec-
tor of object constants (cid:2)B that is (cid:8)B1, B2(cid:9) (or a single constant
B), we write (cid:2)x = (cid:2)B as an abbreviation for x = B1 ∧ y = B2
(or x = B, respectively). We use l((cid:2)x, S) to range over ﬂuent
literals, where S is a ground situation term. We call formu-
las of the form ∀(cid:2)x.e((cid:2)x) ⊃ l((cid:2)x, S) equality-based formulas.
We deﬁne a CNF-based KB DS =KBI ∪ KBS, where KBI
is a set of situation-independent formulas (including unique
name axioms for object constants, i.e., KBI is a subset of
DS0), and KBS is a ﬁnite set of sentences uniform in S,
where each sentence (also called clause below) is a disjunc-
tion of ﬁnitely many equality-based formulas.
In particular,
DS0 =KBI ∪KBS0. A CNF formula composed from ground
ﬂuent literals uniform in S is a simple example of KBS.
Secondly, we consider an action theory D that is local-
effect. Let a SSA of a ﬂuent F have the syntactic form
F ((cid:2)x, do(a, s)) ≡ γ+
F ((cid:2)x, a, s). This
F ((cid:2)x, a, s) are disjunc-
SSA is local-effect if γ+
tions of formulas of the form ∃(cid:2)z[a = A((cid:2)y) ∧ φ((cid:2)y, s)], where
A is a action function, (cid:2)y contains (cid:2)x, (cid:2)z = (cid:2)y − (cid:2)x, and φ is
quantiﬁer-free. An action theory D is local-effect if each SSA
in D is local-effect. Let ∗ be + or −. Consider a ground ac-
tion α and a ﬂuent Fi in a local-effect action theory D of
language LDL
sc , then it is easy to see that the right-hand side
(RHS) of SSA for Fi((cid:2)x, do(α, s)) has the following syntactic

F ((cid:2)x, a, s) ∨ F ((cid:2)x, s) ∧ ¬γ−

F ((cid:2)x, a, s) and γ−

sc

IJCAI07

1895

(cid:3)m+

ik(s)) ∨ Fi((cid:2)x, s) ∧ ¬(cid:3)m−

i

ik ∧ φ+

i

ik(s)),

k=1((cid:2)x = (cid:2)B+

where each m∗

k=1((cid:2)x =
form:
ik ∧ φ−
(cid:2)B−
i is a natural number, the
variables in (cid:2)x are among x and y, and for each k, φ∗
ik(s)
is a propositional formula. This SSA is a special case of the
generic SSA (1) from Section 3. Moreover, according to The-
orem 3 the problem whether D |= φ∗
ik(S) is decidable for
each k and any ground situation S. We deﬁne the following
W
abbreviations.
W
Add(Fi, α, S)def=
Add(¬Fi, α, S)def=
Delete(Fi, α, S)def=

i |D|=φ+
i |D|=φ−

{k∈1..m−

{k∈1..m+

ik ∧ ¬

ik

ik

(S)} (cid:3)x = (cid:3)B+
ik,
_
(S)} (cid:3)x = (cid:3)B−
ik,
_

{k | D|=¬φ−

ik

_
(cid:3)x = (cid:3)B−
_

i

k=1..m−

ik

(cid:3)x = (cid:3)B−
(S)}
(cid:3)x = (cid:3)B+
ik
(S)}

Delete(¬Fi, α, S)def=

(cid:3)x = (cid:3)B+

ik ∧ ¬

k=1..m+
i

{k | D|=¬φ+

ik

When there is no disjunct satisfying the condition on the con-
text formula φ∗
ik, the corresponding disjunction is equivalent
to ⊥. It is easy to see that all formulas above are ewffs.
The intuition behind these abbreviations is simple. For
instance, Add(Fi, α, S) is a collection of all those cases
when Fi will become true in every model if the context
ik(S) holds in S. Therefore, these cases provide support
φ+
for adding the ﬂuent Fi to the new KB. If one takes all those
cases (cid:2)x = (cid:2)B−
ik when Fi ceases to be true in some models
(where contexts might or might not be entailed) and removes
from them those cases when negations of contexts are known
to be entailed (i.e., remove models where it is guaranteed
that Fi will not cease to be true), then as a result one gets
Delete(Fi, α, S) that represents the collections of all those
objects for which Fi has to be deleted from the current KB.
Now consider a ground action α and a CNF-based KB
DS = KBI ∪ KBS as the current KB of a local-effect BAT
D =D ∪ DS. Assume that D |= P oss(α, S), otherwise there
is no need in progression. We provide an algorithm to com-
pute a variant of progression, called a modiﬁed progression of
DS wrt D and the ground action α executed in S, and denote
the resulting KB as P(α,DS).
Let P(α,DS) be the following set of sentences:
1. Initialize P(α,DS) to

KBI∪
{(∀(cid:3)x)Add(Fi, α, S) ⊃ Fi((cid:3)x, do(α, S)) | Add(Fi, α, S) (cid:10)≡ ⊥}∪
{(∀(cid:3)x)Add(¬Fi, α, S) ⊃ ¬Fi((cid:3)x, do(α, S)) | Add(¬Fi, α, S) (cid:10)≡ ⊥}.
2. For each clause in KBS of the form Cj = p1 ∨ ··· ∨ ph ∨ ··· ,
where each ph is an equality-based formula (∀(cid:3)x)ejh ((cid:3)x) ⊃
ljh ((cid:3)x, S) and ljh is either Fi or its negation ¬Fi, we update
this clause as follows.
(a) Initialize a temporary set T = ∅.
(b) For each ph, if
KBI ∪ {(∀(cid:3)x)ejh ((cid:3)x) ∧ ¬Delete(ljh , α, S)} (cid:10)|= ⊥, add
(∀(cid:3)x)ejh ((cid:3)x) ∧ ¬Delete(ljh , α, S) ⊃ ljh ((cid:3)x, do(α, S))
into the set T .

(c) If T (cid:10)= ∅, add a new clause C(cid:2)
otherwise, do nothing (i.e., replace Cj with (cid:14)).

p∈T p to P(α,DS);
It is easy to see that the resulting KB P(α,DS) remains to
sc . Therefore, such progression can

be a CNF-based KB in LDL
be repeated for the next ground action, say α(cid:4).

W

j =

The intuition behind this algorithm is simple. The succes-

sor model of the KB after performing a ground action at the
current situation should keep all the situation-independent in-
formation, add truth values for each ﬂuent for those objects
where it will deﬁnitely become true (or false), and also keep
the remaining consistent information by removing conﬂict-
ing knowledge for objects from the current KB. Note that
we detect conﬂicts between cases supported by ejh and cases
, α, S) condition by using unique
included in the Delete(ljh
name axioms for constants in KBI, if necessary, to solve the
entailment problem in (b).
For any given BAT D = D ∪ DS and a ground action α,
we say that a modiﬁed progression P(α,DS) is (classically)
sound if any model of the classical progression of DS (wrt
α and D) is a model of the modiﬁed progression. Also, we
say that P(α,DS) is (classically) complete if every model of
D ∪ P(α,DS) is a model of the classical progression of DS
(wrt α and D). The modiﬁed progression has the following
nice properties.
Theorem 6 Given a BAT D with the current KB DS and a
ground action α then
(1) If D is consistent and RHS of SSAs are consistent, then
the modiﬁed progression P(α,DS) is also consistent.
(2) The modiﬁed progression P(α,DS) is (classically) sound.
Proof: (1) Prove by cases using the deﬁnition of P(α,DS).
(2) According to the deﬁnition of P(α,DS), prove that D |=
P(α,DS) using the RHS of the SSAs for Fi((cid:2)x, do(α, S)).
Let Mα be any model of the (classical) progression of DS.
Then, there is a model M of D such that M and Mα have
a progression relationship. Then M is also a model of
P(α,DS) by D |= P(α,DS), and then since M and Mα
have a progression relationship we can prove that Mα is a
model of any sentence uniform in do(α, S) iff M is a model
of any sentence uniform in do(α, S). Therefore, we conclude
that Mα is a model of P(α,DS) because P(α,DS) is a set of
(cid:2)
sentences uniform in do(α, S).

6 Discussion and Future Work
The major consequence of the results proved above for the
problem of service composition is the following.
If both
atomic services and properties of the world that can be af-
fected by these services have no more than two parameters,
then we are guaranteed that even in the state of incomplete in-
formation about the world, one can always determine whether
a sequentially composed service is executable and whether
this composite service will achieve a desired effect. The
previously proposed approaches made different assumptions:
[McIlraith and Son, 2002] assumes that the complete infor-
mation is available about the world when effects of a com-
posite service are computed, and [Giacomo et al., 1999] con-
siders the propositional fragment of the SC.

As we mentioned in Introduction, [McIlraith and Son,
2002] propose to use Golog for composition of Semantic
Web services. It is surprisingly straightforward to deﬁne al-
most all Golog operators starting from our C 2 based SC. The
only restriction in comparison with the original Golog [Re-
iter, 2001] is that we cannot deﬁne the operator (πx)δ(x),
non-deterministic choice of an action argument, because LDL

sc

IJCAI07

1896

regressable formulas cannot have occurrences of non-ground
action terms in situation terms.
The recent paper [Baader et al., 2005] proposes integration
of description logics ALCQIO (and its sub-languages) with
an action formalism for reasoning about Web services. We
discuss that paper in [Gu and Soutchanski, 2006].

An interesting paper [Liu and Levesque, 2005] aims to
achieve computational tractability of solving projection and
progression problems. The theory of the initial KB is as-
sumed to be in the so-called proper form (i.e., conjunctions
of equality-based formulas) and the query used in the projec-
tion problem is expected to be in a certain normal form. They
consider a weaker type of progression deﬁned for proper KBs
with local effect actions only and show that their progression
is sound (and sometimes complete) wrt the classical progres-
sion. We also consider local effect action theories, but our
CNF-based KB is a set of disjunctions of equality-based for-
mulas. However, [Liu and Levesque, 2005] considers a SC
formulated in a general FOL (where the entailment problem
is undecidable) and impose no restrictions on arity of ﬂuents.
Because of these signiﬁcant differences in our approaches, it
is not possible to compare them.

It is obvious that all cases from [Lin and Reiter, 1997;
Shirazi and Amir, 2005; Liu and Levesque, 2005] when the
progression is FOL deﬁnable also can be applied to our case
simply because we restrict the language to two object vari-
ables only. However, we do the disjunctive case that nobody
did before. Also, [Liu et al., 2006] considers update of an
ABox in a DL following [Winslett, 1990] and also mentions
that update can be applied to a boolean ABox formulated in
C 2, but their update is deﬁned in terms of a conjunction of
primitive ﬂuent literals, i.e., it is different from our progres-
sion because our update is deﬁned in terms of changes in the
theory due to a ground action. [Giacomo et al., 2006] gener-
alized the update approach of [Liu et al., 2006] from ALC to a
more expressive DL language DL-Lite which allows general
inclusion assertions in TBox , showed that the result of an up-
date is always expressible by a DL-Lite ABox and provided
a polynomial-time algorithm that computes the update over a
DL-Lite KB.
The most important direction for future research is efﬁcient
implementation of practical scenarios of reasoning in LDL
sc .
Although in general, the worst-case computational complex-
ity for the reasoning problems in LDL
is high, some practi-
cal scenarios may facilitate empirically efﬁcient solutions to
the projection and executability problems. We are planning
to consider also the progression problem for a more general
class of incomplete KBs and conditions when the modiﬁed
progressions is (classically) complete.
Acknowledgments
Thanks to the Natural Sciences and Engineering Research
Council of Canada and to the Department of Computer Sci-
ence of the University of Toronto for partial ﬁnancial support.

sc

References
[Baader et al., 2003] Franz Baader, Diego Calvanese, Deb-
orah McGuinness, Daniele Nardi, and Peter F. Patel-
Schneider, editors. The Description Logic Handbook:

Theory, Implementation, and Applications. Cambridge
University Press, 2003.

[Baader et al., 2005] Franz Baader, Carsten Lutz, Maja
Miliˆci´c, Ulrike Sattler, and Frank Wolter. Integrating de-
scription logics and action formalisms: First results.
In
Proc. of AAAI-05, pages 572–577, Pittsburgh, USA, July
2005. An extended version: LTCS-Report-05-02 from
http://lat.inf.tu-dresden.de/research/reports.html.

[Borgida, 1996] Alexander Borgida. On the relative expres-
siveness of description logics and predicate logics. Artiﬁ-
cial Intelligence, 82(1-2):353–367, 1996.

[Giacomo et al., 1999] Giuseppe De Giacomo, Luca Iocchi,
Daniele Nardi, and Riccardo Rosati. A theory and im-
plementation of cognitive mobile robots. J. of Logic and
Computation, 9(5):759–785, 1999.

[Giacomo et al., 2006] Giuseppe De Giacomo, Maurizio
Lenzerini, Antonella Poggi, and Riccardo Posati. On
the update of description logic ontologies at the instance
level.
In Proc. of AAAI-06, pages 1271–1276, Boston,
MA, USA, July 2006. AAAI Press.

Gu

[Gu and Soutchanski, 2006] Yilan

and Mikhail
Soutchanski. A logic for decidable reasoning about
services.
In Proceedings of AAAI-06 workshop on AI-
Driven Technologies for Services-Oriented Computing,
Boston, MA, USA, 2006.
http://www.cs.toronto.edu/˜
yilan/publications/papers/aaai06.pdf.

[Lin and Reiter, 1997] F. Lin and R. Reiter. How to progress

a database. Artiﬁcial Intelligence, 92:131–167, 1997.
[Liu and Levesque, 2005] Yongmei Liu and Hector

J.
Levesque. Tractable reasoning with incomplete ﬁrst-order
knowledge in dynamic systems with context-dependent
actions. In Proc. of IJCAI-05, pages 522–527, Edinburgh,
Scotland, UK, August 2005.

[Liu et al., 2006] H. Liu, C. Lutz, M. Milicic, and F. Wolter.
Updating description logic ABoxes. In Proc. of KR2006,
pages 46–56, Lake District, UK, June, 2-5 2006.

[McIlraith and Son, 2002] Sheila McIlraith and Tran Son.
Adapting Golog for composition of semantic web services.
In Proc. of KR2002, pages 482–493, Toulouse, 2002.

[Pacholski et al., 1997] Leszek Pacholski, Wiesław Szwast,
and Lidia Tendera. Complexity of two-variable logic with
counting. In Proc. of LICS-97, pages 318–327, Warsaw,
Poland, 1997. A journal version: SIAM Journal on Com-
puting, v 29(4), 1999, p. 1083–1117.

[Pratt-Hartmann, 2005] Ian Pratt-Hartmann. Complexity of
the two-variable fragment with counting quantiﬁers. Jour-
nal of Logic, Lang. and Inf., 14(3):369–395, 2005.

[Reiter, 2001] Raymond Reiter. Knowledge in Action: Logi-
cal Foundations for Describing and Implementing Dynam-
ical Systems. The MIT Press, 2001.

[Shirazi and Amir, 2005] Afsaneh Shirazi and Eyal Amir.
In Proc. of IJCAI-05, pages

First-order logical ﬁltering.
589–595, Edinburgh, Scotland, UK, 2005.

[Winslett, 1990] Marianne S. Winslett. Updating logical

databases. The Academic Press, 1990.

IJCAI07

1897

